![[Pasted image 20251223220310.png]]
### Что такое Операционная Система (ОС)?

Если говорить просто, **операционная система** — это не просто красивая оболочка Windows или macOS. Это совокупность пользовательских и системных программ, которые позволяют нам эффективно использовать компьютер.

**Что она делает конкретно?**

1. **Управляет ресурсами**: Решает, какой программе дать поработать на процессоре прямо сейчас, а какой подождать.
    
2. **Абстрагирует железо**: Тебе как программисту не нужно знать, как физически вращается диск, чтобы сохранить файл. Ты просто вызываешь команду `save()`, а ОС сама разбирается с моторами и головками диска.
    
3. **Обеспечивает безопасность**: Следит, чтобы одна программа не могла залезть в память другой или удалить чужие файлы.

### История для + вайба

### Эпоха I: Ламповые машины и «ручное» управление (1945–1955)

**Контекст и технологии:** В это десятилетие компьютер был не персональным устройством, а колоссальным военным или научным проектом. Эти машины (например, знаменитый ENIAC) занимали огромные залы, потребляли электроэнергию на уровне небольшого городского квартала и стоили целое состояние. Сердцем системы были **вакуумные лампы**. Они были размером с палец, дико грелись и перегорали каждые 15–20 минут. Если в машине 20 тысяч ламп, поиск сгоревшей превращался в отдельный квест.

**Ключевые фигуры:**

- **Джон фон Нейман:** Человек-легенда. Он предложил архитектуру, где программа (инструкции) и данные хранятся в одной и той же памяти. Он сказал: «Давайте запишем команды цифрами и положим их в ту же память, что и числа». **Это ключевой момент: без этой идеи ОС была бы невозможна**, так как ОС — это программа (данные), которая управляет другими программами (тоже данными).
    
- **Конрад Цузе:** Пионер автоматизации, создавший первые программируемые машины, которые доказали, что вычисления могут быть гибкими.
    

**Как работал процесс:** Операционных систем не существовало. Учёный бронировал время, заходил в зал и вручную переставлял провода на коммутационных панелях и щелкал тумблерами, задавая начальные значения битов. Весь код писался в машинных кодах (нули и единицы). Не было даже языков программирования, не говоря уже об отладчиках.

**Главная проблема:** Чудовищная неэффективность. Процессор — самая дорогая часть — простаивал 90% времени, пока человек возился с проводами или менял перегоревшую лампу. ОС была не нужна, потому что компьютер обслуживал только одного человека и одну задачу за раз.

---

### Эпоха II: Транзисторы и пакетная обработка (1955–1965)

**Технологический скачок:** Изобретение **транзистора** изменило мир. Компьютеры стали меньше, надежнее и быстрее. Появился термин **Mainframe (Мейнфрейм)** — мощный вычислительный центр. Теперь компьютеры начали покупать крупные банки и корпорации.

**Разделение ролей и перфокарты:** Впервые произошло разделение: программист больше не трогал компьютер. Он писал код на бумаге, переносил его на **перфокарты** (картонные карточки с дырочками) и отдавал стопку оператору. Если ты ошибалась в одной букве, ты узнавала об этом только на следующий день, когда получала распечатку с ошибкой.

**Рождение первой ОС:** Чтобы компьютер не ждал, пока медленный человек загрузит карточки, придумали **пакетную систему (batch system)**. Появилась специальная программа — **резидентный монитор**. Она называлась «резидентной», потому что всегда оставалась в памяти (внизу или вверху адресного пространства).

**Как это работало технически:** Программист писал код на языке FORTRAN или ассемблере, пробивал перфокарты. Первая карта в колоде была «командной» (например, `$JOB` или `$FORTRAN`). Монитор читал её и понимал: «Ага, сейчас нужно запустить компилятор».

- **Функции монитора:** Автоматически считывать задачу с ленты, загружать её, запускать и, как только она закончит, тут же подгружать следующую.
    

**Главная проблема:** Полное отсутствие интерактива. Ты был отрезан от машины. Цикл «сдал задачу — получил результат» занимал сутки.

---

### Эпоха III: Интегральные схемы и мультипрограммирование (1965–1980)

**Аппаратная революция:** Появились **интегральные схемы** (десятки транзисторов на одном кристалле). Это дало рост скорости и памяти. Появились **магнитные диски**, которые позволяли мгновенно прыгнуть к любому файлу (в отличие от лент, которые нужно было долго перематывать).

**Мультипрограммирование и разделение времени:** Это самый важный этап. Процессоры стали такими быстрыми, что устройства ввода-вывода (принтеры, диски) не успевали за ними.

1. **Мультипрограммирование:** ОС научилась держать в памяти сразу несколько программ. Пока одна ждет данных с диска, ОС переключает процессор на вторую. Так родился **планировщик**.
    
2. **Time-sharing (Разделение времени):** К одной машине подключили много терминалов. ОС давала каждому пользователю по несколько миллисекунд. Человеку казалось, что компьютер работает только на него, хотя на самом деле за ним сидело 50 человек.
    

**Рождение UNIX:** Кен Томпсон и Деннис Ритчи устали от огромных и сложных ОС того времени (типа Multics) и написали «простую» систему. Они создали язык **C** специально, чтобы переписать Unix. До этого ОС писались на ассемблере под конкретное «железо». Unix стал первой «переносимой» системой и ввела философию «всё есть файл». На этом фундаменте построены современные Linux и macOS.

**Новые проблемы:** ОС стали «монстрами» — миллионы строк кода. Так как в памяти теперь лежало сразу несколько программ (твоя, соседа и сама ОС), возникла проблема: одна программа могла случайно (или специально) затереть данные другой. Появилось разделение на **Режим пользователя (User Mode)** и **Режим ядра (Kernel Mode)**.

---

### Эпоха IV: Персональные компьютеры и сети (1980 – наши дни)

**Демократизация:** Появились микропроцессоры. Компьютер переехал из огромного зала на рабочий стол. Теперь один компьютер принадлежал одному человеку.

**GUI и Пользователь:** ОС перестала быть просто черным экраном с текстом. Появился **Графический интерфейс (GUI)**: окна, мышь, иконки. Удобство для обычного человека стало важнее, чем максимальная эффективность процессора.

---
- **GUI (Графический интерфейс):** Исследователи из Xerox PARC (а затем Стив Джобс) поняли: люди не хотят учить команды `chmod` или `ls`. Им нужны метафоры: «рабочий стол», «корзина», «папка».
    
- **Сетевой стек:** В 90-е годы ОС перестали быть автономными. В ядро пришлось встраивать сложнейшие механизмы обработки сетевых пакетов (TCP/IP).
    
- **Современность:** Сейчас мы живем в эпоху **Виртуализации**. Твоя ОС может запускать внутри себя другую ОС (контейнеры Docker, виртуальные машины). Это возвращение к идеям 60-х (разделение ресурсов), но на космических скоростях.
---

**Два пути развития:**

1. **Мир Windows:** Путь от простых систем типа MS-DOS (сначала без защиты памяти) к массовому пользователю.
    
2. **Мир UNIX (Linux/macOS):** Путь от надежных серверных и научных систем к современным красивым и стабильным интерфейсам.
    

**Сеть и облака:** С 90-х годов ОС перестала быть «островом». Теперь это узел глобальной сети. Современная ОС управляет не только твоим процессором, но и виртуальными машинами, контейнерами и облачными вычислениями.
## Главный итог всей истории

Каждая эпоха — **ответ на проблему предыдущей**.

| Эпоха | Главный вопрос                |
| ----- | ----------------------------- |
| I     | Как вообще считать?           |
| II    | Как не простаивать?           |
| III   | Как делить ресурсы?           |
| IV    | Как сделать удобно и массово? |
![[Pasted image 20251223220357.png]]

До середины 1940-х годов компьютеры вообще не воспринимались как универсальные машины. Каждый компьютер проектировался под **одну конкретную задачу**. Если машина считала баллистические таблицы, она была буквально «заточена» под это. Если нужно было решить другую задачу — например, расчёт для ядерной физики или метеорологии, — компьютер приходилось **физически переделывать**. Инженеры реально переставляли кабели, переключали панели, меняли конфигурацию схем. Логика вычислений была зашита в железо. Поэтому слово «программа» в современном смысле почти не существовало — был скорее «режим работы машины». Это занимало часы или даже дни, и всё это время сам компьютер простаивал.

И вот здесь появляется Джон фон Нейман. Он не строил компьютеры руками, как инженеры ENIAC, он был математиком и мыслителем, который задался вопросом: а **почему вообще логика вычислений должна быть в проводах?** В 1945 году, работая над проектом EDVAC, он формулирует идею, которая потом получила название концепции **хранимой программы**.  Он предложил рассматривать команды не как нечто физическое, а как **данные**, то есть как числа. Если числа можно хранить в памяти, значит и команды тоже можно хранить в памяти. А если команды лежат в памяти, то компьютер может сам читать их одну за другой и выполнять, не требуя вмешательства человека и перекоммутации схем.

Это звучит сейчас тривиально, но в тот момент это было революционно. По сути, фон Нейман сказал: «Давайте сделаем компьютер, который управляется не проводами, а собственной памятью». В этот момент компьютер впервые стал **универсальным**. Чтобы решить другую задачу, больше не нужно было трогать железо — достаточно было загрузить в память другую последовательность чисел, то есть другую программу. Именно здесь появляется то, что мы сегодня называем программным обеспечением.

Почему это критически важно для операционных систем? 
Потому что операционная система — это не особый режим железа, а **обычная программа**, пусть и очень привилегированная. Если бы команды нельзя было хранить в памяти и выполнять динамически, ОС была бы просто невозможна в принципе. Нельзя написать программу, которая запускает другие программы, если сама идея «программы как данных» не существует.

### Разбор схемы машины фон Неймана

Эта схема не описывает конкретный компьютер, а задаёт **абстрактную модель**, по которой до сих пор построено большинство процессоров. #### 1. Устройство управления (УУ / Control Unit)

Это «дирижер». Оно не умеет считать, но оно знает, что делать.

- Оно извлекает команду из памяти.
- Расшифровывает её (например: «Ага, нужно сложить два числа»).
- Дает сигналы остальным компонентам, что им делать.
#### 2. Арифметико-логическое устройство (АЛУ / ALU)

Это «работяга» или «калькулятор».

- Оно выполняет только математику (сложение, вычитание) и логику (сравнение: больше/меньше).
- УУ говорит ему: «Возьми число из ячейки А и ячейки Б и сложи их», и АЛУ выдает результат.
- _Вместе УУ и АЛУ сегодня образуют то, что мы называем **CPU (Центральный процессор)**._
#### 3. Память (Memory / RAM)

Это общая «тетрадь», где вперемешку лежат:

- **Команды**: например, «прибавь 5».
- **Данные**: например, число «10». Для процессора всё это выглядит как последовательность нулей и единиц. Только УУ знает, какой байт считать командой, а какой — данными.
    
#### 4. Устройства ввода-вывода (I/O)

Это связь с внешним миром: клавиатура, мышь, монитор, диск. Через них данные попадают в память и уходят из неё.

### Принципы фон Неймана (коротко и важно):

1. **Принцип однородности памяти**: Команды и данные хранятся вместе. Процессор не различает их по виду, только по контексту.
    
2. **Принцип адресности**: Память состоит из ячеек, у каждой есть свой номер (адрес). ОС как раз занимается тем, что следит, по каким адресам лежат твои данные.
    
3. **Принцип последовательного выполнения**: Процессор берет одну команду, выполняет её, потом берет следующую.

### «Бутылочное горлышко»

У этой архитектуры есть одна большая проблема, которую называют **«Vaughan Neumann Bottleneck»** возникает знаменитое «узкое место фон Неймана». Поскольку и инструкции, и данные передаются по одной и той же шине, процессор часто вынужден ждать, пока нужная информация дойдёт из памяти. С ростом скорости процессоров это стало огромной проблемой. Именно поэтому появились кэши L1, L2, L3 — быстрые буферы между памятью и CPU. Это не отказ от архитектуры фон Неймана, а попытка сгладить её слабое место.


![[Pasted image 20251223225041.png]]
Если вернуться к архитектуре фон Неймана, процессор умеет выполнять только одну инструкцию за раз и ничего не знает ни о файлах, ни о сети, ни о том, что такое «браузер» или «редактор кода». Всё это — иллюзии, которые создаёт операционная система.
### 1. «ОС — это совокупность пользовательских и системных программ»

Многие думают, что ОС — это только ядро, но это не так. Это **совокупность программ**, часть из которых видна пользователю, а часть работает полностью в фоне

- **Системные программы** — это те, что идут «в комплекте»: проводник (explorer.exe), калькулятор, системные службы, которые проверяют обновления или ищут Wi-Fi.
    
- **Пользовательские программы** — это то, что ставишь ты (Chrome, игры, Telegram). ОС объединяет их всех, чтобы они работали как единый механизм.

### 2. «Ядро — её основная часть, отвечающая за управление ресурсами»

Если ОС — это государство, то **Ядро (Kernel)** — это правительство. это основная и самая привилегированная часть операционной системы. Его задача — управлять ресурсами компьютера и быть посредником между приложениями и оборудованием.

- Оно сидит в самом центре и решает: кому дать «деньги» (память), а кому «право голоса» (время на процессоре).
    
- Если программа зависла, именно ядро имеет власть её «убить», чтобы она не потянула за собой всё остальное.
    
### 3. «Ядро — это тоже программа, которая исполняется параллельно со всеми... за кулисами»

Это очень важный момент. Ядро — это не какой-то магический чип, это **код**, написанный людьми (чаще всего на языке C).

- Когда ты открываешь браузер, процессор выполняет код браузера. Но тысячи раз в секунду он переключается на код ядра, чтобы проверить: «А не пора ли дать поработать другой программе?», «А нет ли новых данных от мышки?».
    
- Это и называется «за кулисами»: ты видишь котика в интернете, а ядро в это время делает миллион микроскопических переключений.
    
### 4. «Предоставляет абстрактный интерфейс к оборудованию»

Почему вообще нельзя обойтись без ядра? Потому что ресурсы компьютера ограничены и опасны. Процессор один, память общая, диск общий, устройства ввода-вывода тоже общие. Если дать каждой программе прямой доступ к этому всему, система мгновенно превратится в хаос. Любая ошибка в программе могла бы стереть данные другой программы, повесить процессор или вывести систему из строя. Ядро  решает, какой процесс получит процессор в следующий момент времени, сколько памяти можно выделить программе, какие участки памяти ей запрещены, кто имеет право читать или писать файл и кто может работать с устройством.

- **Без ядра:** Если бы ты хотела написать в файл слово «Привет», тебе пришлось бы в коде программы указывать: «Поверни диск на 3 градуса, опусти магнитную головку, подай ток такой-то силы на пластину». Это кошмар.
    
- **С ядром:** Ты просто используешь команду `write()`. Ядро само знает, как общаться с драйвером диска. Оно прячет от тебя сложность «железа», давая удобные кнопки.

Программа не знает, как именно устроен жёсткий диск или сетевой адаптер. Она просто делает запрос: «прочитай файл», «отправь данные по сети», «выведи символ на экран». Ядро принимает этот запрос и уже само, через драйверы, общается с конкретным железом. Благодаря этому одна и та же программа может работать на разных компьютерах с разным оборудованием — ей не нужно знать, какая именно модель диска или видеокарты установлена.

---
Если ты хочешь увидеть, как твои программы «стучатся» к ядру, в Linux есть команда `strace`. Если запустить её перед любой программой (например, `strace ls`), ты увидишь бесконечный поток вызовов — это и есть те самые запросы к ядру за ресурсами.

---
Очень важный момент: ядро не «заменяет» приложения и не делает за них работу. Оно не считает формулы, не рисует интерфейсы и не принимает решения пользователя. Оно создаёт **условия**, в которых приложения могут безопасно и эффективно работать одновременно. Когда ты запускаешь программу, ядро создаёт для неё процесс. Когда программа запрашивает память, ядро выделяет ей адресное пространство. Когда программа завершает работу, ядро освобождает ресурсы. Всё это происходит постоянно и прозрачно.

С точки зрения пользователя кажется, что всё работает само собой: ты открываешь браузер, параллельно слушаешь музыку и печатаешь текст. С точки зрения процессора это просто быстрая последовательность инструкций, а вся иллюзия одновременности, изоляции и удобства создаётся ядром операционной системы.

Именно поэтому на этом слайде подчёркивается мысль, что ядро — это тоже программа. Это важно для понимания курса: операционная система не противопоставляется программам, она **сама является программным продуктом**, просто стоящим на самом нижнем уровне программного обеспечения и контролирующим всё остальное.

![[Pasted image 20251224000053.png]]

Этот слайд показывает, **как компьютер устроен по уровням абстракции**. Слева стрелка — это ключ ко всему: внизу находится самый низкий уровень абстракции, то есть максимально близко к физическому железу, а чем выше мы поднимаемся, тем меньше нас интересует, _как именно_ всё работает внутри, и тем больше мы думаем в терминах удобных понятий — файлов, программ, окон, кнопок.

---

### **Граница Software / Hardware**

- **Software (Программное обеспечение):** Всё, что выше и включая ISA _с точки зрения программирования_. Программист пишет код, который в итоге превращается в последовательность команд ISA. ISA — это **абстракция процессора для программиста**.
    
- **Hardware (Аппаратное обеспечение):** Всё, что ниже ISA — физическая реализация процессора (микроархитектура), шины, чипсеты, память, устройства. Инженеры-электронщики и схемотехники проектируют, как эффективно выполнять команды ISA.
    

**Главный принцип:** Каждый уровень использует интерфейс уровня ниже и предоставляет свой, более удобный интерфейс уровню выше. Программисту приложения не нужно знать, как работает ABI, системному программисту — как устроена микроархитектура процессора, а инженеру по процессорам — как пишутся приложения. Это и есть **сила абстракции**.

---

#### 1. Уровень оборудования (Hardware) — Фундамент

Это то, что можно потрогать: процессор, планки памяти, контроллеры дисков. На этом уровне всё общение идет на языке **электрических импульсов** и битов.

1. **Execution Hardware:**
    
    - **Что это:** Физический процессор (CPU) и/или графический процессор (GPU), которые _реализуют_ ISA. Это "движок", который декодирует команды ISA и выполняет их. Внутри него — кэш-память, конвейеры, предсказатели переходов и другие сложные механизмы для повышения скорости.
    
    - На этом уровне: процессор выполняет инструкции, читает и пишет память, обрабатывает прерывания
    

    Если бы ОС не существовало:

    - программа могла бы напрямую выполнять любые инструкции
    - могла бы отключить прерывания
    - могла бы «сломать» всю систему
    
    Поэтому вводятся **режимы исполнения**:

    - **kernel mode** — для ОС
    - **user mode** — для приложений
        
2. **System Interconnect (Bus / Шина)— системная шина:**
    
    Это каналы связи между:
    - процессором
    - памятью
    - устройствами
    
    - **Примеры:** Шина памяти, PCI Express для плат расширения, DMI для соединения чипсета с процессором.
        
3. **Memory Translation / Управление памятью:**
    
    - **Что это:** Обычно часть процессора и ОС. Отвечает за трансляцию **виртуальных адресов** (которые видит программа) в **физические адреса** в оперативной памяти. Это основа для изоляции процессов, защиты памяти и механизма виртуальной памяти (когда места в ОЗУ не хватает, используется диск).
    
   Это аппаратные механизмы:

    - MMU (Memory Management Unit)
    - таблицы страниц
    - преобразование виртуальных адресов в физические
        
4. **Main Memory (оперативная память, RAM):**
    
    - **Что это:** Оперативная память — быстрая, энергозависимая память, где хранятся запущенные программы и их данные, с которыми процессор работает напрямую.
        
5. **I/O Devices and Networking (Устройства ввода-вывода и сеть):**
    
    - **Что это:** Вся периферия: диски (SSD/HDD), клавиатура, мышь, монитор, сетевая карта. У них своя, часто более медленная, скорость работы, и они подключаются к системе через контроллеры и шины.

### 2. Instruction Set Architecture

Это формальный контракт между железом и программами. Это набор команд (ассемблер), которые процессор «понимает». ISA определяет, какие инструкции вообще существуют(`add`, `mov`, `jmp`), как выглядит команда «сложить», какие регистры есть у процессора, как происходит переход по адресу, как процессор обращается к памяти, какие режимы работы есть (user / kernel). Для операционной системы ISA — это фундамент: ядро пишется строго под конкретную архитектуру процессора. Именно поэтому нельзя просто взять ядро Linux для x86 и запустить его на ARM без адаптации.

- **Что это:** Фундаментальный интерфейс между программным обеспечением и "железом". Это набор команд, которые процессор может понять и выполнить, а также модель памяти, регистры, режимы работы.

- **Примеры:** x86-64 (Intel/AMD), ARM (Apple M-series, смартфоны), RISC-V.
    
- **Задача:** Определить "архитектуру" процессора. Два процессора с одной и той же ISA (например, Intel Core i7 и AMD Ryzen) могут выполнять один и тот же машинный код, даже если их физическая реализация (микроархитектура) совершенно разная. **Это ключевая граница между "программированием" и "железом".**

### 3. Application Binary Interface (ABI)

- **Что это:** Низкоуровневое соглашение между программой и операционной системой или между разными программами. Оно определяет, как данные структурированы в памяти, как функции вызываются, как передаются аргументы и т.д. Это правила для «бинарников» (нулей и единиц). ABI определяет, в какой регистр процессора положить число перед вызовом функции и как именно данные должны лежать в памяти
    
- **Примеры:** Формат исполняемых файлов (например, ELF в Linux, PE в Windows), соглашения о вызовах (`cdecl`, `stdcall`).
    
- **Задача:** Обеспечить совместимость на уровне машинного кода. Благодаря ABI скомпилированная библиотека, написанная на одном языке, может быть использована программой, написанной на другом. Это то, что позволяет вашему ПО работать с конкретной ОС и процессором.

### 4. Application Programming Interface (API)

**API (Application Programming Interface) — Уровень человеческого языка**

- **Что это:** Набор готовых классов, функций, структур данных, протоколов и инструментов для создания приложений.
    
- **Примеры:** Windows API, POSIX API для Linux/Unix, OpenGL для графики, TensorFlow для машинного обучения .POSIX — это стандарт API, благодаря которому твоя программа на C будет одинаково компилироваться и в Linux, и в macOS.
    
- **Задача:** Предоставить программисту унифицированный, удобный и высокоуровневый способ использовать сервисы операционной системы, библиотеки и оборудование, не вникая в детали их реализации.

```
malloc()
read()
write()
```

**Слой ПО (Application & Libraries):** Здесь живут твои лабы на C. Они используют библиотеки (Libraries), чтобы не писать всё с нуля. Библиотеки «стучатся» в API.

**Слой ОС (Operating System):** Она стоит «ногами» на ISA. ОС — это программа, которая использует команды процессора (ISA), чтобы управлять памятью и дисками. Она — главный дирижер.

### Уровень ниже ISA (Мир «железа»)

Тут магия программирования заканчивается и начинается физика.

1. **Execution Hardware:** Это сам кристалл процессора. Он «глотает» команды ISA и исполняет их. Внутри него — **Микроархитектура** (конвейеры, кэши).
    
    - _Интересный факт:_ У Intel и AMD разная внутренняя схема (микроархитектура), но одинаковая ISA. Поэтому одна и та же игра работает на обоих.
        
2. **Memory Translation (Трансляция памяти):** Это «охранник» на входе в ОЗУ. Программа видит **виртуальный адрес** (сказочный мир), а этот блок переводит его в **физический адрес** (реальная ячейка памяти). Это защищает одну программу от другой.
    
3. **System Interconnect (Шины):** «Магистрали» данных. Если данные из памяти не приедут вовремя по шине, процессор будет просто греть воздух в ожидании.
    
4. **Main Memory & I/O:** Хранилища и периферия.
    
---
### Почему эта схема критически важна для твоего курса?

Весь курс «Оси» посвящен тому, как **ОС (середина схемы)** связывает **верхний мир (API/Приложения)** с **нижним миром (ISA/Железо)**.

- Если ты понимаешь **ISA**, ты понимаешь, как работает ассемблер.
    
- Если ты понимаешь **ABI**, ты понимаешь, почему программы ломаются при переезде на другую систему.
    
- Если ты понимаешь **Memory Translation**, ты понимаешь, почему одна программа не может украсть пароли из другой.
![[Pasted image 20251224000315.png]]

**Ядро (Kernel)** — это центральная, постоянно находящаяся в оперативной памяти часть операционной системы, которая представляет собой программный слой между аппаратным обеспечением (железом) и прикладным ПО.

Если говорить совсем просто: **это главная программа, которая управляет всем компьютером от имени пользователя.**

Ядро большую часть времени «спит». Оно просыпается только тогда, когда происходит какое-то событие:

- Программа вызвала функцию (Системный вызов).
- Железо подало сигнал (Прерывание).
- Произошла ошибка в программе (Исключение).

### Почему ядро «спит» и как оно «просыпается»?

Это фундаментальный принцип. Если бы ядро постоянно работало, оно бы занимало 100% мощности процессора, и программам ничего бы не досталось. Поэтому ядро — это **событийно-ориентированный механизм**.

#### Сигнал №1: Системный вызов (Инициатива программы)

Это «запланированное» событие. Программист сам вставляет в код инструкцию, которая вызывает ядро.

- **Пример:** Ты в коде на C написал `fopen("test.txt", "r")`.
- **Что происходит:** Процессор выполняет твою программу, доходит до этой функции, исполняет специальную инструкцию (например, `syscall`) и... замирает. Управление мгновенно переходит к ядру. Ядро «просыпается», открывает файл, отдает твоей программе дескриптор и снова «засыпает».

---
### Подробно о `syscall`

`syscall` — это специализированная инструкция в современных архитектурах (например, x86-64), предназначенная для максимально быстрого перехода в режим ядра.

**Что происходит на низком уровне, когда выполняется `syscall`?**

1. **Подготовка:** Приложение (или стандартная библиотека C, такая как `glibc`) помещает **номер системного вызова** (например, 1 для `write` в Linux x64) в регистр `rax` и аргументы в другие регистры (`rdi`, `rsi` и т.д.).
    
2. **Переход:** При выполнении инструкции `syscall`:
    
    - Процессор сохраняет адрес следующей инструкции пользователя (чтобы знать, куда вернуться).
        
    - Процессор загружает адрес входа в ядро из специального системного регистра (MSR - Model Specific Register).
        
    - Уровень привилегий меняется с 3 (пользовательский) на 0 (ядро).
        
3. **Обработка:** Ядро смотрит на номер в регистре `rax`, находит в своей **таблице системных вызовов** соответствующую функцию и выполняет её.
    
4. **Возврат:** После завершения ядро выполняет инструкцию `sysret` (или `iret`), которая возвращает процессор в пользовательский режим и восстанавливает выполнение программы с того места, где она прервалась.
    

### Зачем нужен `syscall`, если можно было бы просто вызвать функцию ядра?

Это вопрос безопасности и стабильности.

- **Изоляция:** Если бы приложения могли вызывать функции ядра напрямую через обычный `call`, они могли бы перепрыгнуть через проверки безопасности.
    
- **Единая точка входа:** `syscall` гарантирует, что управление попадет в строго определенное место в ядре, которое сначала проверит права доступа, а только потом выполнит действие.
    

**Интересный факт:** До появления инструкции `syscall` на старых процессорах x86 системные вызовы реализовывались через «программное прерывание» — инструкцию `int 0x80`. Это работало медленнее, так как процессору приходилось проходить через полную цепочку обработки прерываний.

---
#### Сигнал №2: Аппаратное прерывание (Hardware Interrupt) — Асинхронное событие

Это сигнал от физического устройства. Асинхронность означает, что прерывание может произойти в любой момент времени, независимо от того, какую инструкцию сейчас выполняет процессор.

- **Пример:** Ты нажала клавишу на клавиатуре или пришел пакет данных по Wi-Fi.
    
- **Что происходит:** Железо посылает электрический сигнал процессору. Процессор бросает всё (даже если он выполнял очень важные вычисления в браузере), сохраняет текущее состояние и прыгает в код ядра. Ядро обрабатывает нажатие кнопки и возвращает управление назад.
    

#### Сигнал №3: Исключение (Exception / Trap) — Синхронное ошибочное событие

Это реакция процессора на попытку выполнить недопустимую операцию.

- **Пример:** Деление на ноль или попытка прочитать память, которая тебе не принадлежит (тот самый `Segmentation Fault`). Процессор генерирует внутренний сигнал ошибки, который принудительно передает управление ядру для обработки инцидента (например, для отправки сигнала `SIGSEGV` процессу).
    
- **Что происходит:** Процессор понимает, что не может выполнить такую инструкцию. Он «будит» ядро со словами: «Тут программа сломалась, разберись». Ядро смотрит на безобразие и обычно просто «убивает» провинившийся процесс.

---
### 1. Распоряжение ресурсами и мультиплексирование

#### Какими ресурсами руководит ядро?

##### Физические ресурсы:

- **Процессор (CPU):** Главный ресурс. Ядро решает, кто именно сейчас будет выполнять команды на «камне» и как долго.
    
- **Оперативная память (RAM):** Ядро распределяет мегабайты между программами. Оно следит, чтобы Chrome не залез в память Telegram.
    
- **Устройства ввода-вывода:** Диски (SSD/HDD), видеокарта, сетевая плата, клавиатура. Ядро контролирует очередь к ним.
    
##### Абстрактные ресурсы (созданные ядром):

- **Процессы и потоки:** Программа на диске — это просто файл. Когда она оживает и начинает работать, ядро превращает её в «процесс».
    
- **Файлы:** На диске только намагниченные области, но ядро говорит нам: «Смотри, это текстовый файл с котиками».
    
- **Сокеты:** Это абстракция для сети. Для программы это «труба», в которую можно кинуть данные, а ядро само разберется с IP-адресами и пакетами.

**Мультиплексирование** — это организация совместного использования ограниченного ресурса несколькими потребителями таким образом, что каждый из них получает логически независимый доступ.

 Ресурсы компьютера (процессор, память, диск) ограничены, а программ много. Чтобы они не подрались, ядро использует два метода:

- **Мультиплексирование во времени (Time Multiplexing):**
    
    - **Что это:** Относится прежде всего к процессору. Поскольку CPU может выполнять только одну инструкцию в данный момент времени, ядро разбивает процессорное время на кванты и поочерёдно выделяет их различным процессам. Это реализуется планировщиком задач. С точки зрения процесса создаётся иллюзия непрерывного выполнения, хотя фактически он регулярно прерывается и возобновляется.
        
    - **Пример:** Твой процессор. У тебя может быть 4 ядра, а запущено 100 программ. Ядро ОС дает каждой программе поработать, скажем, 10 миллисекунд. Это происходит так быстро, что тебе кажется, будто музыка играет, а браузер грузится одновременно.
        
- **Мультиплексирование в пространстве (Space Multiplexing):**
    
    - **Что это:** Ресурс делится на части, и каждая программа получает свой «кусок».
        
    - **Пример:** Оперативная память или жесткий диск. Ядро выделяет браузеру один участок памяти, а плееру — другой. Они живут в памяти одновременно, но в разных «квартирах».
        
---

### 2. Сохранение целостности данных и защита


- **Защита пользователей:** Если на компьютере два пользователя, ядро следит, чтобы ты не могла прочитать файлы соседа без его разрешения.
    
- **Защита программ:** Это самое важное. Ядро следит, чтобы программа №1 не залезла в память программы №2.
    
    - _Как это работает:_ Помнишь, мы говорили про **Memory Translation** на прошлом слайде? Ядро настраивает железо так, что программа просто физически «не видит» чужую память. Если программа попытается туда прорваться, ядро её немедленно уничтожит (тот самый Segmentation Fault).
        
### 1. Разделение режимов: User Mode vs Kernel Mode

Процессоры (например, x86-64) имеют аппаратные «кольца защиты» (Protection Rings).

- **Приложения работают в Ring 3 (User Mode):** Здесь процессору запрещено выполнять опасные инструкции (например, выключать компьютер, обращаться к портам ввода-вывода или менять настройки памяти).
- **Ядро работает в Ring 0 (Kernel Mode):** Здесь разрешено всё.
    
**Как это защищает систему:** Если приложение попытается выполнить «запрещенку», процессор мгновенно остановит его выполнение и вызовет исключение (Exception), передав управление ядру. Ядро увидит, что программа хулиганит, и просто завершит её (тот самый «Программа выполнила недопустимую операцию»).

---

### 2. Виртуальная память: «Каждому — своя иллюзия»

Это самый глубокий уровень защиты целостности данных. Приложение никогда не работает с реальными физическими адресами в оперативной памяти (RAM).

- **Изоляция пространств:** Ядро создает для каждого процесса **иллюзию**, что ему принадлежит вся память компьютера. Приложение видит **виртуальные адреса**.
    
- **Таблицы страниц (Page Tables):** Ядро настраивает специальный узел в процессоре — **MMU (Memory Management Unit)**. В MMU лежит «карта», которая переводит виртуальный адрес программы в реальный физический адрес.
    
- **Аппаратный барьер:** Программа «А» физически не имеет в своей таблице страниц ссылок на память Программы «Б» или памяти Ядра. Для неё этой памяти просто не существует.
    

**Почему это предотвращает разрушение:** Если в программе «А» есть ошибка (например, кривой указатель в языке С), и она попытается записать данные по адресу, который ей не принадлежит, MMU скажет процессору: «Стоп! У этого процесса нет прав на этот адрес». Процессор генерирует **Page Fault**, ядро просыпается и говорит: «Извини, ты зашла не в ту дверь», и выдает `Segmentation Fault`. **Система при этом остается целой, так как запись в чужую память не произошла.**

---

### 3. Почему падение приложения не рушит систему (Hardware-Software контракт)

Когда приложение «падает» (например, из-за деления на ноль или ошибки доступа к памяти), происходит следующее:

1. **Процессор детектирует ошибку:** Это происходит на уровне транзисторов. Процессор понимает, что инструкция ошибочна.
    
2. **Переключение контекста:** Процессор автоматически сохраняет состояние упавшей программы и прыгает в код ядра (через таблицу прерываний, о которой мы поговорим на слайдах 17-18).
    
3. **Очистка ресурсов (Cleanup):** Ядро — это «чистильщик». Оно видит, что процесс мертв. Оно освобождает память, которую занимал процесс, закрывает открытые им файлы и сетевые соединения.
    
4. **Возврат в планировщик:** Ядро просто вычеркивает упавшую программу из списка «живых» и отдает процессорное время следующей программе (например, твоему плееру или рабочему столу).

---
**Интересный момент:** Система «падает» целиком (Синий экран в Windows или Kernel Panic в Linux) только в одном случае — если ошибка произошла **внутри самого ядра**. Поскольку у ядра есть доступ ко всему, его ошибка некому «перехватить». Если администратор сам поджег здание, выселять его некому.

---

### 3. Увеличение уровня абстракции (Программный интерфейс)

Железо — это очень неудобная штука. Оно понимает только вольты, сектора и прерывания.

- **Суть:** Ядро берет «страшное» железо и превращает его в «красивые» абстракции.
- **Пример с диском:**
    
    - _Реальность (Железо):_ Магнитная головка, номер цилиндра, номер сектора.
    - _Абстракция (Ядро):_ **Файл**. Тебе не надо знать, где он лежит физически, ты просто говоришь: `myfile.txt`.
        
- **Пример с сетью:**
    
    - _Реальность:_ Электрические пакеты в кабеле.
    - _Абстракция:_ **Сокет (соединение)**. Для тебя это просто «труба», в которую ты вливаешь данные, а они выходят на другом конце света.
  
Диск — это набор секторов.  
Сеть — это пакеты.  
Память — это адреса.

Ядро поднимает уровень абстракции и говорит программисту:

- «вот тебе файл, а не сектора»
- «вот тебе процесс, а не голый CPU»
- «вот тебе память, а не физические адреса»
- «вот тебе сокет, а не сетевой контроллер»
    
Этот интерфейс — системные вызовы — является **контрактом** между программой и ядром.

Программа не говорит:

> «запиши байты в сектор 183920»

Она говорит:

> «запиши в файл»

А **как именно** это сделать — решает ядро.
Именно благодаря этому:

- программы переносимы
- железо можно менять
- ОС можно развивать
---
    

**Полезный факт:** Когда ты в коде на C вызываешь `malloc()`, ты просишь ядро выполнить **пространственное мультиплексирование** — выделить тебе кусок памяти. А когда твоя программа ждет своей очереди на выполнение — это работает **временное мультиплексирование**.

![[Pasted image 20251228163813.png]]

## Архитектура фон Неймана
### Основные компоненты системы

1. **Центральный процессор (CPU / ЦП):**
    
    - **Устройство управления (Control Unit / УУ):** Это «командный центр». Оно считывает команду из памяти, расшифровывает её и подает сигналы всем остальным частям, что именно нужно сделать.
        
    - **Арифметико-логическое устройство (ALU / АЛУ):** «Работяга» системы. Выполняет все математические действия (сложение, вычитание) и логические операции (сравнения «больше/меньше», И/ИЛИ).
        
    - **Регистры:** Сверхбыстрая внутренняя память процессора для хранения промежуточных результатов.
        
2. **Память (Memory):** Единое адресное пространство, где лежат и команды (код программы), и данные (числа, текст). Процессору всё равно, что именно лежит в ячейке, пока УУ не интерпретирует это как команду.
    
3. **Устройства ввода-вывода (I/O):** Через них компьютер общается с внешним миром: получает команды от мышки/клавиатуры и выводит результат на экран или диск.
---

## **Что такое шины (Buses)?**

Внизу показаны **шины** — "магистрали" для передачи данных между компонентами:

- **Control bus (Шина управления)** — передает управляющие сигналы ("что делать")По ней процессор передает сигналы: «СЕЙЧАС ЧИТАЕМ» или «СЕЙЧАС ПИШЕМ». Без этой шины устройства не поймут, забирать данные с линии или, наоборот, выставлять их.

- **Address bus (Шина адреса)** — передает адреса ячеек памяти или устройств - Это указатели. Когда процессору нужно прочитать что-то из памяти, он выставляет на эту шину номер «дома» (адрес ячейки). Только то устройство, чей адрес совпал, открывает свои «ворота» для шины данных.

- **Data bus (Шина данных)** — передает собственно данные - По ним едут сами байты информации (текст, пиксели картинки). Чем она шире (например, 64 бита), тем больше данных за раз перевозится.

- **System bus (Системная шина)** — общее название для всех этих шин вместе


Главный недостаток этой схемы в том, что шина данных одна. Процессор работает в сотни раз быстрее, чем память. В итоге он часто простаивает, ожидая, пока данные приедут по узкой «дороге» шины. Чтобы это исправить, в современных компьютерах придумали кэш-память, но сама логика фон Неймана осталась прежней.

---

## **Как это все работает вместе (принцип фон Неймана):**

1. **CPU получает команду** из памяти через шины
2. **Control Unit декодирует команду** и решает, что делать
3. Если нужны данные — **CPU запрашивает их из памяти** через адресную шину
4. **Данные поступают в CPU** через шину данных
5. **ALU выполняет вычисления** с данными из регистров
6. **Результат сохраняется** обратно в память или отправляется на устройство вывода
7. **Устройства ввода** (клавиатура, мышь) могут прервать работу CPU, чтобы передать данные
    
---

## **Упрощенное объяснение на примере:**

**Вы печатаете текст в Word:**

- **Клавиатура (Input):** Ты нажимаешь кнопку. Контроллер клавиатуры подает сигнал на **Шину управления** (прерывание!).
- **CPU:** Бросает Word, переходит в режим ядра.
- **Ядро:** Читает по **Шине данных** код клавиши.
- **Memory:** Ядро пишет этот код в оперативку (через **Address + Data Bus**).
- **Output:** Ядро дает команду видеокарте отрисовать букву.

---
### Подробнее про память

**Main Memory** — это **Оперативная память (ОЗУ, RAM - Random Access Memory)**. Это быстрая, энергозависимая память, которая находится **"близко" к процессору** и используется для хранения данных и программ, **с которыми процессор работает прямо сейчас**.

### Ключевые характеристики:

1. **Скорость:** **Очень высокая**. В тысячи раз быстрее, чем жесткий диск. Процессор может получать данные из ОЗУ за наносекунды.
2. **Энергозависимость:** **Теряет данные при отключении питания**. Выключили компьютер — ОЗУ очистилась.
3. **Прямая связь с CPU:** Процессор обращается к ОЗУ **напрямую** через системную шину. Любая программа, чтобы выполняться, должна быть загружена в ОЗУ.
4. **Объем:** Относительно небольшой (обычно 8-64 ГБ в современных ПК). Дорогой в пересчете на гигабайт.
5. **Назначение:** **Временное рабочее пространство**. Хранит:
    
    - Код запущенных программ (браузер, Word, игра)
    - Данные, с которыми эти программы работают (открытый документ, вкладки браузера)
    - Часть операционной системы, которая нужна прямо сейчас

**Secondary Memory** — это **устройства долговременного хранения данных**. Это память, которая **сохраняет информацию при выключении питания**. Она находится **"дальше" от процессора** и работает намного медленнее.

### Ключевые характеристики:

1. **Скорость:** **Относительно низкая** (особенно HDD). SSD быстрее, но всё равно медленнее ОЗУ.
2. **ЭнергоНЕзависимость:** **Сохраняет данные при отключении питания**. Ваши файлы остаются на диске, даже когда компьютер выключен.
3. **Косвенная связь с CPU:** Процессор **не может работать с данными напрямую** с диска. Данные должны быть сначала скопированы в ОЗУ.
4. **Объем:** **Очень большой** (обычно 256 ГБ - 4 ТБ и более). Дешевый в пересчете на гигабайт.
5. **Назначение:** **Долговременное хранилище**. Хранит:
    
    - Операционную систему (Windows, Linux)
    - Все установленные программы
    - Все ваши файлы (документы, фото, видео, музыка)
    - Резервные копии

![[Pasted image 20251228170440.png]]

>**Memory-mapped I/O** — это способ подключения устройств к процессору, при котором  
>**устройство выглядит для процессора как участок памяти**.

Идея **Memory-mapped I/O** начинается с очень простого, но мощного допущения:  
для процессора **не существует принципиальной разницы между памятью и устройствами ввода-вывода**. Процессор умеет делать только две базовые операции — читать и писать по адресу. Поэтому архитекторы решили: пусть устройства выглядят так, будто они просто занимают часть адресного пространства памяти.

Это означает, что некоторым диапазонам адресов не соответствует оперативная память, а соответствует **устройство**. Когда процессор пишет по такому адресу, он на самом деле не записывает байт в RAM, а посылает команду конкретному железу. Когда он читает — он получает данные не из памяти, а из регистра устройства.

Именно это и называется memory-mapped I/O: ввод-вывод, отображённый в память.

---
### Простым языком

Процессор **не умеет**: рисовать на экране, читать с диска, отправлять данные по сети.

Процессор умеет **только одно**:  
👉 читать данные из адреса и писать данные в адрес.

---
Теперь вспоминаем архитектуру фон Неймана.
У процессора есть:
- регистры
- арифметика,
- шина,
- и **единое адресное пространство**.

Адресное пространство — это просто воображаемая линейка адресов:

`0x00000000  ...  0xFFFFFFFF`

Когда процессор выполняет инструкцию вроде:

`MOV [0xB8000], AX`

он **не знает**, что находится по адресу `0xB8000`.  
Он не знает, «память это или устройство».  
Он просто кладёт значение на шину и говорит:  
«Я хочу записать вот это по адресу 0xB8000».

---

И вот тут появляется железо **вокруг** процессора. За пределами CPU находятся:

- контроллер памяти,
- чипсет,
- видеокарта,
- другие устройства.

И они договорились о следующем правиле:

> «Если процессор обращается к одним адресам — это RAM.  
> Если к другим — это видеоустройство.  
> Если к третьим — это ещё что-то.»

Это **аппаратное соглашение**, а не программа.

---

### 1. Что такое VGA?

Представь старый компьютер, где на черном экране горят белые или зеленые буквы. **VGA (Video Graphics Array)** — это старый стандарт того, как видеокарта выводит изображение.

- В этом режиме экран — это просто сетка **80 столбиков на 25 строк**.
    
- В каждую клетку этой сетки можно положить один символ (букву, цифру) и задать ей цвет.
    
- **Видеокарта**(GPU) — это **отдельный специализированный компьютер внутри вашего компьютера**, который отвечает за создание и вывод изображения на экран. Она

    - 1. **Обрабатывает графику** (игры, 3D-моделирование, видео)
     - 2. **Ускоряет вычисления** (машинное обучение, научные расчеты)
     - 3. **Выводит изображение** на монитор
     
- **VGA** — это старый, очень простой стандарт видеокарт для PC.

- **Видеопамять** — это **высокоскоростная память, расположенная на видеокарте**, которая используется исключительно для графических операций.
    
```
ВИДЕОПАМЯТЬ (например, 8 ГБ GDDR6)
├── ТЕКСТУРЫ (60%)          ← Изображения для поверхностей (трава, кожа, металл)
├── ГЕОМЕТРИЯ (20%)         ← 3D-модели объектов
├── КАДРОВЫЙ БУФЕР (10%)    ← Готовый кадр для вывода на экран
├── ШЕЙДЕРЫ (5%)            ← Программы для GPU
└── ДРУГОЕ (5%)             ← Информация об освещении, тени и т.д.
```

### Зачем писать «прямо в видеокарту», а не в обычную память?

Это отличный вопрос! Смотри:

- **Обычная память (RAM)** — это просто склад. Если ты положишь туда букву «А», она там будет просто лежать. Планка памяти не умеет светиться или передавать сигнал на монитор.
    
- **Видеокарта** — это устройство, которое «смотрит» на свои адреса и сразу выводит их на экран.
    

**Почему мы используем адрес `0xb8000`?** Инженеры договорились: «Пусть адрес `0xb8000` будет входом в видеокарту». Если ты запишешь букву в оперативную память (например, по адресу `0x100`), она останется там. Если ты запишешь ту же букву по адресу `0xb8000`, она пролетит мимо оперативной памяти и упадет в память видеокарты. И — магия! — ты мгновенно увидишь её на экране.

---

### 2. Принцип фон Неймана и «Магия адресов»

Помнишь, в архитектуре фон Неймана у процессора есть **Адресная шина**? Процессор выставляет на неё номер (адрес), чтобы что-то прочитать или записать.

Обычно мы думаем, что адреса ведут только в оперативную память (RAM). Но инженеры придумали хитрость:

> «А давайте сделаем так: если процессор обращается к адресам от `0` до `1000`, это будет настоящая память. А если он обратится к адресу **`0xb8000`**, сигнал пойдет не в планку памяти, а по проводам прямиком в **видеокарту**».

Это и есть **Memory-mapped I/O** (ввод-вывод, отображенный на память). Процессор «думает», что пишет в память, а на самом деле он крутит шестеренки внутри видеокарты.

### 3.Почему «нет ОС и syscall»?

Представь, что ты пишешь самую первую программу, которая запускается сразу при включении компьютера (например, саму операционную систему или BIOS).

- У тебя ещё **нет** функций `printf` или `cout`.
- У тебя ещё **нет** ядра, которое управляет драйверами.
- Есть только ты (Процессор) и Видеокарта.
    

В этом случае ты общаешься с железом «напрямую». Код со слайда:

```
volatile uint16_t *const vga_memory = (uint16_t *)0xb8000;
```

Когда компьютер только включается, **никакой операционной системы еще нет**. Она еще не загрузилась. В памяти пусто. Процессор умеет только одно: брать команду из памяти и выполнять её. Если ты хочешь в этот момент хоть что-то вывести на экран (например, надпись «Loading Linux...»), тебе некому «заказать пиццу». Ты не можешь вызвать `printf`, потому что `printf` — это часть ОС, которой еще нет.

В этот момент ты — как первобытный человек. Ты берешь «камень» (адрес `0xb8000`) и бьешь им прямо по «дереву» (видеокарте).

---

### Разбор кода (VGA Text Mode)

На слайде приведен классический пример вывода символа на экран в текстовом режиме VGA. (**VGA** — это **исторический стандарт для вывода видео**, который стал основополагающим в мире персональных компьютеров.)

```c
#define VGA_VIDEO_WIDTH 80  // Ширина текстового экрана VGA
volatile uint16_t *const vga_memory = (uint16_t *)0xb8000;
```

Это означает:

> «Считай, что по адресу 0xB8000 лежит массив, и каждая запись в него — это команда видеоустройству».

- **`0xb8000`**: Это стандартный физический адрес видеопамяти для текстового режима в архитектуре x86.
    
- **`volatile`**: Самое важное слово. Оно говорит компилятору: «Не пытайся оптимизировать работу с этой памятью!». Если мы запишем туда букву 'A', а потом букву 'B', компилятор может подумать, что 'A' записывать не обязательно. Но для видеокарты важна каждая запись, поэтому `volatile` заставляет процессор выполнять каждое обращение к памяти честно.
    
- **`uint16_t`**: Каждый «пиксель» (символ) на экране занимает 2 байта (16 бит).

```c
static void put_char(uint8_t x, uint8_t y, char c, uint8_t color) {
    vga_memory[y * VGA_VIDEO_WIDTH + x] = (uint16_t)((color << 8) | (c & 0x7F));
}
```

Функция выводит один символ на экран в позицию `(x, y)`.

Представь экран как таблицу в Excel: 80 ячеек в ширину и 25 в высоту. Но **видеопамять** (`vga_memory`) — это не таблица, это **длинная лента** (одномерный массив).

#### Аргументы функции:

- `x, y` — координаты на экране (где именно рисуем).
- `char c` — сама буква (например, 'A').
- `uint8_t color` — код цвета (например, 0x0F — это белый текст на черном фоне).

#### Математика внутри: `y * VGA_VIDEO_WIDTH + x`

Это формула превращения координат таблицы в индекс на ленте:

- Если нам нужна 2-я строка (`y=1`), мы должны сначала «пропустить» все 80 ячеек 1-й строки.
    
- Поэтому мы умножаем `y` на ширину экрана (`80`) и прибавляем `x`.
    
- **Итог:** Мы нашли точное место в памяти видеокарты, которое отвечает за конкретную точку на мониторе.
    
#### Магия упаковки: `(color << 8) | (c & 0x7F)`

Для видеокарты VGA каждая ячейка — это 16 бит (2 байта). Она требует, чтобы они были упакованы строго в определенном порядке:

1. **Младший байт** (справа): ASCII-код символа.
2. **Старший байт** (слева): Атрибуты цвета.

**Как работает код:**

- `(color << 8)` — мы берем байт цвета и сдвигаем его влево на 8 бит, чтобы он занял «верхний этаж» 16-битного числа.
- `(c & 0x7F)` — мы берем код буквы (маска `0x7F` гарантирует, что мы используем стандартный 7-битный ASCII).
- `|` (побитовое ИЛИ) — склеивает их вместе в одно 16-битное число.

**Результат:** Одна запись в массив — и видеокарта мгновенно получает и букву, и её цвет.


Важно понять:  
➡️ **никакого драйвера, никакого syscall, никакой ОС здесь нет**.  
➡️ Это прямой доступ к устройству через память.

В современном пользовательском приложении такой код:

- либо не скомпилируется,
- либо упадёт с ошибкой доступа.
    
Почему? Потому что:

- пользовательский режим не имеет права писать в такие адреса,
- доступ к memory-mapped I/O разрешён только ядру или драйверам.

### Итог
Этот слайд в твоей лекции нужен для того, чтобы показать: **в самом низу всё работает очень просто**. Операционная система — это просто надстройка, которая делает эти «удары камнем по дереву» за тебя, чтобы ты могла просто писать `printf`.

Современная видеокарта:

- слишком сложна, чтобы к ней писали напрямую,
- имеет тысячи регистров,
- поддерживает ускорение, 3D, шейдеры.

Поэтому:

- пользовательские программы **не имеют доступа** к видеокарте,
- ядро управляет доступом,
- драйвер видеокарты — это часть ОС, которая знает, _как с ней говорить_.

Схема выглядит так:

`программа → syscall → ядро → драйвер → видеокарта → экран`

А в VGA-примере:

`код → запись в адрес → видеокарта → экран`

![[Pasted image 20251228184410.png]]

Этот слайд показывает **второй фундаментальный способ общения процессора с устройствами** — **Port-mapped I/O (PMIO)**, который является альтернативой Memory-mapped I/O (MMIO), о котором мы говорили ранее.

Если в memory-mapped I/O устройство «притворяется памятью», то здесь ввод-вывод **вынесен в отдельный мир**, не связанный с обычной памятью.

У процессора появляется **два разных пространства**:

- адресное пространство памяти;
- адресное пространство портов ввода-вывода.

Это принципиально другое архитектурное решение.

Ключевые отличия от MMIO:

|**Memory-mapped I/O (MMIO)**|**Port-mapped I/O (PMIO)**|
|---|---|
|Устройства выглядят как **память**|Устройства имеют **порты**|
|Использует обычные команды работы с памятью (`mov`)|Использует **специальные команды** (`in`, `out`)|
|Адреса в общем адресном пространстве|**Отдельное адресное пространство портов**|
|Пример: `mov [0xB8000], ax`|Пример: `in al, 0x60`|

---
### 1. Что такое Port-mapped I/O (PMIO)?

В архитектуре x86 (Intel/AMD) инженеры создали **отдельное адресное пространство**, полностью независимое от оперативной памяти.

- **Порт** — это числовой адрес (от 0 до 65535), закрепленный за конкретным контроллером.

То есть это **числовой идентификатор**, который процессор использует, чтобы обратиться к конкретному устройству.

Можно думать о порте как о «почтовом ящике» устройства:

- у каждого устройства есть свои порты,
- процессор пишет или читает данные, указывая номер порта,
- устройство, «подписанное» на этот порт, отвечает.

Например:

- порт `0x60` — классический порт клавиатуры на PC,
- при нажатии клавиши клавиатура кладёт туда сканкод,
- процессор читает его через специальную инструкцию.
### 2. Специальные инструкции: `in` и `out`

В обычном коде на C ты их не увидишь. Для портов существуют **отдельные инструкции процессора** - это команды **ассемблера**:

- **`in`**: Процессор «втягивает» данные из порта устройства в свой регистр.
- **`out`**: Процессор «выталкивает» данные из регистра в порт устройства.

Это жёстко зашито в архитектуру x86.

---

### 3. Разбор ассемблерного кода (Клавиатура)

Это код на ассемблере для **чтения сканкодов с клавиатуры** в реальном режиме x86:

---
Сканкод — это **уникальный номер, который клавиатура присваивает каждой физической клавише**, независимо от раскладки

**Важно:** Сканкод ≠ ASCII! Сканкод говорит "нажата третья клавиша во втором ряду", а уже драйвер клавиатуры переводит это в символ 'A', 'Ф' или 'А' в зависимости от раскладки и модификаторов (Shift, Ctrl).

---

```c
loop:              /* Метка начала цикла */
  in $0x60, %al    /* Читаем скан-код нажатой клавиши из порта 0x60 в регистр AL */
  cmp %al, %cl     /* Сравниваем: не та ли это клавиша, что мы читали в прошлый                          раз? */
  jz loop          /* Если та же — прыгаем в начало цикла (ждем нового нажатия) */
  mov %al, %cl     /* Если НОВЫЙ сканкод → сохраняем его в CL */
  PRINT_HEX <%al>  /* Выводим сканкод в HEX-формате */
  PRINT_NEWLINE    /* Переводим строку */
  jmp loop         /* Снова в начало */
```

**Что здесь происходит:** Процессор «завис» в бесконечном цикле, постоянно спрашивая контроллер: «Ну что, нажали кнопку? А сейчас? А теперь?».

Клавиатура — это устройство, которое:

- при нажатии клавиши кладёт код (сканкод) в свой порт,
- не «пушит» его в процессор,
- просто ждёт, пока процессор сам придёт и заберёт.

Этот подход называется **polling** — активный опрос.

Процессор:

- тратит время на постоянные проверки,
- простаивает, если данных нет,
- вынужден знать, _когда_ и _как часто_ опрашивать устройство.

Если делать это для клавиатуры, диска, сети и таймера — процессор будет заниматься только ожиданием.

---

Именно здесь появляется идея прерываний.
Было бы гораздо удобнее, если бы:

> «Устройство само сказало процессору:  
> „У меня есть данные, обрати внимание!“»

Это и есть **прерывание**.

---

###  Проблема подхода: Опрос (Polling)

**Опрашивать устройства вручную — это ужасно**.

1. **Процессор перегружен:** Он тратит 100% своей мощности на пустые вопросы к клавиатуре, вместо того чтобы считать физику в игре или рендерить видео.
    
2. **Риск пропустить данные:** Если процессор отвлечется на тяжелую задачу, а ты нажмешь кнопку очень быстро, контроллер может перезаписать старый код новым, и нажатие «потеряется».

---

###  Почему в x86 есть два механизма (MMIO и PMIO)?

Это «историческое наследство». Архитектура x86 выросла не как «чистый проект с нуля», а как **наследник ранних 8-битных и 16-битных процессоров Intel (8080, 8086)**. Когда создавались первые процессоры Intel (8080, 8086), оперативная память была безумно дорогой, а её объем — крошечным (килобайты).

- адресное пространство памяти было маленьким и дорогим,
- каждый байт RAM был на вес золота,
- устройства было удобно вынести в отдельное пространство, чтобы **не отнимать память**.

Так появился **port-mapped I/O** — отдельное пространство портов с инструкциями `in` и `out`. Это позволяло:

- не тратить адреса памяти,
- упростить декодирование инструкций,
- сделать дешёвые контроллеры устройств.

Когда проектировали 8086, **memory-mapped I/O ещё не был доминирующей идеей**, и портовая модель казалась логичной.

### Почему потом появился memory-mapped I/O

#### 1. Проблема «узкого горлышка» (Объем данных)

В системе **PMIO** у процессора x86 всего 65 536 портов. Каждый порт — это крошечное окошко размером в 1–4 байта.

- **Для клавиатуры** этого достаточно: нажал кнопку — получил 1 байт.
    
- **Для видеокарты** это катастрофа. Представь, что тебе нужно передать текстуру в 100 Мегабайт через форточку размером в 1 байт. Тебе придется 100 миллионов раз выполнить команду `out`. Это невероятно медленно.
    

**В MMIO** видеокарта может занять огромный диапазон адресов (например, 256 МБ или даже несколько ГБ). Процессор видит это как огромный массив. Можно использовать сверхбыстрые инструкции копирования памяти (например, `MOV`), которые передают данные огромными блоками.

#### 2. Упрощение архитектуры процессора

Для **PMIO** процессору нужны были **отдельные команды** (`in` и `out`) и отдельная логика внутри «мозга», чтобы понимать: «Так, это я сейчас не в память иду, а в порт». Для **MMIO** новые команды не нужны. Процессор просто умеет «читать и писать в память». Инженерам проще сделать одну универсальную и очень быструю систему работы с памятью, чем поддерживать две разные.

> Именно поэтому в архитектурах **ARM** (твои смартфоны, процессоры Apple M1/M2, Raspberry Pi) портов вообще не существует. Там всё — от таймера до видеоядра — это MMIO.

### 3. Гибкость и высокоуровневые языки (C/C++)

Работать с портами из языков высокого уровня неудобно — приходится постоянно вставлять куски на Ассемблере. **В MMIO** работа с железкой превращается в работу с **указателем**:

```c
// Просто создаем указатель на адрес устройства
uint32_t *network_card = (uint32_t *)0xC0000000; 
// Пишем в него данные как в обычную переменную
*network_card = 0x12345678; 
```

Компилятор C даже не знает, что он управляет сетевой картой. Он просто пишет в память, и это работает очень эффективно.

### 4. Защита и многозадачность

Когда появились современные ОС (Windows, Linux), возникла проблема: как запретить обычной программе (например, вирусу) напрямую управлять диском или видеокартой?

- **В PMIO** защищать порты сложно.
    
- **В MMIO** всё работает через механизм **страничной памяти** (то, что мы обсуждали: MMU и таблицы страниц). Ядро ОС может просто пометить участок памяти устройства как «запрещенный» для обычных программ. Если программа попытается туда записать — процессор её мгновенно остановит.

### 5. Плохо сочетается с виртуальной памятью

Port I/O:

- живёт **вне адресного пространства памяти**,
- не может быть защищён страницами,
- не участвует в MMU.
Ядро не может:

- легко запретить доступ к части портов,
- отобразить порты в адресное пространство процесса,
- использовать стандартные механизмы защиты.

### 6.Нельзя использовать кэш процессора

Операции `in/out`:

- **всегда идут напрямую к устройству**,
- не кэшируются,
- не буферизуются.

Каждый `in`:

- тормозит конвейер,
- ждёт ответа устройства,
- блокирует выполнение.
Для быстрых устройств это **очень дорого**.

---
### Почему нельзя было просто убрать port-mapped I/O

Потому что **обратная совместимость — священна для x86**.

Огромное количество: BIOS-кода, старых ОС, драйверов, embedded-систем зависело от портов. Если бы Intel убрала `in/out`, **сломался бы весь PC-мир**. Поэтому port-mapped I/O остался, но стал вторичным.

В современных системах:
- доступ к портам есть только у ядра,
- пользовательский код не может использовать `in/out`.

**Кто остался на портах:**

1. **Клавиатура и мышь (PS/2):** Те самые порты `0x60-0x64`. Даже если у тебя USB-клавиатура, современный компьютер часто имитирует эти порты, чтобы старые программы и ОС могли работать.
    
2. **Системный таймер (PIT):** Порты `0x40-0x43`. Он отсчитывает время для ядра ОС.
    
3. **Контроллер прерываний (PIC):** Порты `0x20-0x21` и `0xA0-0xA1`. Это «секретарь» процессора, который принимает звонки от всех железок.
    
4. **RTC (Часы реального времени):** Порты `0x70-0x71`. Те самые часы, которые не сбиваются, когда компьютер выключен.
    
5. **Старые дисковые контроллеры (IDE/ATA):** Порты вроде `0x1F0-0x1F7`.
    

**Кто ушел в MMIO:**

- **Видеокарты:** Им нужно передавать гигабайты, в порты они просто не влезут.
    
- **Сетевые карты и Wi-Fi:** Слишком большой поток данных.
    
- **Звуковые карты:** Современный HD Audio работает только через память.

---

Одно и то же устройство **может** использовать и то, и другое. Например, видеокарта VGA использует **MMIO** для передачи самой картинки (адрес `0xb8000`), но использует **порты** (например, `0x3D4`), чтобы ты могла просто подвинуть курсор.

![[Pasted image 20251228190151.png]]

**Прерывание** — это механизм, при котором устройство или событие временно останавливает текущий код процессора и передаёт управление специальному обработчику.
Процессор не спрашивает — его **вызывают**.

**Виды прерываний (как это бывает):**

1. **Exceptions (Исключения):** «Внутренние» прерывания. Процессор сам себя прерывает, потому что произошла ошибка (например, ты делишь на ноль или лезешь в чужую память).
    
2. **Hardware Interrupts (Аппаратные):** «Внешние» сигналы. Клавиатура посылает электрический импульс: «Эй, я тут нажата!».
    
3. **Software Interrupts (Программные):** Это те самые **syscall**, о которых мы говорили. Когда программа специально имитирует прерывание, чтобы позвать ядро.

![[Pasted image 20251228190241.png]]

Слайд противопоставляет:

1. **Обычное выполнение программы** (сверху) — поток инструкций выполняется последовательно
    
2. **Обработку прерывания** (снизу) — внезапный "перехват" выполнения для реакции на событие
    

Визуально это показано стрелкой **← rip (x86_64 instruction pointer)**, которая символизирует, что указатель инструкций "перепрыгивает" из пользовательской программы в ядро ОС.

Давай разберем, что происходит в этой «драме» из двух актов.
### Акция 1: Обычная жизнь (Ваш код)

`dot_product` (скалярное произведение векторов) на языке ассемблера.

```assembly
dot_product(int x1, int y1, int x2, int y2):  ; edi, esi, edx, ecx
    mov eax, edi     ; result = x1
    imul eax, edx    ; result *= x2
    mov edx, eax     ; lhs = result
    mov eax, esi     ; result = y1
    imul eax, ecx    ; result *= y2   ← rip (x86_64 instruction pointer)
    add eax, edx     ; result += lhs
    ret              ; result is in eax
```

- **Важно:** Программа «думает», что она — единственная в мире и ничто её не остановит.
- Указатель **`rip`** (регистр, который хранит адрес следующей команды) сейчас указывает на строку `imul eax, ecx`.

1. Это функция вычисления скалярного произведения векторов: `x1*x2 + y1*y2`
2. Параметры передаются в регистрах (System V ABI для x86_64)
3. Выполнение идет последовательно, инструкция за инструкцией
4. В момент выполнения `imul eax, ecx` (выделенная строка) происходит...
### Акция 2: Вторжение (Прерывание)

В тот самый микросекундный момент, когда процессор выполняет умножение, ты нажимаешь клавишу на клавиатуре.

**Внезапно:** Нажата клавиша на клавиатуре → возникает **прерывание** → процессор:

1. **Сохраняет состояние** (регистры, включая rip)
2. **Переключается в режим ядра** (повышает уровень привилегий)
3. **Переходит на обработчик прерывания** в ядре (`handle_keyboard`)

```
; …и где-то очень далеко, в ядре
handle_keyboard:
    in $0x60, %al    ; что-то делаем с этим сканкодом
    iret             ; возвращаемся обратно, откуда нас унесли
```
    
### Акция 3: Жизнь в ядре (Обработчик)

Процессор смотрит в специальную таблицу  и видит: «Ага, для клавиатуры нужно прыгнуть по адресу `handle_keyboard`».

- Теперь процессор находится «очень далеко, в ядре».
    
- Он выполняет инструкцию `in $0x60, %al` (которую мы обсуждали в PMIO), чтобы забрать код нажатой клавиши.
    
- **Ключевой момент:** Программа `dot_product` в это время «заморожена». Она даже не знает, что её поставили на паузу.
    
### Акция 4: Возвращение

Последняя команда в ядре — **`iret`** (Interrupt Return).

- Это не просто «выход». Эта команда говорит процессору: «Восстанови всё, как было! Достань из стека старое значение `rip` и вернись к той самой инструкции, на которой мы прервались».
    
- Процессор возвращается к строчке `add eax, edx` и заканчивает вычисление вектора.
    

---

### Почему это гениально?

1. **Прозрачность:** Ваша программа `dot_product` не содержит ни одной строчки кода для работы с клавиатурой. Она «просто считает», а ядро «просто обрабатывает прерывания» в промежутках между тактами.
    
2. **Скорость:** Реакция на нажатие клавиши происходит мгновенно (микросекунды), даже если программа занята сложными расчетами.
    
3. **Сохранность:** Благодаря тому, что процессор сохраняет состояние (регистры, адрес возврата) перед прыжком в ядро, вычисления не портятся.
    

> **Академический нюанс:** Обрати внимание на регистр **`rip`**. Это «глаза» процессора. Прерывание — это когда кто-то насильно поворачивает голову процессора в другую сторону, но потом возвращает её в исходное положение с точностью до миллиметра.

![[Pasted image 20251228203503.png]]

### 1️ Материнская плата

Материнская плата — это **основная плата компьютера**, на которой размещены:

- Процессор (CPU)
- Оперативная память (RAM)
- Контроллеры устройств
- Разъёмы для внешних устройств (USB, клавиатура, диски и т.д.)
    
Она обеспечивает **электрические соединения** между всеми компонентами. Проще говоря: процессор, память и устройства “разговаривают” через **провода и шины на материнской плате**.

---

### 2️ Контроллер прерываний (PIC или APIC)

**Контроллер прерываний** (PIC) — это специальная микросхема на материнской плате, которая управляет прерываниями:

- Слушает сигналы от всех устройств (клавиатура, мышь, таймер, сеть и т.д.)
- Решает, какое устройство требует внимания процессора
- Передаёт сигнал процессору, чтобы он временно **прервал текущее выполнение кода** и вызвал обработчик (ISR — Interrupt Service Routine)

Раньше был **PIC (Programmable Interrupt Controller)**, сейчас в современных системах чаще используется **APIC (Advanced Programmable Interrupt Controller)**.

---

### 3️ Почему прерывания сигнализируют через провода

- Каждое устройство (клавиатура, мышь, диск) подключено к **порту ввода-вывода**, который физически связан с контроллером прерываний через **провод или дорожку на плате**.
    
- Когда устройство хочет привлечь внимание CPU:
    
    1. Оно **ставит напряжение на определённый провод** (IRQ line)
    2. Контроллер прерываний видит этот сигнал
    3. Отправляет сигнал процессору → CPU приостанавливает текущую программу → выполняет обработчик прерывания
        

![[Pasted image 20251228203553.png]]

Если раньше мы говорили, что устройство просто «подает сигнал» процессору, то на этом рисунке показано, **как именно** это происходит в реальности.

### Зачем нужен этот «желтый блок» (PIC)?

Представь, что процессор — это очень важный директор. У него есть только одна «телефонная линия» для экстренных звонков (вход **Interrupt**). А устройств в компьютере много: USB, Сеть, Диски, Видеокарта.

Если бы каждое устройство тянуло свой провод напрямую к процессору, у него бы просто не хватило «ножек» (контактов).

**Programmable Interrupt Controller (PIC)** работает как секретарь-коммутатор:

1. Он собирает все сигналы (**IRQ lines**) от разных устройств.
    
2. Он расставляет их по **приоритету** (например, сигнал от таймера важнее, чем от мышки).
    
3. Он отправляет процессору один-единственный сигнал: «Шеф, есть прерывание!».
    
4. Когда процессор спрашивает «От кого?», контроллер передает ему **номер (вектор)** устройства.
    

---

### Кто именно сигнализирует (разбор списка слева)?

На схеме показаны типичные источники аппаратных прерываний:

- **USB controller:** Сигнализирует, когда ты пошевелила мышкой или вставила флешку.
    
- **Network adapter (Сетевая карта):** Сигнализирует, когда из интернета прилетел пакет данных. Если бы не прерывание, процессор бы не узнал, что пора забирать данные из памяти.
    
- **PCI-e controller:** Сигнализирует о событиях в шине PCI Express (например, видеокарта закончила сложные расчеты).
    
- **SATA controller:** Сообщает, что жесткий диск (или SSD) закончил читать файл и данные готовы к обработке.

>В современных компьютерах используется более продвинутая версия — **APIC** (Advanced PIC). Она умеет распределять прерывания между разными ядрами процессора (например, клавиатуру на 1-е ядро, а сеть на 4-е), чтобы компьютер работал еще быстрее.

### Аппаратные прерывания доставляются двумя способами

### Линии прерываний (IRQ — Interrupt Request lines)

Это реальные электрические дорожки на материнской плате, соединяющие контроллеры устройств (USB, диск, сеть) с контроллером прерываний.

- Когда устройству нужно «позвать» процессор, оно меняет напряжение на своей линии (подает электрический сигнал).
    
- Контроллер прерываний (секретарь) видит, на какой именно линии «загорелась лампочка».

### Зачем каждой железке своя линия?

Чтобы процессор понимал, **кто именно** его отвлекает. Если бы линия была одна на всех, процессору пришлось бы после каждого сигнала опрашивать все устройства: «Это ты нажал? Или ты?». Это было бы очень медленно (тот самый Polling, которого мы избегаем).

Благодаря отдельным линиям:

- **IRQ 1** традиционно зарезервирована за клавиатурой.
    
- **IRQ 0** — за системным таймером.
    
- Современные устройства (PCI-e, USB) используют более сложные виртуальные линии, но принцип тот же.

### MSI (Прерывание по сигналу сообщения)

**MSI** — это технология, которая позволяет устройствам сигнализировать о прерывании, просто **записывая данные в определенный адрес памяти**. (Напрямую записывают информацию о прерываниях в память контролера)

Вот как это объяснить академически:

### 1. В чем разница (Провода vs Сообщения)

- **Классические IRQ (Legacy Interrupts):** Это выделенный электрический контакт (провод). Когда устройству (например, SATA-контроллеру) нужно внимание процессора, оно меняет напряжение на этом проводе.
    
- **MSI (Message Signaled Interrupts):** У устройства нет выделенного провода к контроллеру прерываний. Вместо этого устройство делает **запись по специальному адресу в памяти (MMIO)**. Процессор (или контроллер прерываний) следит за этим адресом, и как только туда прилетает «сообщение» с номером прерывания, он понимает: «Ага, это прерывание от видеокарты!».

### 2. Почему MSI — это круто и почему они заменили линии?

1. **Лимит линий:** На старых шинах (PCI) было всего 4 физические линии прерываний. Устройствам приходилось «делить» одну линию на двоих (Interrupt Sharing), что создавало путаницу и тормоза. У **MSI** таких ограничений нет — каждое устройство может иметь десятки своих «сообщений».
    
2. **Скорость и отсутствие помех:** Электрический сигнал на длинном проводе может давать наводки. Запись в память через быструю шину PCI Express происходит мгновенно и без ошибок.
    
3. **Многоядерность (Affinity):** С помощью MSI ядро ОС может сказать сетевой карте: «Присылай прерывания от 1-го порта на 0-е ядро процессора, а от 2-го порта — на 3-е ядро». С физическим проводом так гибко не получится.
    
4. **Упрощение железа:** Меньше дорожек на материнской плате — проще и дешевле производство
---
### ЭТАП 1: Генерация запроса (Уровень железа)

1. **Событие:** Внешнее устройство (например, клавиатура) генерирует данные.
    
2. **Сигнализирование:** Контроллер устройства выставляет электрический сигнал на свою персональную линию **IRQ** (Interrupt Request).
    
3. **Служба «секретаря» (PIC/APIC):** Сигнал поступает в **Программируемый контроллер прерываний**. Контроллер выполняет **арбитраж**: проверяет приоритет линии и не замаскирована (запрещена) ли она операционной системой.
    
4. **Уведомление процессора:** Если прерывание допустимо, PIC активирует вход **Interrupt** на самом процессоре.
    
### ЭТАП 2: Реакция процессора (Переход в режим ядра)

5. **Завершение инструкции:** Процессор не прерывается на полуслове — он обязан довести текущую ассемблерную команду до конца (например, завершить умножение `imul`).
    
6. **Подтверждение и получение вектора:** Процессор подтверждает готовность, и PIC передает ему по шине данных **номер вектора** (например, `0x21` для клавиатуры).
    
7. **Сохранение контекста (Консервация):** Чтобы вернуться назад, CPU автоматически сохраняет в стек критически важные данные:
    
    - Текущий указатель команд (**RIP/EIP**) — адрес следующей строки кода.
        
    - Регистры состояния (флаги) и сегментные регистры.
        
8. **Поиск в таблице IDT:** Процессор использует полученный номер вектора как индекс в **IDT (Interrupt Descriptor Table)**. Это «телефонная книга» в памяти, где для каждого номера прописан адрес начала кода его обработчика (ячейка в ядре ОС).
    
### ЭТАП 3: Работа обработчика (Внутри ядра ОС)

9. **Прыжок в обработчик:** Процессор меняет значение регистра `RIP` на адрес, найденный в IDT. Теперь выполняется код драйвера (например, `handle_keyboard`).
    
10. **Чтение данных (I/O):** Драйвер общается с устройством одним из двух способов:
    
    - **Port-mapped I/O:** Использует команды `in/out` для чтения скан-кода из порта (например, `in $0x60, %al`).
        
    - **Memory-mapped I/O:** Читает данные, обращаясь к «магическому» адресу памяти (например, `0xb8000` для видео), который на самом деле ведет к устройству.
        
### ЭТАП 4: Возврат к прерванной задаче

11. **Завершение работы ядра:** После обработки (например, записи буквы в буфер) обработчик выполняет специальную команду **`iret`** (Interrupt Return).
    
12. **Восстановление контекста:** Процессор «выталкивает» из стека сохраненные ранее значения `RIP` и флагов.
    
13. **Продолжение вычислений:** Указатель команд снова указывает на ту строку, где программа была прервана (например, `add eax, edx`). Программа продолжает работу, даже не «заметив» паузы.



![[Pasted image 20251228212200.png]]

### 1. IDT (Interrupt Descriptor Table) — Таблица дескрипторов прерываний

Это системная структура данных, которая служит «картой переходов» для процессора.

- **Структура**: Представляет собой массив из **256 записей** (индексы от 0 до 255).
    
- **Содержимое**: Каждая запись содержит адрес (указатель) на функцию-обработчик, которая называется **ISR** (Interrupt Service Routine).
    - Процессор **сам не знает**, где лежит IDT
    - Ядро загружает адрес IDT в специальный регистр **IDTR**

- **Регистр IDTR**: Чтобы процессор знал, где в оперативной памяти ядро разместило эту таблицу, используется специальный регистр **IDTR** (Interrupt Descriptor Table Register). Команда загрузки адреса в этот регистр — `lidt`.

>**Программные прерывания**: Этот же механизм используется для системных вызовов (**syscall**). Программа специально вызывает прерывание (например, `int 0x80` в Linux), чтобы заставить процессор прыгнуть в ядро по этой же таблице.
### 2. Алгоритм «Прыжка» (Context Switch)

Когда процессор получает номер прерывания от контроллера (например, №33), он выполняет следующие действия:

1. **Сохранение состояния (Push to Stack)**: Процессор должен запомнить, где он находился в пользовательской программе. Он автоматически сохраняет в стек три критических значения:
    
    - **CS (Code Segment)**: Сегмент кода.
        
    - **RIP (Instruction Pointer)**: Адрес следующей инструкции, которую мы должны были выполнить.
        
    - **EFLAGS**: Регистр состояния (результаты сравнений, флаги разрешений прерываний).
        
2. **Загрузка обработчика**: Процессор берет адрес из 33-й ячейки IDT и записывает его в свои регистры **CS** и **RIP**.
    
3. **Переключение режима**: В этот момент процессор переходит из режима пользователя (Ring 3) в режим ядра (Ring 0), что дает ему право выполнять привилегированные команды (например, `in/out`).

### 3. Завершение: Инструкция `iret`

Инструкция `iret` (Interrupt Return) — это антипод прерывания. Она выполняет «откат» системы в исходное состояние.

- **Механизм**: Она извлекает (**pop**) из стека те самые три значения (CS, RIP, EFLAGS), которые процессор сохранил в самом начале.
    
- **Результат**: Процессор мгновенно «телепортируется» обратно в ту точку программы, где его прервали, восстанавливая все флаги состояния. Программа продолжает работу с того же места.

![[Pasted image 20251228212306.png]]

### 1. Когда именно CPU узнает о прерывании? (Цикл инструкции)

Процессор не прерывает выполнение команды на середине. Его работа — это бесконечный цикл: **«Извлечение -> Декодирование -> Выполнение -> Проверка прерываний»**.

- **Флаг IF (Interrupt Flag):** В системном регистре `EFLAGS` есть специальный бит **IF**.
    
    - Если `IF = 1`, прерывания **разрешены**.
        
    - Если `IF = 0`, прерывания **замаскированы** (игнорируются). Это нужно ядру ОС, когда оно выполняет критически важный код, который нельзя прерывать.
        
- **Момент проверки:** Процессор проверяет состояние этого бита и наличие сигнала от PIC **строго после завершения каждой инструкции**. Если сигнал есть и `IF=1`, CPU запускает процедуру сохранения контекста и перехода к IDT.

### 2. Разделение обязанностей: CPU vs PIC

Процессор спроектирован для максимально быстрых вычислений, поэтому он «делегирует» сложную логику управления внешними сигналами отдельному устройству.

- **Проблема CPU:** Он «один», а устройств много. Он не хочет тратить свои транзисторы на хранение очереди из 15 прерываний или сравнение их приоритетов.
    
- **Решение (PIC):**
    
    - **Очередь и приоритеты:** Именно **PIC** (или APIC) решает, что прерывание от сетевой карты сейчас важнее, чем от мышки. Он «держит в уме» все поступившие сигналы.
        
    - **Коммуникация:** Процессор общается с PIC точно так же, как с любым другим устройством — через **порты (PMIO)** или **адреса памяти (MMIO)**. С помощью команд `in/out` или записи в память ядро ОС настраивает PIC: меняет приоритеты, маскирует линии или подтверждает получение прерывания (сигнал EOI — End of Interrupt).

![[Pasted image 20251228212325.png]]

### 1. Как программа вызывает прерывание?

Хотя программы не могут напрямую дергать за «провода» процессора, они могут использовать специальные инструкции:

- **`int 0x80` (на старых x86):** Программа буквально говорит: «Выполни прерывание номер 128». Процессор смотрит в ту самую таблицу **IDT**, находит там адрес входа в ядро и переключает режим.
    
- **`syscall` (на современных x86_64):** Это более быстрый и современный аналог инструкции `int`. Он делает то же самое — мгновенно переключает процессор из режима пользователя в режим ядра.

### 2. Зачем это нужно? (Абстракция и Безопасность)

Ты правильно заметила раньше: «никакого драйвера и ОС нет», когда мы писали в `0xb8000`. Но в реальной жизни давать каждой программе прямой доступ к железу опасно. **Системные вызовы (syscalls)** создают границу:

- **Управление процессами:** Программа не может сама «убить» другую программу. Она просит об этом ядро через прерывание.
    
- **Управление файлами:** Программа не знает, на каких секторах диска лежит файл. Она говорит ядру: «Прочитай файл `data.txt`», и ядро само общается с контроллером диска.
    
- **Управление устройствами:** Вместо того чтобы знать адрес `0xb8000`, программа просто просит: «Выведи этот текст в терминал».

![[Pasted image 20251228214102.png]]

### 1. Монолитное ядро (Monolithic Kernel)

В этой архитектуре **все** основные сервисы ОС работают внутри ядра в одном адресном пространстве.

- - **Что внутри:** Файловая система (VFS), сетевой стек, драйверы устройств, планировщик процессов и управление виртуальной памятью.
    
- **Как это работает:** Все эти компоненты являются частями одной огромной программы. Они общаются друг с другом напрямую, вызывая функции.
    
- **Плюсы:** * **Максимальная скорость:** Процессору не нужно переключать режимы и контексты, чтобы передать данные от драйвера диска к файловой системе.
    
- **Минусы:**
    
    - **Хрупкость:** Если в коде драйвера принтера затаилась ошибка (баг), она может затереть память планировщика задач. Итог — «синий экран» или полная заморозка системы.
        
- **Примеры:** Linux, FreeBSD.
    
### 2. Микроядро (Microkernel)

Здесь подход другой: в ядре остается только **абсолютный минимум**, необходимый для работы системы.

 -  **Что внутри:** Только самый минимум — базовое планирование, управление памятью и механизмы общения между программами (**IPC — Inter-Process Communication**).
    
- **Что снаружи (в User Space):** Драйверы, файловые системы и сетевые службы вынесены в отдельные процессы. Они работают как обычные приложения с ограниченными правами.
    
- **Как это работает:** Если приложению нужно прочитать файл, оно посылает текстовое сообщение «серверу файловой системы». Сообщение проходит через микроядро.
    
- **Плюсы:**
    
    - **Невероятная надежность:** Если драйвер диска «упал», система просто перезапустит его как обычный процесс. Компьютер даже не перезагрузится.
        
- **Минусы:**
    
    - **Медлительность:** Постоянная пересылка сообщений (IPC) между процессами требует много времени и ресурсов процессора.
        
- **Примеры:** QNX (стоит в бортовых компьютерах машин и самолетов), L4, Minix.
    
---
Давай разберем блоки, чтобы ты могла ответить по пунктам:

1. **Hardware (синий низ):** Это физическое железо (процессор, память, диски).
    
2. **Kernel Space (красная зона):** Зона «всевластия». Любая ошибка здесь фатальна. В монолите она огромная, в микроядре — тонкая полоска.
    
3. **User Space (белая зона):** Зона безопасности. Здесь работают твои программы (браузер, игры). В микроядре сюда же переезжают и части самой ОС (драйверы, сервера файлов).
    
4. **IPC (Inter-Process Communication):** Это «мостики» в микроядре. Поскольку компоненты разделены, им нужны эти каналы для общения. В монолите они не нужны, так как всё и так находится в одном месте.

```
Application (Приложение)
  ↓
Application IPC (Межпроцессное взаимодействие приложений)
  ↓
Unix Server (Сервер Unix-совместимости)
Device Driver (Драйвер устройства)
File Server (Файловый сервер)
  ↓
User Space (Пользовательское пространство)
─────── Граница ───────
VFS, System calls (Виртуальная ФС, системные вызовы)
IPC, File System (Межпроцессное взаимодействие, Файловая система)
Scheduler virtual Memory (Планировщик, виртуальная память)
Device Driver, Dispatcher (Драйвер устройства, Диспетчер)
  ↓
Basic IPC, Virtual Memory, Scheduling 
(Базовая IPC, виртуальная память, планирование)
  ↓
Hardware (Аппаратное обеспечение)
```

---

### Ключевое отличие

### Микроядро (Microkernel):

- **Ядро минимально** (только самое необходимое)
- **Большинство сервисов ОС работают в пользовательском пространстве** как отдельные процессы ("серверы")
- Ядро содержит только:
    
    1. Базовое управление процессами (создание, уничтожение)
    2. Межпроцессное взаимодействие (IPC)
    3. Управление виртуальной памятью
    4. Базовое планирование

### Монолитное ядро (Monolithic Kernel):

- **Все сервисы ОС работают в ядре** в одном адресном пространстве
- Ядро содержит ВСЁ:
    
    1. Драйверы устройств
    2. Файловые системы
    3. Сетевой стек
    4. Управление процессами
    5. Виртуальную память и т.д.
---

>Windows — это гибридное ядро: архитектурно похоже на микроядро, но по факту работает как монолит ради производительности.

### Почему Windows — это гибрид?

Если смотреть на схему, которую ты прислала, Windows находится «посередине» между этими двумя картинками:

1. **От микроядра она взяла архитектуру:** * Внутри Windows всё разделено на модули.
    
    - Ядро спроектировано так, чтобы компоненты общались через сообщения.
        
    - Многие драйверы в современных версиях (например, драйверы принтеров или некоторые части видеодрайверов) вынесены в **User Space**, чтобы их ошибка не приводила к синему экрану.
        
2. **От монолита она взяла производительность:** * Самые критичные вещи (графическая подсистема, оконный менеджер, драйверы файловой системы) работают **внутри Kernel Space**.
    
    - Это сделано потому, что если бы Windows была «чистым» микроядром, игры и тяжелые программы работали бы значительно медленнее из-за постоянного переключения между режимами.

### Как эта модульность реализована в Windows?

Windows была спроектирована как микроядро, но чтобы не тормозить, её «пересобрали». Представь это так:
#### А) Дизайн (как микроядро):

Ядро Windows — это не монолитный кусок кода, а набор **независимых объектов (модулей)**. У каждого модуля есть свой четкий интерфейс.

- Есть модуль **Object Manager** (управляет ресурсами).
- Есть модуль **Process Manager** (управляет процессами).
- Есть модуль **I/O Manager** (управляет вводом-выводом).

Они общаются друг с другом через формальные запросы (похоже на пересылку сообщений), а не просто хаотично залезают в чужой код.

#### Б) Реализация (как монолит):

Чтобы не тратить время на «походы на почту» (IPC), разработчики Microsoft решили: «Пусть эти независимые модули сидят **в одной комнате** (в Kernel Space)».

- Теперь они всё еще общаются официально, через запросы, но делают это мгновенно, так как находятся в общем адресном пространстве.
    

**Именно поэтому Windows — гибрид:**

1. По **структуре** (как всё организовано внутри кода) — она модульная, как микроядро.
2. По **запуску** (где этот код живет в памяти) — она работает в режиме ядра, как монолит.

Представь, что у тебя завис видеодрайвер:

- В **чистом монолите** (старый Linux) компьютер бы просто замер («паника ядра»).
    
- В **Windows** ты увидишь, как экран моргнул, и выскочит сообщение: «Видеодрайвер был успешно восстановлен».
    
- **Почему?** Потому что в Windows драйвер — это отдельный модуль. Ядро смогло понять, что именно этот «кусочек» сломался, выкинуло его и запустило заново, не останавливая всю систему. **Это и есть проявление модульности и идей микроядра в гибриде.**

---
### Список литературы

https://gemini.google.com/share/8327fd724cdb
https://chatgpt.com/share/69517fd6-2970-8001-804d-fd7286e722e0
https://www.youtube.com/watch?v=G7bqvpAw7HE