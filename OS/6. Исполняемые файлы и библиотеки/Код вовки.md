# Примеры использования общей библиотеки для курса OS

Этот базовый пример демонстрирует использование динамической компоновки во время выполнения.

Предположим, вы хотите реализовать невероятно быстрые версии своих любимых математических функций: `abs` и `cos`, но не хотите заменять их полностью, потому что стандартная математическая библиотека более точна, но работает медленно. Итак, вы создали программу, которая использует пользовательские функции по запросу и возвращается к стандартной реализации, если библиотека не установлена.

## Компиляция

### Linux

`dl` это загрузчик динамических библиотек во время выполнения

```shell
cc -o library.so -fPIC -shared library.c
cc -o example -ldl posix_example.c 
```

### Windows

```batchfile
cl /LD library.c
cl win32_example.c
```

## Выполняется

Приведённые ниже инструкции применимы и к Windows (`cmd`, `ps`), просто удалите `./` и замените `.so` на `.dll`.

Запустите со стандартной реализацией:

```shell
./example
```

Запуск с пользовательской реализацией:

```shell
./example ./library.so
```

[**library.c**]
```c
#include "library.h"

// NOTE: MSVC compiler does not export symbols unless annotated
#ifdef _MSC_VER
#define EXPORT __declspec(dllexport)
#else
#define EXPORT
#endif

EXPORT float fabsf(float x) {
	union {
		float f;
		unsigned i;
	} u = {x};

	u.i &= 0x7fffffff;

	return u.f;
}

EXPORT float cosf(float x) {
	const float x2 = x * x;
	return 1.0f -
	       (x2 / 2.0f) +
	       (x2 * x2) / 24.0f -
	       (x2 * x2 * x2) / 720.0f +
	       (x2 * x2 * x2 * x2) / 40320.0f -
	       (x2 * x2 * x2 * x2 * x2) / 3628800.0f +
	       (x2 * x2 * x2 * x2 * x2 * x2) / 479001600.0f;
}
```

[**library.h**]

```c
#ifndef __LIBRARY_H
#define __LIBRARY_H

typedef float fabsf_func(float x);
typedef float cosf_func(float x);

#endif // __LIBRARY_H
```

[**posix_example.c**]

```c
#include <stddef.h>
#include <stdlib.h>
#include <stdio.h>

#include <unistd.h> // write
#include <dlfcn.h> // dlopen, dlsym, dlclose, RTLD_*

#include "library.h" // NOTE: Custom function types

static fabsf_func *fabsf;
static cosf_func *cosf;

// NOTE: Functions stubs will be used, if library failed to load
// NOTE: Stubs are better than NULL function pointers,
//       you don't need to check for NULL before calling a function
static float func_impl_stub(float x) {
	(void)x; // NOTE: Compiler will warn about unused parameter otherwise
	return 0.0f;
}

int main(int argc, char **argv) {
	(void)argc;

	void *library = dlopen(argv[1], RTLD_LOCAL | RTLD_NOW);

	if (argc > 1 && library != NULL) {
		fabsf = dlsym(library, "fabsf");
		if (fabsf == NULL) {
			const char msg[] = "warning: failed to find abs function implementation\n";
			write(STDERR_FILENO, msg, sizeof(msg));
			fabsf = func_impl_stub;
		}

		cosf = dlsym(library, "cosf");
		if (cosf == NULL) {
			const char msg[] = "warning: failed to find cosine function implementation\n";
			write(STDERR_FILENO, msg, sizeof(msg));
			cosf = func_impl_stub;
		}
	} else {
		const char msg[] = "warning: library failed to load, trying standard implemntations\n";
		write(STDERR_FILENO, msg, sizeof(msg));

		// NOTE: Trying standard implementations
		library = dlopen("libm.so.6", RTLD_GLOBAL | RTLD_LAZY);
		if (library == NULL) {
			const char msg[] = "error: failed to open standard math library\n";
			write(STDERR_FILENO, msg, sizeof(msg));
			return EXIT_FAILURE;
		}

		fabsf = dlsym(library, "fabsf");
		cosf = dlsym(library, "cosf");
	}

	{
		const float x = -3.14159f;
		const float y = fabsf(x);

		char buf[1024];
		int length = snprintf(buf, sizeof(buf) - 1, "Abs of %.10f is %.10f\n", x, y);
		buf[length] = '\0';
		write(STDOUT_FILENO, buf, length);
	}

	{
		const float x = 0.5f;
		const float y = cosf(x);

		char buf[1024];
		int length = snprintf(buf, sizeof(buf) - 1, "Cosine of %f is %.10f\n", x, y);
		buf[length] = '\0';
		write(STDOUT_FILENO, buf, length);
	}

	if (library) {
		dlclose(library);
	}
}
```

