 
(https://gist.github.com/vladeemerr/dcf8ef920361e3f5a7aa6eaaeea77a4e#file-posix_ipc-example-client-c)
# Примеры кода IPC для курса по ОС

В этом базовом примере показано, как:

- Создать новый процесс (`fork`)
- Заменить образ процесса (`exec`)
- Создать канал связи (`pipe`)
- Заменить файловые дескрипторы (`dup`)
- `write` на / `read` из файловых дескрипторов
- `open` / `close` файлов
- `wait`до завершения дочернего процесса
- Бонус: чтение ссылок на файлы через `readlink`

Клиент перенаправляет вводные данные терминала на сервер, где они дополняются информацией и записываются в файл `filename`.

## Компиляция

Минимальное количество команд для компиляции примера:

```shell
cc -o posix_ipc-example-client posix_ipc-example-client.c
cc -o posix_ipc-example-server posix_ipc-example-server.c
```

## Выполняется

Запустите клиент с выбранным вами именем файла и начинайте вводить текст, пока не нажмёте `Ctrl-D` или `Enter` в пустой строке, чтобы выйти.

```shell
./posix_ipc-example-client имя_файла
```

**ВАЖНО: исполняемый файл сервера должен называться `posix_ipc-example-server` и находиться рядом с клиентом, иначе сервер завершит работу с ошибкой!**

Если вы хотите переименовать исполняемый файл сервера, вам также нужно изменить константу `SERVER_PROGRAM_NAME`

**posix_ipc-example-client.c**
```c
#include <stdint.h>
#include <stdbool.h>

#include <unistd.h>
#include <sys/wait.h>
#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>

static char SERVER_PROGRAM_NAME[] = "posix_ipc-example-server";

int main(int argc, char **argv) {
	if (argc == 1) {
		char msg[1024];
		uint32_t len = snprintf(msg, sizeof(msg) - 1, "usage: %s filename\n", argv[0]);
		write(STDERR_FILENO, msg, len);
		exit(EXIT_SUCCESS);
	}

	// NOTE: Get full path to the directory, where program resides
	char progpath[1024];
	{
		// NOTE: Read full program path, including its name
		ssize_t len = readlink("/proc/self/exe", progpath,
		                       sizeof(progpath) - 1);
		if (len == -1) {
			const char msg[] = "error: failed to read full program path\n";
			write(STDERR_FILENO, msg, sizeof(msg));
			exit(EXIT_FAILURE);
		}

		// NOTE: Trim the path to first slash from the end
		while (progpath[len] != '/')
			--len;

		progpath[len] = '\0';
	}

	// NOTE: Open pipes
	int client_to_server[2]; // AB
	if (pipe(client_to_server) == -1) {
		const char msg[] = "error: failed to create pipe\n";
		write(STDERR_FILENO, msg, sizeof(msg));
		exit(EXIT_FAILURE);
	}

	int server_to_client[2]; // BA
	if (pipe(server_to_client) == -1) {
		const char msg[] = "error: failed to create pipe\n";
		write(STDERR_FILENO, msg, sizeof(msg));
		exit(EXIT_FAILURE);
	}

	// NOTE: Spawn a new process
	const pid_t child = fork();

	switch (child) {
	case -1: { // NOTE: Kernel fails to create another process
		const char msg[] = "error: failed to spawn new process\n";
		write(STDERR_FILENO, msg, sizeof(msg));
		exit(EXIT_FAILURE);
	} break;

	case 0: { // NOTE: We're a child, child doesn't know its pid after fork
		{
			pid_t pid = getpid(); // NOTE: Get child PID

			char msg[64];
			const int32_t length = snprintf(msg, sizeof(msg),
				"%d: I'm a child\n", pid);
			write(STDOUT_FILENO, msg, length);
		}

		close(client_to_server[1]);
		close(server_to_client[0]);

		dup2(client_to_server[0], STDIN_FILENO);
		close(client_to_server[0]);

		dup2(server_to_client[1], STDOUT_FILENO);
		close(server_to_client[1]);

		{
			char path[1024];
			snprintf(path, sizeof(path) - 1, "%s/%s", progpath, SERVER_PROGRAM_NAME);

			// NOTE: args[0] must be a program name, next the actual arguments
			// NOTE: `NULL` at the end is mandatory, because `exec*`
			//       expects a NULL-terminated list of C-strings
			char *const args[] = {SERVER_PROGRAM_NAME, argv[1], NULL};

			int32_t status = execv(path, args);

			if (status == -1) {
				const char msg[] = "error: failed to exec into new exectuable image\n";
				write(STDERR_FILENO, msg, sizeof(msg));
				exit(EXIT_FAILURE);
			}
		}
	} break;

	default: { // NOTE: We're a parent, parent knows PID of child after fork
		{
			pid_t pid = getpid(); // NOTE: Get parent PID

			char msg[64];
			const int32_t length = snprintf(msg, sizeof(msg),
				"%d: I'm a parent, my child has PID %d\n", pid, child);
			write(STDOUT_FILENO, msg, length);
		}

		close(client_to_server[0]);
		close(server_to_client[1]);

		char buf[4096];
		ssize_t bytes;

		while (bytes = read(STDIN_FILENO, buf, sizeof(buf))) {
			if (bytes < 0) {
				const char msg[] = "error: failed to read from stdin\n";
				write(STDERR_FILENO, msg, sizeof(msg));
				exit(EXIT_FAILURE);
			} else if (buf[0] == '\n') {
				// NOTE: When Enter is pressed with no input, then exit client
				break;
			}

			write(client_to_server[1], buf, bytes);

			bytes = read(server_to_client[0], buf, sizeof(bytes));
			write(STDOUT_FILENO, buf, bytes);
		}

		close(client_to_server[1]);
		close(server_to_client[0]);

		wait(NULL);
	} break;
	}
}
```

**posix_ipc-example-server.c**

```c
#include <stdint.h>
#include <stdbool.h>
#include <ctype.h>

#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <stdio.h>

int main(int argc, char **argv) {
	char buf[4096];
	ssize_t bytes;

	pid_t pid = getpid();

	// NOTE: `O_WRONLY` only enables file for writing
	// NOTE: `O_CREAT` creates the requested file if absent
	// NOTE: `O_TRUNC` empties the file prior to opening
	// NOTE: `O_APPEND` subsequent writes are being appended instead of overwritten
	int32_t file = open(argv[1], O_WRONLY | O_CREAT | O_TRUNC | O_APPEND, 0600);
	if (file == -1) {
		const char msg[] = "error: failed to open requested file\n";
		write(STDERR_FILENO, msg, sizeof(msg));
		exit(EXIT_FAILURE);
	}

	while (bytes = read(STDIN_FILENO, buf, sizeof(buf))) {
		if (bytes < 0) {
			const char msg[] = "error: failed to read from stdin\n";
			write(STDERR_FILENO, msg, sizeof(msg));
			exit(EXIT_FAILURE);
		}

		// NOTE: Transform data
		for (uint32_t i = 0; i < bytes; ++i) {
			buf[i] = toupper(buf[i]);
		}

		{
			// NOTE: Log to file
			int32_t written = write(file, buf, bytes);
			if (written != bytes) {
				const char msg[] = "error: failed to write to file\n";
				write(STDERR_FILENO, msg, sizeof(msg));
				exit(EXIT_FAILURE);
			}

			{
				const char msg[] = "Server received: ";
				write(STDERR_FILENO, msg, sizeof(msg) - 1);
			}

			// NOTE: Echo back to client
			written = write(STDOUT_FILENO, buf, bytes);
			if (written != bytes) {
				const char msg[] = "error: failed to echo\n";
				write(STDERR_FILENO, msg, sizeof(msg));
				exit(EXIT_FAILURE);
			}
		}
	}

	// NOTE: Write terminator to the end file
	if (bytes == 0) {
		const char term = '\0';
		write(file, &term, sizeof(term));
	}

	close(file);
}
```