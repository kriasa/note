# Концепция динамического массива

**Динамический массив (dynamic array, vector, ArrayList)** — это абстрактная структура данных, реализующая массив с **автоматическим изменением размера**. В отличие от статического массива фиксированного размера, динамический массив может расти и сжиматься во время выполнения программы.
### Ключевые характеристики:
- **Непрерывное размещение в памяти** — все элементы располагаются последовательно
- **Автоматическое управление емкостью** — при переполнении происходит реаллокация
- **Амортизированная константная сложность** добавления элемента в конец
- **Константный доступ по индексу** благодаря непрерывности память

# Структура динамического массива
### Базовая структура данных
Динамический массив требует хранения **трех ключевых полей**:
```c
typedef struct {
    int *data;          // Указатель на блок памяти с данными
    size_t size;        // Текущее количество элементов (логический размер)
    size_t capacity;    // Выделенная емкость (физический размер)
} DynamicArray;
```
**Инвариант**: `size <= capacity` всегда. `capacity` — это размер выделенной памяти, `size` — количество реально используемых элементов.

## Стратегии перераспределения памяти
### 1. Стратегия удвоения емкости (Geometric Growth)
**Суть**: при переполнении новая емкость = `capacity * k`, где `k ≥ 2` (обычно `k = 2`).

**Алгоритм**:
- Если `size == capacity`, выделяется новый блок размером `capacity * 2`
- Копируются все элементы из старого блока
- Старый блок освобождается
- Указатель перенаправляется на новый блок

**Алгоритмическая сложность добавления n элементов**:
При добавлении `n` элементов с удвоением емкости происходят копирования на этапах: 1, 2, 4, 8, 16, ..., n/2 элементов.
Суммарное количество копирований: `1 + 2 + 4 + 8 + ... + n/2 = n - 1` (геометрическая прогрессия).

**Амортизированная сложность одного добавления**: `O(n) / n = O(1)` — константное время!

**Худший случай одной операции**: `O(n)` — когда происходит реаллокация и копирование всех элементов.

**Лучший случай одной операции**: `O(1)` — когда есть свободное место (`size < capacity`).

### 2. Стратегия фиксированного приращения (Additive Growth)
**Суть**: при переполнении новая емкость = `capacity + C`, где `C` — константа.
**Проблема**: неэффективна при большом количестве добавлений!
При добавлении `n` элементов с приращением `C`:
- Реаллокации происходят каждые `C` элементов
- Количество реаллокаций: `n / C`
- На каждой реаллокации копируется `i * C` элементов (где `i` — номер реаллокации)
- Суммарное количество копирований: `C + 2C + 3C + ... + (n/C)*C = C * (1 + 2 + ... + n/C) = C * (n/C)^2 / 2 = O(n^2)`
**Амортизированная сложность**: `O(n^2) / n = O(n)` — **линейная**, не константная!
**Вывод**: стратегия фиксированного приращения **неэффективна** для динамических массивов.
### 3. Стратегия коэффициента роста < 2 (Golden Ratio Growth)
**Суть**: использовать коэффициент меньше 2, например `φ ≈ 1.5` или золотое сечение `1.618`.

**Преимущество**: лучшее переиспользование памяти. При коэффициенте 2 новый блок всегда больше суммы всех предыдущих освобожденных блоков, что затрудняет их переиспользование аллокатором.
С коэффициентом `< 2` новый блок может занять место, освобожденное предыдущими реаллокациями.
**Недостаток**: математически менее элегантно, минимальная разница в производительности на практике.
**Стандарты**: C++ STL vector использует коэффициент 2 (GCC) или 1.5 (MSVC).

---
# Операции над динамическим массивом
### 1. Инициализация
**Пустой массив с начальной емкостью**: Выделяется память под начальную емкость (типично 8-16 элементов), `size = 0`.
**Сложность**: `O(1)` — один вызов `malloc`.
**Почему не capacity = 0?**: чтобы избежать реаллокации при первом же добавлении. Компромисс между памятью и производительностью.

### 2. Доступ к элементу по индексу (Random Access)
**Операция**: чтение/запись элемента по индексу `i`.
**Алгоритм**: `data[i]` — прямое обращение по адресу `data + i * sizeof(элемент)`.
**Сложность**: `O(1)` — константное время, это **главное преимущество** массивов.
**Проверка границ**: в production коде необходимо проверять `i < size`, иначе — неопределенное поведение.
### 3. Добавление элемента в конец (push_back, append)
**Алгоритм**:
1. Проверить, есть ли место: `size < capacity`
2. Если нет — реаллоцировать с увеличенной емкостью
3. Записать элемент: `data[size] = value`
4. Инкрементировать: `size++`

**Сложность**:
- **Амортизированная**: `O(1)` — константное время в среднем
- **Худший случай**: `O(n)` — когда требуется реаллокация и копирование
- **Лучший случай**: `O(1)` — когда есть свободное место

**Ключевое понятие — амортизация**: хотя отдельные операции могут быть дорогими (`O(n)`), в среднем на большой последовательности операций стоимость распределяется, давая `O(1)` на операцию.
### 4. Добавление элемента в середину (insert)
**Операция**: вставка элемента на позицию `index`.

**Алгоритм**:
1. Если `size == capacity` — реаллоцировать
2. Сдвинуть все элементы от `index` до `size-1` на одну позицию вправо
3. Записать элемент на позицию `index`
4. Инкрементировать `size`

**Сложность**: `O(n)` — линейное время из-за необходимости сдвига элементов.
В худшем случае (вставка в начало) нужно сдвинуть все `n` элементов. В среднем случае (случайная позиция) — `n/2` элементов, что всё равно `O(n)`.
### 5. Удаление элемента из конца (pop_back)
**Алгоритм**:
1. Проверить, что массив не пуст: `size > 0`
2. Декрементировать: `size--`
3. Опционально — обнулить элемент для очистки памяти

**Сложность**: `O(1)` — константное время, просто уменьшаем счетчик.

**Сжатие памяти**: при многих удалениях `capacity` может значительно превышать `size`. Некоторые реализации автоматически уменьшают `capacity`, когда `size < capacity / 4` (гистерезис, чтобы избежать постоянных реаллокаций при колебаниях размера).
### 6. Удаление элемента из середины (erase)
**Операция**: удаление элемента на позиции `index`.

**Алгоритм**:
1. Проверить границы: `index < size`
2. Сдвинуть все элементы от `index+1` до `size-1` на одну позицию влево
3. Декрементировать `size`

**Сложность**: `O(n)` — линейное время из-за сдвига элементов.

В худшем случае (удаление первого элемента) — сдвиг `n-1` элементов. В среднем — `n/2`.
### 7. Поиск элемента по значению (find)
**Операция**: найти индекс первого вхождения элемента со значением `value`.

**Алгоритм**: линейный поиск — последовательный проход по массиву.

**Сложность**:
- **Худший случай**: `O(n)` — элемента нет или он последний
- **Лучший случай**: `O(1)` — элемент первый
- **Средний случай**: `O(n/2) = O(n)` — элемент в середине

**Оптимизация**: если массив **отсортирован**, можно использовать **бинарный поиск** со сложностью `O(log n)`, но динамические массивы обычно не поддерживают автоматическую сортировку (это задача уровня выше).
### 8. Очистка массива (clear)
**Алгоритм**: `size = 0`, память остается выделенной.

**Сложность**: `O(1)` — константное время.

Физически элементы остаются в памяти, но логически массив пуст. Для полного освобождения памяти нужна отдельная операция `shrink` или `free`.
### 9. Уничтожение массива (destroy)
**Алгоритм**: `free(data)`, обнулить поля структуры.

**Сложность**: `O(1)` — один вызов `free`.

**Важно**: если элементы массива сами содержат динамические данные (указатели), их нужно освобождать **до** вызова `free(data)`, иначе — утечка памяти.

---

## Таблица вычислительных сложностей

| Операция                     | Лучший случай | Средний случай | Худший случай | Амортизированная |
| ---------------------------- | ------------- | -------------- | ------------- | ---------------- |
| Доступ по индексу            | O(1)          | O(1)           | O(1)          | O(1)             |
| Поиск по значению            | O(1)          | O(n)           | O(n)          | O(n)             |
| Добавление в конец           | O(1)          | O(1)           | O(n)          | **O(1)**         |
| Добавление в середину/начало | O(n)          | O(n)           | O(n)          | O(n)             |
| Удаление из конца            | O(1)          | O(1)           | O(1)          | O(1)             |
| Удаление из середины/начала  | O(n)          | O(n)           | O(n)          | O(n)             |

---
