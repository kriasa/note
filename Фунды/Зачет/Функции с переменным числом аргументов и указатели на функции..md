
# Функции с переменным числом аргументов (Variadic Functions)
**Определение**: Функции, которые могут принимать произвольное количество аргументов. Классический пример — `printf()` и `scanf()`.
### Синтаксис объявления
```c
#include <stdarg.h>

тип_возврата имя_функции(тип обязательный_параметр, ...);
```

# Типы данных для работы с variadic functions
### va_list
**Что это по сути**: Это **непрозрачный тип данных** (opaque type), который хранит информацию о текущем состоянии обработки списка аргументов.

**Реализация зависит от платформы**:
- На x86-64 (System V ABI): обычно это структура, содержащая указатели на область стека и регистры
- На других архитектурах: может быть просто указателем на стек

**Критически важно**: `va_list` — это **изменяемый объект**. Каждый вызов `va_arg()` модифицирует его внутреннее состояние, перемещая "указатель" на следующий аргумент.

# Основные макросы для работы с переменными аргументами

Все макросы определены в заголовочном файле `<stdarg.h>`.

### 1. va_start (MACRO!!)
```c
void va_start(va_list ap, lastNamedParam)
```
**Инициализирует** `va_list` для начала обработки перепменных.
**Параметры**:
- `ap` — переменная типа `va_list`
- `last_named_param` — имя последнего именованного параметра перед `...`

#### Что делает под капотом
```c
#define va_start(ap, last)  (ap = (char*)&last + ...)

va_start(ap, x);  
ap = (char*)&x + SIZE;  // раскрытый типа
```

### 2. va_arg (MACRO!!)
```c
TYPE va_arg(va_list ap, TYPE);
```
Извлекает следущ
**Параметры**:
- `ap` — переменная типа `va_list`
- `TYPE` —  тип извлекаемого аргумента
**Returns**:
- TYPE — переменную типа TYPE

**Default argument promotions**: При передаче через `...` происходят автоматические преобразования:
- `char` и `short` → `int`
- `float` → `double`

### 3. va_end (MACRO!!)
```c
void va_end(va_list ap);
```
**Важно**: Вызов `va_end` **обязателен** после каждого `va_start`! Это может быть критично на некоторых платформах, где `va_list` выделяет ресурсы.

**После вызова `va_end`**: Переменная `ap` становится неопределённой (undefined). Для повторного использования нужен новый `va_start`.

## Полный пример variadic function

```c
#include <stdarg.h>
#include <stdio.h>

// Функция суммирует count целых чисел
int sum(int count, ...) {
    va_list args;
    va_start(args, count);  // инициализация
    
    int total = 0;
    for (int i = 0; i < count; i++) {
        int value = va_arg(args, int);  // извлечение очередного аргумента
        total += value;
    }
    
    va_end(args);  // обязательное завершение
    return total;
}

int main() {
    printf("%d\n", sum(3, 10, 20, 30));     // 60
    printf("%d\n", sum(5, 1, 2, 3, 4, 5));  // 15
    return 0;
}
```

---

# Указатели на функции
### Определение
*Переменная*, которая хранит в памяти *адрес функции*. Позволяет косвенно вызывать функцию.
#### Синтаксис объявления
```c
тип_возврата (*имя_указателя)(типы_параметров);

int (*func_ptr)(int, int);     // указатель на функцию
int *func_ptr(int, int);       // функция, возвращающая int* (не то!)
```

**Важные детали**:
- Имя функции автоматически преобразуется в указатель (как массивы)
- `&add` и `add` — эквивалентны
- `(*operation)(3, 4)` и `operation(3, 4)` — эквивалентны (разыменование необязательно)

### Зачем нужны указатели на функции
1. **Callback-функции**: Передача функции как параметра
2. **Таблицы диспетчеризации**: Выбор функции во время выполнения
3. **Реализация полиморфизма** в C
4. **Обработчики событий**: Event-driven programming
5. **Plugin-системы**: Динамическая загрузка функционала
# Массив указателей на функции

**Определение**: Массив, каждый элемент которого — указатель на функцию. Используется для реализации таблиц диспетчеризации (dispatch tables) или state machines.

### Синтаксис объявления

```c
#include <stdio.h>

int add(int a, int b) { return a + b; }
int subtract(int a, int b) { return a - b; }
int multiply(int a, int b) { return a * b; }
int divide(int a, int b) { return a / b; }

int main() {
    // Массив указателей на функции
    int (*operations[4])(int, int) = {add, subtract, multiply, divide};
    
    char *op_names[] = {"+", "-", "*", "/"};
    
    int x = 10, y = 5;
    
    for (int i = 0; i < 4; i++) {
        printf("%d %s %d = %d\n", x, op_names[i], y, operations[i](x, y));
    }
    
    return 0;
}
```

**Вывод**:
```c
10 + 5 = 15
10 - 5 = 5
10 * 5 = 50
10 / 5 = 2
```

---

# Функция atexit (defer-like)

**Прототип**:
```c
#include <stdlib.h>

int atexit(void (*function)(void));
```
**Назначение**: Регистрирует функцию, которая будет вызвана автоматически при **нормальном завершении программы** (через `return` из `main` или вызов `exit()`).
**Возвращает**:
- `0` при успешной регистрации
- Ненулевое значение при ошибке
### Правила работы atexit
1. **Порядок вызова**: LIFO (Last In, First Out) — последняя зарегистрированная функция вызывается первой
2. **Количество**: Стандарт гарантирует минимум **32** функции, многие реализации поддерживают больше
3. **Сигнатура**: Функция должна иметь тип `void (*)(void)` — без параметров и без возврата
4. **Не вызывается**: При аварийном завершении (сигналы, `abort()`, `_Exit()`)