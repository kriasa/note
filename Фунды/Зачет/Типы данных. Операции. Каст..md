# Основные типы данных

### Целочисленные типы

**char** — 1 байт, от -128 до 127 (или 0 до 255 для unsigned)
**short** — 2 байта, от -32,768 до 32,767
**int** — обычно 4 байта, от -2,147,483,648 до 2,147,483,647
**long** — 4 или 8 байт (зависит от платформы)
**long long** — минимум 8 байт

Модификаторы: **unsigned** (только положительные значения), **signed** (по умолчанию)
### Типы с плавающей точкой

**float** — 4 байта, точность ~7 десятичных цифр
**double** — 8 байт, точность ~15 десятичных цифр
**long double** — 10-16 байт (зависит от компилятора)
### Другие типы
**void** — отсутствие типа (используется для функций без возвращаемого значения)
**\_Bool** (или **bool** с stdbool.h) — логический тип, 0 или 1

---
# Операции над переменными

### Арифметические операции

**Основные операторы:**
- `+` — сложение
- `-` — вычитание
- `*` — умножение
- `/` — целочисленно деление (floor div)
- `%` — остаток от деления (только для целых чисел)

**Особенности:**
```c
int a = 7, b = 3;
int result1 = a / b;      // result1 = 2 (целочисленное деление)
float result2 = a / b;    // result2 = 2.0 (оба операнда int)
float result3 = (float)a / b;  // result3 = 2.333... (неявное приведение типа)

int c = -7;
int result4 = c % 3;      // result4 = -1 (знак как у делимого)
```

**Инкремент и декремент:**

- `++` — увеличение на 1 (prefix: `++i` или postfix: `i++`)
- `--` — уменьшение на 1

```c
int x = 5;
int y = ++x;  // x = 6, y = 6 (сначала увеличение)
int z = x++;  // x = 7, z = 6 (сначала присваивание)
```

### Логические операции

**Операторы сравнения:**
- `==` — равно
- `!=` — не равно
- `<`, `>` — меньше, больше
- `<=`, `>=` — меньше или равно, больше или равно

**Логические операторы:**
- `&&` — логическое И (AND)
- `||` — логическое ИЛИ (OR)
- `!` — логическое НЕ (NOT)

**Особенности:**
```c
int a = 5, b = 0;
if (a && b) { }  // false, b == 0
if (a || b) { }  // true, a != 0

// Короткое замыкание (short-circuit evaluation)
if (b != 0 && a / b > 2) { }  // второе условие не проверяется, если b == 0
```
В C любое ненулевое значение считается истинным, 0 — ложным.

### Битовые (бинарные) операции

Работают на уровне отдельных битов целых чисел:
- `&` — побитовое И (AND)
- `|` — побитовое ИЛИ (OR)
- `^` — побитовое исключающее ИЛИ (XOR)
- `~` — побитовое НЕ (NOT, инверсия)
- `<<` — сдвиг влево
- `>>` — сдвиг вправо

**Примеры:**
```c
unsigned int a = 12;  // 1100 в двоичной системе
unsigned int b = 10;  // 1010 в двоичной системе

unsigned int c = a & b;   // 1000 = 8
unsigned int d = a | b;   // 1110 = 14
unsigned int e = a ^ b;   // 0110 = 6
unsigned int f = ~a;      // инверсия всех битов

unsigned int g = a << 2;  // 110000 = 48 (умножение на 2²)
unsigned int h = a >> 1;  // 110 = 6 (деление на 2)
```

**Практическое применение:**
```c
// Проверка чётности
if (n & 1) { /* нечётное */ }

// Умножение/деление на степени двойки
int fast_mult = n << 3;  // n * 8
int fast_div = n >> 2;   // n / 4

// Установка/сброс битов
int flags = 0;
flags |= (1 << 3);   // установить 3-й бит
flags &= ~(1 << 3);  // сбросить 3-й бит
```

---
# Приведение типов (Type Casting)

### Неявное приведение (Implicit Casting)

Происходит автоматически при операциях с разными типами. Применяются правила продвижения типов:

1. Если один операнд `long double`, другой преобразуется в `long double`
2. Иначе если один `double`, другой в `double`
3. Иначе если один `float`, другой в `float`
4. Иначе применяется целочисленное продвижение (char, short → int)
5. Если типы различаются, меньший преобразуется в больший
```c
int a = 10;
float b = 3.5;
float result = a + b; // a неявно преобразуется в float
```

### Явное приведение (Explicit Casting)
```c
int a = 10, b = 3;
float result = (float)a / b;  // 3.333...

// Без приведения
float wrong = a / b;  // 3.0 (целочисленное деление, затем преобразование)

// Потеря данных при приведении к меньшему типу
double pi = 3.14159;
int truncated = (int)pi;  // 3 (дробная часть отбрасывается)
```
Может привести к переполнению.

# Операция быстрого возведения в степень

### Быстрое возведение в степень — O(log n)

Основан на принципе "разделяй и властвуй" и бинарном представлении показателя степени:

**Принцип:**

- Если exp чётное: base^exp = (base²)^(exp/2)
- Если exp нечётное: base^exp = base × base^(exp-1)

**Итеративная реализация:**
```c
long long fast_power(long long base, long long exp) {
	long long result = 1;
	
	while (exp > 0) {
		if (exp & 1) {
			result *= base;
		}
		
		base *= base;
		exp >>= 1;
	}
	return result;
}
```


## Проблемы точности вещественных чисел

### Ошибки округления
Не все десятичные числа можно точно представить в двоичной системе
### Сравнение вещественных чисел
Такие сравнения производятся только как разность по модулю `fabs(a - b) < EPS`
### Потеря значимости
При операциях с числами разного масштаба: