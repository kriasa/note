# Что такое файл на самом деле?

**Файл** — это абстракция над последовательностью байтов, хранящихся на устройстве (диск, SSD, сеть).

На уровне операционной системы:
- **Файловый дескриптор** (UNIX) или **хэндл** (Windows) — целое число, идентифицирующее открытый файл
- ОС поддерживает таблицу открытых файлов для каждого процесса
- Каждая запись содержит: позицию чтения/записи, режим доступа, буферы

В C эта сложность скрыта за структурой `FILE`.
### Что такое FILE?
`FILE` — это **непрозрачная структура** (opaque type), определённая в `<stdio.h>`. Её точное содержимое зависит от реализации, но концептуально:
```c
struct _IO_FILE {
    int fd;                    // Файловый дескриптор ОС
    
    // Указатели для чтения (start, end, cur) БУФФЕРОВ!!
    char *read_ptr;            // Указатель текущей позиции чтения в буфере
    char *read_end;            // Конец данных в буфере чтения
    char *read_base;           // Начало буфера чтения
    
    // Указатели для записи (start, end, cur) БУФФЕРОВ!!
    char *write_ptr;           // Указатель текущей позиции записи
    char *write_end;           // Конец буфера записи
    char *write_base;          // Начало буфера записи
    
    // Буфер
    unsigned char *buffer;     // Основной буфер
    size_t buffer_size;        // Размер буфера (обычно 4KB или 8KB)
    
    int flags;                 // Флаги состояния (EOF, error, etc.)
    int mode;                  // Режим открытия (read/write/append)
    
    fpos_t position;           // Текущая позиция в файле
    
    // И другое...
};
```


**Ключевая идея:** `FILE` содержит **буфер** между программой и файлом. 
**Проблема:** Системные вызовы (read/write) **медленные** — каждый вызов требует переключения контекста ядро/пользователь. 
**Решение:** Буферизация в пространстве пользователя.

**Типы буферизации:**
1. **Полная буферизация** (\_IOFBF) — данные записываются при заполнении буфера
2. **Построчная буферизация** (\_IOLBF) — данные записываются при встрече '\n' (для терминалов)
3. **Без буферизации** (\_IONBF) — каждая операция сразу идёт в ОС (stderr по умолчанию)


**Режимы открытия:**

| Режим  | Описание          | Позиция          | Файл не существует | Файл существует |
| ------ | ----------------- | ---------------- | ------------------ | --------------- |
| `"r"`  | Чтение            | Начало           | Ошибка             | Открывается     |
| `"w"`  | Запись            | Начало           | Создаётся          | **Очищается**   |
| `"a"`  | Добавление        | Конец            | Создаётся          | Дописывается    |
| `"r+"` | Чтение+запись     | Начало           | Ошибка             | Открывается     |
| `"w+"` | Чтение+запись     | Начало           | Создаётся          | **Очищается**   |
| `"a+"` | Чтение+добавление | Конец для записи | Создаётся          | Дописывается    |

**Дополнительный модификатор:**
- `"b"` — бинарный режим (важно для Windows: `"rb"`, `"wb"`)

##### Что происходит при fclose:
1. Сбрасывает буфер (fflush)
2. Закрывает файловый дескриптор ОС
3. Освобождает структуру FILE
4. Возвращает 0 при успехе, EOF при ошибке

**Важно:** Незакрытые файлы:
- Утечка ресурсов (ограничено количество открытых файлов)
- Данные могут не записаться (остаться в буфере)
- При завершении программы ОС закроет файлы автоматически, но лучше делать явно

```c
long ftell(FILE *stream);                    // Текущая позиция
int fseek(FILE *stream, long offset, int whence);
void rewind(FILE *stream);                   // = fseek(f, 0, SEEK_SET)
```

**Параметры fseek:**
- `SEEK_SET` — от начала файла
- `SEEK_CUR` — от текущей позиции
- `SEEK_END` — от конца файла

```c
fseek(f, 0, SEEK_END);   // В конец файла
long size = ftell(f);    // Размер файла
fseek(f, 0, SEEK_SET);   // Обратно в начало
```

**EOF** — это макрос, обычно равен -1. Это **НЕ символ в файле**, а возвращаемое значение функции.


```c
char* fgets(char *s, int size, FILE *stream);
```
**Поведение fgets:**
- Читает **до size-1** символов
- Останавливается при '\n' (и **включает** его в строку)
- Добавляет '\0' в конец
- Возвращает NULL при EOF или ошибке

```c
int getc(FILE* stream);  // macro -> faster than fgetc
int fgetc(FILE* stream);
```

# Бинарные и текстовые файлы
### Нетипизированные (бинарные) файлы
**Нетипизированный файл** — просто последовательность байтов без структуры.
**Характеристики:**
- Компактны (нет текстового представления)
- Зависят от архитектуры (endianness, размер типов)
- Быстрое чтение/запись
- Нечитаемы человеком
- Проблема переносимости
### Типизированные (текстовые) файлы
**Типизированный файл** — содержит данные в текстовом формате с явной структурой.

## Форматируемый ввод/вывод
**Характеристики:**
- Читаемы человеком
- Переносимы между платформами
- Больше места (12345 → "12345" = 5 символов vs 4 байта)
- Медленнее (преобразование число↔строка)

### Текстовый vs бинарный режим
**Разница проявляется только в Windows:**
**Текстовый режим (`"r"`, `"w"`):**
- Windows: `\r\n` ↔ `\n` (автоматическая конвертация)
- Unix/Linux: без изменений
**Бинарный режим (`"rb"`, `"wb"`):**
- Все системы: байты передаются "как есть"
### Спецификаторы формата printf/scanf
**Основные спецификаторы:**

| Спецификатор | Тип          | Описание                                  |
| ------------ | ------------ | ----------------------------------------- |
| `%d`, `%i`   | int          | Десятичное целое                          |
| `%u`         | unsigned int | Беззнаковое целое                         |
| `%x`, `%X`   | unsigned int | Шестнадцатеричное                         |
| `%o`         | unsigned int | Восьмеричное                              |
| `%f`         | double       | Число с плавающей точкой                  |
| `%e`, `%E`   | double       | Экспоненциальная форма                    |
| `%g`, `%G`   | double       | Автоматический выбор %f/%e                |
| `%c`         | char         | Символ                                    |
| `%s`         | char*        | Строка                                    |
| `%p`         | void*        | Адрес (указатель)                         |
| `%n`         | int*         | Записывает количество выведенных символов |

#### Модификаторы размера:
```c
%hd   // short
%ld   // long
%lld  // long long
%zu   // size_t
%td   // ptrdiff_t

printf("%lld\n", 123456789LL);
```

#### Ширина и точность
```c
printf("%5d\n", 42);      // "   42" (выравнивание по правому краю)
printf("%-5d\n", 42);     // "42   " (по левому краю)
printf("%05d\n", 42);     // "00042" (заполнение нулями)

printf("%.2f\n", 3.14159);  // "3.14" (2 знака после запятой)
printf("%10.2f\n", 3.14);   // "      3.14" (ширина 10, точность 2)

int width = 10;
int precision = 2;
double value = 3.14159;

printf("%*.*f\n", width, precision, value);  // "      3.14"
```


## Выделение лексем из строки

### Принцип границы
**Лексема (token)** — неделимая единица текста, отделённая разделителями.

**Принцип границы:** лексема ограничена:
1. Началом строки
2. Концом строки
3. Разделителями (пробел, запятая, и т.д.)
```python
Строка: "apple,banana:cherry grape"
Разделители: ",: "
Лексемы: "apple", "banana", "cherry", "grape"
```

```c
// Концептуальная реализация strtok
static char *last_position = NULL;  // Статическая переменная!

char* my_strtok(char *str, const char *delim) {
    if (str != NULL) {
        last_position = str;
    }
    
    if (last_position == NULL) {
        return NULL;
    }
    
    // Пропустить начальные разделители
    last_position += strspn(last_position, delim);
    
    if (*last_position == '\0') {
        last_position = NULL;
        return NULL;
    }
    
    char *token_start = last_position;
    
    // Найти конец лексемы
    last_position += strcspn(last_position, delim);
    
    if (*last_position != '\0') {
        *last_position = '\0';  // МОДИФИКАЦИЯ СТРОКИ!
        last_position++;
    } else {
        last_position = NULL;
    }
    
    return token_start;
}

char str[] = "apple,:banana:cherry grape";  // КОПИЯ! Не литерал!

char *token = strtok(str, ",: ");
while (token != NULL) {
    printf("Token: %s\n", token);
    token = strtok(NULL, ",: ");
}

// Вывод:
// Token: apple
// Token: banana
// Token: cherry
// Token: grape
```

**Что происходит со строкой:**
```c
До strtok:
str: "apple,banana:cherry grape"

После 1-го вызова:
str: "apple\0banana:cherry grape"
      ^---- token указывает сюда
      
После 2-го вызова:
str: "apple\0banana\0cherry grape"
             ^---- token указывает сюда

После 3-го вызова:
str: "apple\0banana\0cherry\0grape"
                     ^---- token

После 4-го вызова:
str: "apple\0banana\0cherry\0grape\0"
                            ^---- token

После 5-го вызова:
token == NULL (лексемы кончились)
```