# Вопрос 16: Стеки и очереди на основе односвязного списка

## Абстрактные типы данных (ADT)
**Стек** и **очередь** — это **АТД** (Abstract Data Types), определяющие интерфейс операций, но не конкретную реализацию. Они могут быть реализованы через массивы, списки или другие структуры.
## СТЕК (Stack) — LIFO структура
### Концепция: Last In, First Out
**Метафора:** стопка тарелок — можем брать и класть только сверху.
### Базовые операции

| Операция         | Описание                                | Сложность |
| ---------------- | --------------------------------------- | --------- |
| `push(x)`        | Добавить элемент на вершину             | **O(1)**  |
| `pop()`          | Удалить и вернуть верхний элемент       | **O(1)**  |
| `top()`/`peek()` | Посмотреть верхний элемент без удаления | **O(1)**  |
| `is_empty()`     | Проверка на пустоту                     | **O(1)**  |
### Реализация на односвязном списке
**Ключевая идея:** вершина стека = голова списка (все операции с головой — O(1)!)
```c
typedef struct StackNode {
    int data;
    struct StackNode *next;
} StackNode;

typedef struct Stack {
    StackNode *top;    // указатель на вершину
    size_t size;       // для удобства, не обязательно
} Stack;

// Инициализация - O(1)
void stack_init(Stack *stack) {
    stack->top = NULL;
    stack->size = 0;
}

// Проверка на пустоту - O(1)
int stack_is_empty(Stack *stack) {
    return stack->top == NULL;
}

// Push - O(1)
int stack_push(Stack *stack, int value) {
    StackNode *new_node = (StackNode*)malloc(sizeof(StackNode));
    if (!new_node) {
        return 0;  // ошибка выделения памяти
    }
    
    new_node->data = value;
    new_node->next = stack->top;  // новый указывает на старую вершину
    stack->top = new_node;        // новый становится вершиной
    stack->size++;
    
    return 1;  // успех
}

// Pop - O(1)
int stack_pop(Stack *stack, int *value) {
    if (stack_is_empty(stack)) {
        return 0;  // стек пуст, ошибка
    }
    
    StackNode *temp = stack->top;
    *value = temp->data;           // сохраняем значение
    stack->top = temp->next;       // смещаем вершину
    free(temp);                    // освобождаем память
    stack->size--;
    
    return 1;  // успех
}

// Peek (top) - O(1)
int stack_peek(Stack *stack, int *value) {
    if (stack_is_empty(stack)) {
        return 0;
    }
    
    *value = stack->top->data;
    return 1;
}

// Освобождение памяти - O(n)
void stack_free(Stack *stack) {
    while (!stack_is_empty(stack)) {
        int dummy;
        stack_pop(stack, &dummy);
    }
}
```

### Применения стека
1. **Вызовы функций** — call stack в процессоре (frame pointer, return address)
2. **Обратная польская нотация** — вычисление постфиксных выражений
3. **Проверка балансировки** — скобки, теги HTML/XML
4. **Backtracking** — DFS, обход лабиринта
5. **Отмена операций** — Undo/Redo в редакторах
## ОЧЕРЕДЬ (Queue) — FIFO структура
### Концепция: First In, First Out
**Метафора:** очередь в магазине — кто первым пришел, тот первым обслуживается.
### Базовые операции

|Операция|Описание|Сложность|
|---|---|---|
|`enqueue(x)`|Добавить элемент в конец|**O(1)** с tail|
|`dequeue()`|Удалить и вернуть первый элемент|**O(1)**|
|`front()`/`peek()`|Посмотреть первый элемент|**O(1)**|
|`is_empty()`|Проверка на пустоту|**O(1)**|
### Реализация на односвязном списке
**Ключевая идея:** храним указатели на **голову** (front) и **хвост** (rear). Удаляем из головы, добавляем в хвост.
```c
typedef struct QueueNode {
    int data;
    struct QueueNode *next;
} QueueNode;

typedef struct Queue {
    QueueNode *front;  // голова - откуда удаляем
    QueueNode *rear;   // хвост - куда добавляем
    size_t size;
} Queue;

// Инициализация - O(1)
void queue_init(Queue *queue) {
    queue->front = NULL;
    queue->rear = NULL;
    queue->size = 0;
}

// Проверка на пустоту - O(1)
int queue_is_empty(Queue *queue) {
    return queue->front == NULL;
}

// Enqueue (добавление в конец) - O(1)
int queue_enqueue(Queue *queue, int value) {
    QueueNode *new_node = (QueueNode*)malloc(sizeof(QueueNode));
    if (!new_node) {
        return 0;  // ошибка
    }
    
    new_node->data = value;
    new_node->next = NULL;  // новый элемент всегда последний
    
    if (queue_is_empty(queue)) {
        // Первый элемент - он и front, и rear
        queue->front = new_node;
        queue->rear = new_node;
    } else {
        // Добавляем после текущего rear
        queue->rear->next = new_node;
        queue->rear = new_node;
    }
    
    queue->size++;
    return 1;
}

// Dequeue (удаление из начала) - O(1)
int queue_dequeue(Queue *queue, int *value) {
    if (queue_is_empty(queue)) {
        return 0;  // очередь пуста
    }
    
    QueueNode *temp = queue->front;
    *value = temp->data;
    queue->front = temp->next;
    
    // Критический момент: если удалили последний элемент
    if (queue->front == NULL) {
        queue->rear = NULL;  // очередь опустела
    }
    
    free(temp);
    queue->size--;
    return 1;
}

// Peek (front) - O(1)
int queue_peek(Queue *queue, int *value) {
    if (queue_is_empty(queue)) {
        return 0;
    }
    
    *value = queue->front->data;
    return 1;
}

// Освобождение памяти - O(n)
void queue_free(Queue *queue) {
    while (!queue_is_empty(queue)) {
        int dummy;
        queue_dequeue(queue, &dummy);
    }
}
```

### Критическая деталь
**Почему нужен указатель rear?**
Без `rear` добавление в конец требует O(n) — нужно пройти весь список до конца. С `rear` — O(1)!
### Применения очереди
1. **Планировщик задач** — CPU scheduling (Round Robin)
2. **BFS** — обход графа в ширину
3. **Буферы** — печать, обработка пакетов
4. **Асинхронная обработка** — message queues
## Сравнение стека и очереди
| Характеристика | Стек            | Очередь           |
| -------------- | --------------- | ----------------- |
| Принцип        | LIFO            | FIFO              |
| Указатели      | Только `top`    | `front` и `rear`  |
| Добавление     | В начало (top)  | В конец (rear)    |
| Удаление       | Из начала (top) | Из начала (front) |
| Все операции   | **O(1)**        | **O(1)**          |
| Память         | 1 указатель     | 2 указателя       ||

## АЛГОРИТМ ПРОВЕРКИ БАЛАНСА СКОБОК
### Постановка задачи
Проверить, корректно ли расставлены скобки в выражении. Типы скобок: `()`, `[]`, `{}`
**Правила:**
1. Каждая открывающая скобка должна иметь парную закрывающую
2. Скобки должны закрываться в правильном порядке
3. Закрывающая скобка должна соответствовать типу открывающей
### Алгоритм со стеком
**Идея:** используем стек для хранения открывающих скобок

**Логика:**
1. Читаем символы слева направо
2. Открывающая скобка `(`, `[`, `{` → `push` в стек
3. Закрывающая скобка `)`, `]`, `}` → проверяем вершину стека:
    - Стек пуст → **ошибка** (лишняя закрывающая)
    - Типы не совпадают → **ошибка**
    - Типы совпадают → `pop` из стека
4. В конце: стек должен быть пуст (иначе есть незакрытые)
### Временная сложность: **O(n)**
Каждый символ обрабатывается ровно один раз.
### Пространственная сложность: **O(n)**
В худшем случае все скобки открывающие: `(((((`
### Полная реализация на C
```c
#include <stdio.h>
#include <string.h>
#include <ctype.h>

// Используем стек из предыдущей реализации
// Модифицируем для хранения char вместо int

typedef struct StackNode {
    char data;
    struct StackNode *next;
} StackNode;

typedef struct Stack {
    StackNode *top;
} Stack;

void stack_init(Stack *stack) {
    stack->top = NULL;
}

int stack_is_empty(Stack *stack) {
    return stack->top == NULL;
}

int stack_push(Stack *stack, char value) {
    StackNode *new_node = (StackNode*)malloc(sizeof(StackNode));
    if (!new_node) return 0;
    
    new_node->data = value;
    new_node->next = stack->top;
    stack->top = new_node;
    return 1;
}

int stack_pop(Stack *stack, char *value) {
    if (stack_is_empty(stack)) return 0;
    
    StackNode *temp = stack->top;
    *value = temp->data;
    stack->top = temp->next;
    free(temp);
    return 1;
}

int stack_peek(Stack *stack, char *value) {
    if (stack_is_empty(stack)) return 0;
    *value = stack->top->data;
    return 1;
}

void stack_free(Stack *stack) {
    char dummy;
    while (!stack_is_empty(stack)) {
        stack_pop(stack, &dummy);
    }
}

// Вспомогательная функция: проверка на открывающую скобку
int is_opening(char c) {
    return c == '(' || c == '[' || c == '{';
}

// Вспомогательная функция: проверка на закрывающую скобку
int is_closing(char c) {
    return c == ')' || c == ']' || c == '}';
}

// Вспомогательная функция: проверка соответствия типов
int matches(char opening, char closing) {
    return (opening == '(' && closing == ')') ||
           (opening == '[' && closing == ']') ||
           (opening == '{' && closing == '}');
}

// ОСНОВНОЙ АЛГОРИТМ - O(n)
int check_balance(const char *expression) {
    Stack stack;
    stack_init(&stack);
    
    size_t len = strlen(expression);
    
    for (size_t i = 0; i < len; i++) {
        char current = expression[i];
        
        // Открывающая скобка - кладем в стек
        if (is_opening(current)) {
            if (!stack_push(&stack, current)) {
                // Ошибка выделения памяти
                stack_free(&stack);
                return -1;
            }
        }
        // Закрывающая скобка - проверяем
        else if (is_closing(current)) {
            // Стек пуст - лишняя закрывающая
            if (stack_is_empty(&stack)) {
                stack_free(&stack);
                return 0;  // НЕ сбалансировано
            }
            
            // Достаем последнюю открывающую
            char top;
            stack_pop(&stack, &top);
            
            // Проверяем соответствие типов
            if (!matches(top, current)) {
                stack_free(&stack);
                return 0;  // НЕ сбалансировано
            }
        }
        // Остальные символы (буквы, цифры) игнорируем
    }
    
    // В конце стек должен быть пуст
    int result = stack_is_empty(&stack);
    stack_free(&stack);
    
    return result;  // 1 = сбалансировано, 0 = нет
}
```
## Тонкости для преподавателей

### 1. **Почему стек идеален для скобок?**

Скобки подчиняются принципу **вложенности**: последняя открытая должна закрыться первой — это точно LIFO!

### 2. **Можно ли без стека?**

Да, через **счетчик** для одного типа скобок:

```c
int count = 0;
for (...) {
    if (c == '(') count++;
    if (c == ')') count--;
    if (count < 0) return 0;  // лишняя закрывающая
}
return count == 0;
```

Но для **нескольких типов** нужен стек!
### 3. **Реализация через массив vs список**
**Массив:**
- ✅ Лучше locality of reference (кэш-эффективность)
- ✅ Меньше overhead (нет указателя `next`)
- ❌ Ограниченный размер (или нужна реаллокация)

**Список:**
- ✅ Динамический размер
- ✅ Нет переаллокаций
- ❌ Хуже кэш-локальность
- ❌ Дополнительная память на указатели
### 4. **Стек и рекурсия**
Любая рекурсия = неявное использование стека вызовов! Проверку скобок можно написать рекурсивно, но явный стек эффективнее (избегаем overhead вызовов функций).
### 5. **Очередь на одном указателе?**
**Невозможно** с O(1) операциями! Либо enqueue за O(n), либо dequeue за O(n). Два указателя — необходимость.