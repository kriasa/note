## Три формы записи выражений

### Инфиксная нотация (Infix)

**Определение:** Оператор находится **между** операндами — привычная для человека форма.

**Примеры:**

- `a + b`
- `(a + b) * c`
- `a + b * c - d / e`

**Проблемы:**

1. **Приоритет операторов** — `2 + 3 * 4` ≠ `(2 + 3) * 4`
2. **Ассоциативность** — `a - b - c` = `(a - b) - c` (левая) vs `a ^ b ^ c` = `a ^ (b ^ c)` (правая)
3. **Требует скобок** для изменения порядка
4. **Сложность парсинга** — нужен анализ приоритетов

### Префиксная нотация (Prefix, Польская нотация)

**Определение:** Оператор находится **перед** операндами.

**Примеры:**

- `+ a b` → `a + b`
- `* + a b c` → `(a + b) * c`
- `+ a * b c` → `a + (b * c)`

**Автор:** Ян Лукасевич (Jan Łukasiewicz), польский логик, 1924 год.

**Преимущества:**

- ✅ Не требует скобок
- ✅ Не нужны правила приоритета
- ✅ Легко вычислять рекурсивно

### Постфиксная нотация (Postfix, Обратная польская нотация, RPN)

**Определение:** Оператор находится **после** операндов.

**Примеры:**

- `a b +` → `a + b`
- `a b + c *` → `(a + b) * c`
- `a b c * +` → `a + (b * c)`

**Применение:**

- Калькуляторы HP (до сих пор!)
- Виртуальные машины (стековые архитектуры)
- Компиляторы (промежуточное представление)

**Преимущества:**

- ✅ Не требует скобок
- ✅ Очень легко вычислять с помощью стека
- ✅ Естественна для стековых машин

## Таблица соответствий

|Инфиксная|Префиксная|Постфиксная|
|---|---|---|
|`a + b`|`+ a b`|`a b +`|
|`a + b * c`|`+ a * b c`|`a b c * +`|
|`(a + b) * c`|`* + a b c`|`a b + c *`|
|`a * b + c * d`|`+ * a b * c d`|`a b * c d * +`|
|`(a + b) * (c - d)`|`* + a b - c d`|`a b + c d - *`|

## АЛГОРИТМ: Инфикс → Постфикс (Алгоритм Дейкстры)

### Алгоритм сортировочной станции (Shunting Yard Algorithm)

**Автор:** Эдсгер Дейкстра (Edsger Dijkstra), 1961 год.

**Название:** "Shunting yard" — сортировочная станция (метафора железнодорожных путей).

### Основная идея

Используем **стек** для операторов и **выходную очередь** (или строку) для результата.

### Правила приоритета

```c
int precedence(char op) {
    switch (op) {
        case '+':
        case '-':
            return 1;
        case '*':
        case '/':
        case '%':
            return 2;
        case '^':
            return 3;  // возведение в степень
        default:
            return 0;
    }
}

// Ассоциативность: левая для большинства, правая для ^
int is_right_associative(char op) {
    return op == '^';
}
```

### Алгоритм пошагово

**Входные данные:** инфиксное выражение (строка)  
**Выходные данные:** постфиксное выражение (строка)

**Структуры:**

- Стек операторов
- Выходная строка (или массив)

**Правила:**

1. **Операнд** (число/переменная) → сразу в выход
2. **Открывающая скобка `(`** → в стек
3. **Закрывающая скобка `)`** → выталкиваем из стека в выход до `(`
4. **Оператор:**
    - Пока на вершине стека оператор с бо́льшим или равным приоритетом (с учетом ассоциативности) → выталкиваем его в выход
    - Кладем текущий оператор в стек
5. **Конец выражения** → выталкиваем все из стека в выход

### Полная реализация на C

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

// Стек для символов
typedef struct {
    char *data;
    int top;
    int capacity;
} Stack;

void stack_init(Stack *s, int capacity) {
    s->data = (char*)malloc(capacity);
    s->top = -1;
    s->capacity = capacity;
}

void stack_free(Stack *s) {
    free(s->data);
}

int stack_is_empty(Stack *s) {
    return s->top == -1;
}

void stack_push(Stack *s, char c) {
    if (s->top < s->capacity - 1) {
        s->data[++(s->top)] = c;
    }
}

char stack_pop(Stack *s) {
    if (!stack_is_empty(s)) {
        return s->data[(s->top)--];
    }
    return '\0';
}

char stack_peek(Stack *s) {
    if (!stack_is_empty(s)) {
        return s->data[s->top];
    }
    return '\0';
}

// Приоритет оператора
int precedence(char op) {
    switch (op) {
        case '+':
        case '-':
            return 1;
        case '*':
        case '/':
        case '%':
            return 2;
        case '^':
            return 3;
        default:
            return 0;
    }
}

// Правая ассоциативность (только для ^)
int is_right_associative(char op) {
    return op == '^';
}

// Проверка: является ли символ оператором
int is_operator(char c) {
    return c == '+' || c == '-' || c == '*' || 
           c == '/' || c == '%' || c == '^';
}

// АЛГОРИТМ ДЕЙКСТРЫ: Инфикс → Постфикс
// Временная сложность: O(n)
// Пространственная сложность: O(n)
void infix_to_postfix(const char *infix, char *postfix) {
    Stack operators;
    stack_init(&operators, strlen(infix));
    
    int out_idx = 0;
    int len = strlen(infix);
    
    for (int i = 0; i < len; i++) {
        char current = infix[i];
        
        // Пропускаем пробелы
        if (isspace(current)) {
            continue;
        }
        
        // 1. Операнд (цифра или буква) → в выход
        if (isalnum(current)) {
            postfix[out_idx++] = current;
            
            // Многозначные числа
            while (i + 1 < len && isalnum(infix[i + 1])) {
                postfix[out_idx++] = infix[++i];
            }
            
            postfix[out_idx++] = ' ';  // разделитель
        }
        // 2. Открывающая скобка → в стек
        else if (current == '(') {
            stack_push(&operators, current);
        }
        // 3. Закрывающая скобка → выталкиваем до '('
        else if (current == ')') {
            while (!stack_is_empty(&operators) && 
                   stack_peek(&operators) != '(') {
                postfix[out_idx++] = stack_pop(&operators);
                postfix[out_idx++] = ' ';
            }
            
            // Удаляем '(' из стека
            if (!stack_is_empty(&operators)) {
                stack_pop(&operators);
            }
        }
        // 4. Оператор
        else if (is_operator(current)) {
            // Выталкиваем операторы с >= приоритетом
            while (!stack_is_empty(&operators)) {
                char top = stack_peek(&operators);
                
                if (top == '(') {
                    break;
                }
                
                int top_prec = precedence(top);
                int curr_prec = precedence(current);
                
                // Условие выталкивания с учетом ассоциативности
                int should_pop;
                if (is_right_associative(current)) {
                    should_pop = (top_prec > curr_prec);
                } else {
                    should_pop = (top_prec >= curr_prec);
                }
                
                if (should_pop) {
                    postfix[out_idx++] = stack_pop(&operators);
                    postfix[out_idx++] = ' ';
                } else {
                    break;
                }
            }
            
            stack_push(&operators, current);
        }
    }
    
    // 5. Выталкиваем все оставшиеся операторы
    while (!stack_is_empty(&operators)) {
        postfix[out_idx++] = stack_pop(&operators);
        postfix[out_idx++] = ' ';
    }
    
    // Убираем последний пробел и завершаем строку
    if (out_idx > 0 && postfix[out_idx - 1] == ' ') {
        out_idx--;
    }
    postfix[out_idx] = '\0';
    
    stack_free(&operators);
}
```

### Пример работы алгоритма

**Вход:** `a + b * c`

|Шаг|Символ|Стек|Выход|
|---|---|---|---|
|1|`a`|`[]`|`a`|
|2|`+`|`[+]`|`a`|
|3|`b`|`[+]`|`a b`|
|4|`*`|`[+, *]`|`a b`|
|5|`c`|`[+, *]`|`a b c`|
|6|конец|`[]`|`a b c * +`|

**Вход:** `(a + b) * c`

|Шаг|Символ|Стек|Выход|
|---|---|---|---|
|1|`(`|`[(]`|``|
|2|`a`|`[(]`|`a`|
|3|`+`|`[(, +]`|`a`|
|4|`b`|`[(, +]`|`a b`|
|5|`)`|`[]`|`a b +`|
|6|`*`|`[*]`|`a b +`|
|7|`c`|`[*]`|`a b + c`|
|8|конец|`[]`|`a b + c *`|

### Временная сложность: **O(n)**

Каждый символ обрабатывается не более двух раз (один раз при чтении, один раз при выталкивании из стека).

## АЛГОРИТМ: Вычисление постфиксного выражения

### Основная идея

Постфиксная форма **идеально** подходит для стека:

1. Читаем слева направо
2. Операнд → в стек
3. Оператор → берем два операнда из стека, применяем оператор, результат в стек
4. В конце в стеке остается один элемент — ответ

### Временная сложность: **O(n)**

### Реализация на C

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <math.h>

// Стек для чисел
typedef struct {
    double *data;
    int top;
    int capacity;
} NumStack;

void numstack_init(NumStack *s, int capacity) {
    s->data = (double*)malloc(capacity * sizeof(double));
    s->top = -1;
    s->capacity = capacity;
}

void numstack_free(NumStack *s) {
    free(s->data);
}

int numstack_is_empty(NumStack *s) {
    return s->top == -1;
}

void numstack_push(NumStack *s, double value) {
    if (s->top < s->capacity - 1) {
        s->data[++(s->top)] = value;
    }
}

double numstack_pop(NumStack *s) {
    if (!numstack_is_empty(s)) {
        return s->data[(s->top)--];
    }
    return 0.0;
}

// Применение оператора
double apply_operator(char op, double operand1, double operand2) {
    switch (op) {
        case '+': return operand1 + operand2;
        case '-': return operand1 - operand2;
        case '*': return operand1 * operand2;
        case '/': 
            if (operand2 == 0) {
                fprintf(stderr, "Error: Division by zero\n");
                return 0.0;
            }
            return operand1 / operand2;
        case '%': 
            return fmod(operand1, operand2);
        case '^': 
            return pow(operand1, operand2);
        default:
            return 0.0;
    }
}

// ВЫЧИСЛЕНИЕ ПОСТФИКСНОГО ВЫРАЖЕНИЯ
// Временная сложность: O(n)
double evaluate_postfix(const char *postfix) {
    NumStack stack;
    numstack_init(&stack, strlen(postfix));
    
    int len = strlen(postfix);
    
    for (int i = 0; i < len; i++) {
        char current = postfix[i];
        
        // Пропускаем пробелы
        if (isspace(current)) {
            continue;
        }
        
        // Если цифра - читаем число
        if (isdigit(current)) {
            double num = 0;
            
            // Парсим многозначное число
            while (i < len && isdigit(postfix[i])) {
                num = num * 10 + (postfix[i] - '0');
                i++;
            }
            i--;  // откатываем, т.к. for сделает i++
            
            numstack_push(&stack, num);
        }
        // Если оператор - применяем
        else if (is_operator(current)) {
            // ВАЖНО: порядок операндов!
            // Первым из стека выходит ВТОРОЙ операнд
            double operand2 = numstack_pop(&stack);
            double operand1 = numstack_pop(&stack);
            
            double result = apply_operator(current, operand1, operand2);
            numstack_push(&stack, result);
        }
    }
    
    // Результат - единственный элемент в стеке
    double result = numstack_pop(&stack);
    numstack_free(&stack);
    
    return result;
}
```

### Критическая деталь: порядок операндов

```c
double operand2 = numstack_pop(&stack);  // ВТОРОЙ операнд
double operand1 = numstack_pop(&stack);  // ПЕРВЫЙ операнд
double result = operand1 - operand2;     // НЕ operand2 - operand1!
```

Для некоммутативных операций (`-`, `/`, `^`) порядок критичен!

### Пример работы

**Вход:** `5 3 + 2 *`  
**Инфиксный эквивалент:** `(5 + 3) * 2`

|Шаг|Токен|Стек|Действие|
|---|---|---|---|
|1|`5`|`[5]`|push 5|
|2|`3`|`[5, 3]`|push 3|
|3|`+`|`[8]`|pop 3,5 → push 5+3=8|
|4|`2`|`[8, 2]`|push 2|
|5|`*`|`[16]`|pop 2,8 → push 8*2=16|

**Результат:** `16`

## АЛГОРИТМ: Вычисление инфиксного выражения напрямую

### Метод двух стеков (Dijkstra's Two-Stack Algorithm)

**Идея:** используем два стека одновременно:

1. **Стек операндов** — для чисел
2. **Стек операторов** — для операторов
Вычисляем "на лету", не создавая промежуточного постфиксного представления.
### Алгоритм

1. **Операнд** → в стек операндов
2. **Открывающая скобка** → в стек операторов
3. **Оператор:**
    - Пока на вершине оператор с бо́льшим/равным приоритетом → выполняем его
    - Кладем текущий оператор в стек
4. **Закрывающая скобка:**
    - Выполняем операторы до открывающей скобки
    - Удаляем открывающую скобку
5. **Конец** → выполняем все оставшиеся операторы
### Реализация на C

```c
// Выполнить верхний оператор из стека
void execute_operator(NumStack *operands, Stack *operators) {
    if (stack_is_empty(operators)) return;
    
    char op = stack_pop(operators);
    
    if (numstack_is_empty(operands)) return;
    double operand2 = numstack_pop(operands);
    
    if (numstack_is_empty(operands)) return;
    double operand1 = numstack_pop(operands);
    
    double result = apply_operator(op, operand1, operand2);
    numstack_push(operands, result);
}

// ПРЯМОЕ ВЫЧИСЛЕНИЕ ИНФИКСНОГО ВЫРАЖЕНИЯ
// Временная сложность: O(n)
double evaluate_infix(const char *infix) {
    NumStack operands;
    Stack operators;
    
    int len = strlen(infix);
    numstack_init(&operands, len);
    stack_init(&operators, len);
    
    for (int i = 0; i < len; i++) {
        char current = infix[i];
        
        // Пропускаем пробелы
        if (isspace(current)) {
            continue;
        }
        
        // 1. Операнд
        if (isdigit(current)) {
            double num = 0;
            while (i < len && isdigit(infix[i])) {
                num = num * 10 + (infix[i] - '0');
                i++;
            }
            i--;
            numstack_push(&operands, num);
        }
        // 2. Открывающая скобка
        else if (current == '(') {
            stack_push(&operators, current);
        }
        // 3. Закрывающая скобка
        else if (current == ')') {
            // Выполняем до '('
            while (!stack_is_empty(&operators) && 
                   stack_peek(&operators) != '(') {
                execute_operator(&operands, &operators);
            }
            // Удаляем '('
            if (!stack_is_empty(&operators)) {
                stack_pop(&operators);
            }
        }
        // 4. Оператор
        else if (is_operator(current)) {
            // Выполняем операторы с >= приоритетом
            while (!stack_is_empty(&operators)) {
                char top = stack_peek(&operators);
                
                if (top == '(') {
                    break;
                }
                
                int top_prec = precedence(top);
                int curr_prec = precedence(current);
                
                int should_execute;
                if (is_right_associative(current)) {
                    should_execute = (top_prec > curr_prec);
                } else {
                    should_execute = (top_prec >= curr_prec);
                }
                
                if (should_execute) {
                    execute_operator(&operands, &operators);
                } else {
                    break;
                }
            }
            
            stack_push(&operators, current);
        }
    }
    
    // 5. Выполняем оставшиеся операторы
    while (!stack_is_empty(&operators)) {
        execute_operator(&operands, &operators);
    }
    
    double result = numstack_pop(&operands);
    
    numstack_free(&operands);
    stack_free(&operators);
    
    return result;
}
```

### Пример работы

**Вход:** `3 + 5 * 2`

| Шаг | Токен | Операнды    | Операторы | Действие                |
| --- | ----- | ----------- | --------- | ----------------------- |
| 1   | `3`   | `[3]`       | `[]`      | push 3                  |
| 2   | `+`   | `[3]`       | `[+]`     | push +                  |
| 3   | `5`   | `[3, 5]`    | `[+]`     | push 5                  |
| 4   | `*`   | `[3, 5]`    | `[+, *]`  | push * (выше приоритет) |
| 5   | `2`   | `[3, 5, 2]` | `[+, *]`  | push 2                  |
| 6   | конец | `[3, 10]`   | `[+]`     | выполнить * → 5\*2=10   |
| 7   | конец | `[13]`      | `[]`      | выполнить + → 3+10=13   |
**Результат:** `13`

## Сравнение методов
| Метод                              | Преобразование | Вычисление | Итого    | Память      |
| ---------------------------------- | -------------- | ---------- | -------- | ----------- |
| **Инфикс → Постфикс → Вычисление** | O(n)           | O(n)       | **O(n)** | O(n) + O(n) |
| **Прямое вычисление инфикса**      | —              | O(n)       | **O(n)** | O(n)        ||
Оба метода линейны, но прямое вычисление экономит память и проходы.

## Тонкости для преподавателей
### 1. **Почему постфикс проще вычислять?**
В постфиксной форме **нет неопределенности**: когда встречаем оператор, операнды уже в стеке. В инфиксе нужно анализировать приоритеты.
### 2. **Унарный минус**
Сложность! `-5 + 3` vs `5 + -3`
**Решение:** различаем унарный и бинарный `-`:
- Унарный: в начале, после `(`, после оператора
- Можно заменить на `(0 - x)`
```c
// Проверка на унарный минус
int is_unary_minus(const char *expr, int pos) {
    if (expr[pos] != '-') return 0;
    if (pos == 0) return 1;
    
    char prev = expr[pos - 1];
    return prev == '(' || is_operator(prev);
}
```

### 3. **Ассоциативность возведения в степень**
`2 ^ 3 ^ 2` = `2 ^ (3 ^ 2)` = `2 ^ 9` = `512`  
НЕ `(2 ^ 3) ^ 2` = `8 ^ 2` = `64`

Возведение в степень — **правоассоциативно**!
### 4. **Применение в компиляторах**
Постфиксная форма = **трехадресный код** (Three-Address Code):
```
t1 = b * c
t2 = a + t1
```
Это промежуточное представление в компиляторах (например, в LLVM IR).
### 5. **Стековые машины**
Java Virtual Machine, Python VM, Forth — все используют стековую архитектуру:
```
PUSH 5
PUSH 3
ADD      // pop два значения, push сумму
PUSH 2
MUL      // результат: 16
```
Это по сути выполнение постфиксного выражения!
### 6. **Обработка ошибок**
**Некорректный постфикс:**
- Слишком много операндов → в конце стека > 1 элемента
- Слишком мало операндов → попытка pop из пустого стека

```c
double evaluate_postfix_safe(const char *postfix, int *error) {
    // ... вычисление ...
    
    if (stack.top != 0) {
        *error = 1;  // лишние операнды
        return 0.0;
    }
    
    *error = 0;
    return result;
}
```

## Полный пример с тестами

```c
int main() {
    // Тест 1: Инфикс → Постфикс
    char postfix[256];
    
    infix_to_postfix("3 + 5 * 2", postfix);
    printf("Инфикс: 3 + 5 * 2\n");
    printf("Постфикс: %s\n", postfix);
    printf("Результат: %.2f\n\n", evaluate_postfix(postfix));
    
    // Тест 2: Со скобками
    infix_to_postfix("(3 + 5) * 2", postfix);
    printf("Инфикс: (3 + 5) * 2\n");
    printf("Постфикс: %s\n", postfix);
    printf("Результат: %.2f\n\n", evaluate_postfix(postfix));
    
    // Тест 3: Прямое вычисление
    printf("Прямое вычисление '3 + 5 * 2': %.2f\n", 
           evaluate_infix("3 + 5 * 2"));
    printf("Прямое вычисление '(3 + 5) * 2': %.2f\n", 
           evaluate_infix("(3 + 5) * 2"));
    
    // Тест 4: Сложное выражение
    const char *complex = "10 + 2 * 6 / 4 - 1";
    infix_to_postfix(complex, postfix);
    printf("\nИнфикс: %s\n", complex);
    printf("Постфикс: %s\n", postfix);
    printf("Результат постфикс: %.2f\n", evaluate_postfix(postfix));
    printf("Результат прямой: %.2f\n", evaluate_infix(complex));
    
    return 0;
}
```