##### Ключевые моменты:
- В C только передача по значению
- Указатели эмулируют передачу по ссылке
- static меняет время жизни (для локальных) или связывание (для глобальных)
- Локальные переменные НЕ инициализируются автоматически
- Глобальные переменные инициализируются нулями
- Массивы деградируют до указателей при передаче

# 1. Функции — основные понятия

**Функция** — это именованный блок кода, который выполняет определенную задачу и может быть вызван из других частей программы. Функция является основной единицей модульности в C.

**Сигнатура функции** включает:
- Тип возвращаемого значения
- Имя функции
- Список параметров с их типами

**Объявление (declaration)** vs **Определение (definition)**:
- Объявление (прототип) сообщает компилятору о существовании функции:`int calculate(int a, double b);`
- Определение содержит тело функции с реализацией

# 2. Способы передачи аргументов в функции
### 2.1. Передача по значению (pass by value)
**В C существует ТОЛЬКО передача по значению.** Это фундаментальный принцип языка.
При вызове функции:
1. Создаются копии значений аргументов
2. Копии помещаются в стек
3. Функция работает с копиями, а не с оригинальными переменными
4. Изменения параметров внутри функции НЕ влияют на исходные переменные
### 2.2. Эмуляция передачи по ссылке через указатели
Чтобы изменить значение переменной извне, передаём **указатель по значению**:
**Важно**: мы всё равно передаём по значению, но значением является адрес. Копируется указатель (адрес), но данные по этому адресу остаются теми же.

### 2.3. Передача массивов
Массивы в C **деградируют до указателей** при передаче в функцию
Поэтому размер массива передаётся отдельным параметром.

# 3. Возврат значений из функции
### 3.1. Через возвращаемое значение (return)
**Ограничения:**
- Можно вернуть только **одно значение**
- Нельзя возвращать адрес локальной переменной (она уничтожается при выходе из функции)
```c
int* dangerous() {
    int x = 42;
    return &x;  // ОШИБКА! x уничтожится, указатель станет невалидным
}
```

**Возврат структур:**
```c
typedef struct {
    int x, y;
} Point;

Point create_point(int x, int y) {
    Point p = {x, y};
    return p;  // структура копируется
}
```

### 3.2. Через параметры функции (output parameters)
Используется для возврата **нескольких значений** или больших структур данных:
**Преимущества:**
- Возврат нескольких значений
- Избежание копирования больших структур
- Возможность сигнализировать об ошибке через return, а результат передавать через параметры
# 4. Глобальные и локальные переменные
### 4.1. Локальные переменные (automatic variables)
**Локальные переменные:**
- Объявляются внутри функции или блока `{}`
- Размещаются в **стеке**
- Создаются при входе в блок, уничтожаются при выходе
- Не инициализируются автоматически (содержат мусор)
```c
void func() {
    int x;  // локальная переменная, содержит неопределённое значение
    int y = 10;  // явная инициализация
}
```
**Время жизни** — от момента объявления до конца блока.
### 4.2. Глобальные переменные
**Глобальные переменные:**
- Объявляются вне всех функций
- Размещаются в **сегменте данных** (data segment)
- *Инициализируются нулями* по умолчанию
- Существуют всё время работы программы
- Видны во всех файлах (если не static)

```c
int global = 100;  // глобальная переменная

void func() {
    global++;  // доступна везде
}
```

**Недостатки глобальных переменных:**
- Усложняют отладку
- Создают скрытые зависимости между функциями
- Проблемы с многопоточностью
- Затрудняют повторное использование кода
# 5. Область видимости переменных (scope)
**Область видимости** — часть программы, где переменная доступна по имени.
### 5.1. Блочная область видимости
```c
int main() {
    int x = 1;
    {
        int x = 2;  // это другая переменная, скрывает внешнюю
        printf("%d\n", x);  // 2
    }
    printf("%d\n", x);  // 1
}
```
Внутренняя переменная **затеняет** (shadows) внешнюю.
### 5.2. Область видимости файла (file scope)
Переменные, объявленные вне функций, имеют область видимости файла:
```c
int file_var;  // видна во всём файле, начиная с точки объявления

void func1() {
    file_var = 10;  // OK
}
```
### 5.3. Правило: переменная видна от точки объявления до конца блока
```c
void example() {
    // x здесь ещё не существует
    int x = 5;
    // x существует отсюда
    {
        int y = x;  // x видна
        // y существует только в этом блоке
    }
    // y здесь больше не существует
}
```

# 6. Модификатор static
Модификатор `static` имеет **разное значение** в зависимости от контекста:
### 6.1. static для локальных переменных
**static локальная переменная:**
- Размещается в **сегменте данных**, а не в стеке
- Инициализируется **один раз** при первом вызове функции
- **Сохраняет значение** между вызовами функции
- Область видимости остаётся локальной
```c
void counter() {
    static int count = 0;  // инициализируется один раз
    count++;
    printf("%d\n", count);
}

int main() {
    counter();  // 1
    counter();  // 2
    counter();  // 3
}
```
**Без static:**
```c
void counter() {
    int count = 0;  // создаётся заново каждый раз
    count++;
    printf("%d\n", count);  // всегда 1
}
```

### 6.2. static для глобальных переменных и функций
**static глобальная переменная/функция:**
- Ограничивает область видимости **текущим файлом** (единицей трансляции)
- Реализует **внутреннее связывание** (internal linkage)
- Недоступна из других файлов через `extern`
```c
// file1.c
static int secret = 42;  // видна только в file1.c

static void helper() {  // видна только в file1.c
    // ...
}
```

```c
// file2.c
extern int secret;  // ОШИБКА компоновки! secret имеет internal linkage
```

**Без static (external linkage):**
```c
// file1.c
int shared = 100;  // видна во всех файлах

// file2.c
extern int shared;  // OK, получаем доступ
```

### 6.3. Практическое применение static
**1. Инкапсуляция в C:**
```c
// module.c
static int internal_state;  // приватное состояние модуля

static void internal_helper() {  // приватная функция
    // ...
}

void public_api() {  // публичная функция (не static)
    internal_helper();
}
```

**2. Избежание конфликтов имён:**
```c
// file1.c
static void init() { /* ... */ }

// file2.c
static void init() { /* ... */ }  // OK, разные функции
```

**3. Счётчики и кеши:**
```c
int get_unique_id() {
    static int id = 0;
    return id++;
}
```

## Дополнительные детали для демонстрации глубины знаний

### Calling conventions

**Стандартная calling convention в C (cdecl на x86):**

1. Аргументы заталкиваются в стек справа налево
2. Вызывающая функция (caller) очищает стек после вызова
3. Возвращаемое значение передаётся через регистр (EAX/RAX на x86/x64)

### Register keyword (устаревший)
```c
void func(register int x) {  // подсказка компилятору хранить в регистре
    // современные компиляторы игнорируют это
}
```

### inline функции
```c
inline int max(int a, int b) {  // подсказка для inline-подстановки
    return a > b ? a : b;
}
```
Компилятор может встроить код функции непосредственно в место вызова, избегая overhead вызова функции.
### Рекурсия и стек
Каждый вызов функции создаёт новый **stack frame** (активационная запись), содержащий:
- Локальные переменные
- Параметры функции
- Адрес возврата
- Сохранённые регистры

При глубокой рекурсии возможно **переполнение стека** (stack overflow).

---

**Ключевые моменты для зачёта:**

- В C только передача по значению
- Указатели эмулируют передачу по ссылке
- static меняет время жизни (для локальных) или связывание (для глобальных)
- Локальные переменные НЕ инициализируются автоматически
- Глобальные переменные инициализируются нулями
- Массивы деградируют до указателей при передаче