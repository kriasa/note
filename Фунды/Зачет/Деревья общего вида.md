# 1. Определение дерева общего вида

**Дерево общего вида (general tree)** — это иерархическая структура данных, состоящая из узлов, связанных отношением "родитель-потомок", где каждый узел может иметь **произвольное число потомков** (в отличие от бинарного дерева, где максимум 2 потомка).

**Формальное определение:**

- Дерево состоит из множества узлов и множества рёбер
- Существует ровно один узел без родителя — **корень** (root)
- Каждый узел, кроме корня, имеет ровно одного родителя
- Из корня существует путь к любому узлу дерева
- Отсутствуют циклы (ацикличность)

**Терминология:**

- **Корень** — узел без родителя
- **Лист** (leaf) — узел без потомков
- **Внутренний узел** — узел, имеющий хотя бы одного потомка
- **Степень узла** — количество его потомков
- **Степень дерева** — максимальная степень среди всех узлов
- **Высота дерева** — максимальная длина пути от корня до листа
- **Уровень узла** — длина пути от корня до этого узла (корень на уровне 0)
- **Поддерево** — дерево, образованное узлом и всеми его потомками

# 2. Представления дерева общего вида в памяти

### 2.1. Представление "Левый потомок — правый брат" (Left-Child Right-Sibling)

Это **самое эффективное и распространённое** представление дерева общего вида.

**Идея:** каждый узел хранит только два указателя:

- Указатель на первого (левого) потомка
- Указатель на следующего брата (правого соседа среди детей одного родителя)

**Структура на языке C:**

```c
typedef struct TreeNode {
    int data;                      // Данные узла (может быть любой тип)
    struct TreeNode *first_child;  // Указатель на первого потомка
    struct TreeNode *next_sibling; // Указатель на следующего брата
} TreeNode;
```

**Преимущества:**

- Фиксированный размер структуры (два указателя независимо от числа потомков)
- Эффективное использование памяти: O(n) для n узлов
- Естественная навигация по дереву

**Визуализация:**

```
Исходное дерево:
        A
      / | \
     B  C  D
    /|  |
   E F  G

Представление left-child right-sibling:
A → first_child → B
                  ↓ next_sibling
                  C
                  ↓ next_sibling
                  D

B → first_child → E
                  ↓ next_sibling
                  F

C → first_child → G
```

### 2.2. Массив указателей на потомков

```c
typedef struct TreeNode {
    int data;
    struct TreeNode **children;  // Динамический массив указателей
    int children_count;          // Текущее число потомков
    int children_capacity;       // Выделенная ёмкость массива
} TreeNode;
```

**Особенности:**

- Требует динамического перераспределения памяти при добавлении потомков
- Прямой доступ к i-му потомку за O(1)
- Большие накладные расходы памяти при малом числе потомков

### 2.3. Массив указателей фиксированного размера

```c
#define MAX_CHILDREN 10

typedef struct TreeNode {
    int data;
    struct TreeNode *children[MAX_CHILDREN];
    int children_count;
} TreeNode;
```

**Недостатки:**

- Ограничение на максимальное число потомков
- Неэффективное использование памяти (если узлы имеют мало потомков)

# 3. Основные операции над деревом общего вида

### 3.1. Создание узла

```c
TreeNode* create_node(int data) {
    TreeNode *node = (TreeNode*)malloc(sizeof(TreeNode));
    if (!node) return NULL;
    
    node->data = data;
    node->first_child = NULL;
    node->next_sibling = NULL;
    
    return node;
}
```

**Сложность:** O(1)

### 3.2. Добавление потомка (left-child right-sibling)

```c
void add_child(TreeNode *parent, TreeNode *child) {
    if (!parent || !child) return;
    
    // Если нет потомков, child становится первым
    if (parent->first_child == NULL) {
        parent->first_child = child;
    } else {
        // Находим последнего брата и добавляем child
        TreeNode *sibling = parent->first_child;
        while (sibling->next_sibling != NULL) {
            sibling = sibling->next_sibling;
        }
        sibling->next_sibling = child;
    }
    child->next_sibling = NULL;  // child — последний брат
}
```

**Сложность:** O(k), где k — число уже существующих потомков

**Оптимизация:** можно хранить указатель на последнего потомка для добавления за O(1).

### 3.3. Обходы дерева

#### а) Прямой обход (Preorder) — КЛП (Корень-Левый-Правый)

Сначала обрабатываем узел, затем рекурсивно все его поддеревья:

```c
void preorder_traversal(TreeNode *node) {
    if (node == NULL) return;
    
    printf("%d ", node->data);  // Обработка текущего узла
    
    // Обход всех потомков
    TreeNode *child = node->first_child;
    while (child != NULL) {
        preorder_traversal(child);
        child = child->next_sibling;
    }
}
```

**Применение:** копирование структуры дерева, сериализация

#### б) Обратный обход (Postorder) — ЛПК (Левый-Правый-Корень)

Сначала рекурсивно обрабатываем все поддеревья, затем сам узел:

```c
void postorder_traversal(TreeNode *node) {
    if (node == NULL) return;
    
    // Сначала обход всех потомков
    TreeNode *child = node->first_child;
    while (child != NULL) {
        postorder_traversal(child);
        child = child->next_sibling;
    }
    
    printf("%d ", node->data);  // Обработка текущего узла
}
```

**Применение:** удаление дерева, вычисление размера поддерева, постфиксная запись выражений

#### в) Поуровневый обход (Level-order / BFS)

Обход слева направо по уровням, используя очередь:

```c
void level_order_traversal(TreeNode *root) {
    if (root == NULL) return;
    
    // Простая реализация очереди через массив (можно использовать список)
    TreeNode *queue[1000];
    int front = 0, rear = 0;
    
    queue[rear++] = root;
    
    while (front < rear) {
        TreeNode *current = queue[front++];
        printf("%d ", current->data);
        
        // Добавляем всех потомков в очередь
        TreeNode *child = current->first_child;
        while (child != NULL) {
            queue[rear++] = child;
            child = child->next_sibling;
        }
    }
}
```

**Сложность всех обходов:** O(n), где n — число узлов

### 3.4. Поиск узла

```c
TreeNode* find_node(TreeNode *root, int value) {
    if (root == NULL) return NULL;
    
    if (root->data == value) return root;
    
    // Рекурсивный поиск в каждом поддереве
    TreeNode *child = root->first_child;
    while (child != NULL) {
        TreeNode *found = find_node(child, value);
        if (found != NULL) return found;
        child = child->next_sibling;
    }
    
    return NULL;
}
```

**Сложность:** O(n) в худшем случае

### 3.5. Вычисление высоты дерева

```c
int tree_height(TreeNode *node) {
    if (node == NULL) return -1;  // Высота пустого дерева = -1
    
    int max_height = -1;
    
    // Находим максимальную высоту среди всех поддеревьев
    TreeNode *child = node->first_child;
    while (child != NULL) {
        int child_height = tree_height(child);
        if (child_height > max_height) {
            max_height = child_height;
        }
        child = child->next_sibling;
    }
    
    return max_height + 1;
}
```

**Сложность:** O(n)

### 3.6. Подсчёт числа узлов

```c
int count_nodes(TreeNode *node) {
    if (node == NULL) return 0;
    
    int count = 1;  // Текущий узел
    
    TreeNode *child = node->first_child;
    while (child != NULL) {
        count += count_nodes(child);
        child = child->next_sibling;
    }
    
    return count;
}
```

**Сложность:** O(n)

### 3.7. Удаление дерева (освобождение памяти)

**Критически важно:** использовать постфиксный обход, чтобы не обращаться к освобождённой памяти.

```c
void delete_tree(TreeNode *node) {
    if (node == NULL) return;
    
    // Сначала удаляем всех потомков
    TreeNode *child = node->first_child;
    while (child != NULL) {
        TreeNode *next = child->next_sibling;  // Сохраняем указатель
        delete_tree(child);
        child = next;
    }
    
    // Теперь освобождаем сам узел
    free(node);
}
```

**Сложность:** O(n)

### 3.8. Удаление конкретного узла

Сложная операция, требующая реструктуризации:

```c
void remove_child(TreeNode *parent, TreeNode *child_to_remove) {
    if (!parent || !child_to_remove) return;
    
    TreeNode *child = parent->first_child;
    TreeNode *prev = NULL;
    
    // Поиск узла среди потомков
    while (child != NULL && child != child_to_remove) {
        prev = child;
        child = child->next_sibling;
    }
    
    if (child == NULL) return;  // Узел не найден
    
    // Удаление первого потомка
    if (prev == NULL) {
        parent->first_child = child->next_sibling;
    } else {
        prev->next_sibling = child->next_sibling;
    }
    
    // Можно переместить потомков удаляемого узла к родителю
    // или удалить всё поддерево
    delete_tree(child);
}
```

# 4. Подковыристые детали для преподавателей

### 4.1. Связь с бинарным деревом

**Важное наблюдение:** представление left-child right-sibling **изоморфно бинарному дереву**!

- first_child соответствует левому потомку
- next_sibling соответствует правому потомку

Это позволяет использовать алгоритмы для бинарных деревьев на деревьях общего вида.

### 4.2. Сравнение памяти

Для дерева из n узлов со средней степенью d:

- Left-child right-sibling: 2n указателей (всегда)
- Массив указателей: ~n×d указателей в среднем
- При d > 2 первое представление эффективнее

### 4.3. Указатель на родителя

Иногда добавляют третий указатель:

```c
typedef struct TreeNode {
    int data;
    struct TreeNode *first_child;
    struct TreeNode *next_sibling;
    struct TreeNode *parent;  // Для восходящей навигации
} TreeNode;
```

**Применение:** поиск общего предка, вычисление уровня узла без рекурсии

### 4.4. NULL vs дерево из одного узла

- Пустое дерево: root == NULL
- Дерево из одного узла: root != NULL, root->first_child == NULL
- Это разные концепции!

### 4.5. Инварианты

Для корректного left-child right-sibling дерева:

- У корня next_sibling всегда NULL (нет братьев)
- Последний брат в цепочке имеет next_sibling == NULL
- Если first_child == NULL, узел является листом

---

**Итого:** дерево общего вида — фундаментальная структура с произвольным ветвлением. Представление left-child right-sibling оптимально по памяти и элегантно сводит задачу к бинарным деревьям. Все базовые операции имеют линейную сложность O(n), что обусловлено необходимостью обхода всех узлов.