# Вопрос 13: Директивы препроцессора в языке C (компактная версия)
## Препроцессор: концептуальная основа
**Препроцессор** — это отдельная фаза компиляции, работающая **ДО** собственно компилятора. Это **текстовый процессор**, выполняющий чисто синтаксическую обработку исходного кода на уровне лексем (токенов), без понимания семантики языка C.
### Критическое понимание:
Препроцессор **не знает о типах данных, области видимости, синтаксисе C** — он работает с текстом как с потоком токенов. Это мощный, но **опасный** инструмент: ошибки препроцессора могут привести к трудноотлаживаемым проблемам.

---
## Порядок работы препроцессора
### Фазы трансляции (согласно стандарту C)

**Фаза 1-2**: Физическая обработка файла
- Преобразование исходного файла в поток символов
- Обработка trigraph-последовательностей (устаревшие, `??=` → `#`)
- Склейка строк, заканчивающихся на `\` (line splicing) — позволяет разбивать длинные макросы на несколько физических строк

**Фаза 3**: Токенизация и обработка комментариев
- Исходный текст разбивается на **токены** (ключевые слова, идентификаторы, литералы, операторы)
- Комментарии `/* */` и `//` заменяются на пробелы

**Фаза 4**: Выполнение директив препроцессора
- Обработка всех директив `#include`, `#define`, `#if`, `#ifdef` и т.д.
- Раскрытие макросов
- Условная компиляция

**Фаза 5-9**: Компиляция, линковка
- Препроцессированный текст передается компилятору
- Компиляция в объектный код
- Линковка

### Просмотр результата препроцессирования
Команды `gcc -E source.c -o source.i` или `clang -E source.c -o source.i` позволяют получить файл `.i` с результатом препроцессирования — незаменимо для отладки макросов!

---

## Директива `#include`
### Синтаксис и семантика
`#include <filename>` — для системных заголовочных файлов `#include "filename"` — для пользовательских заголовочных файлов
**Механизм работы**: препроцессор **буквально заменяет** строку `#include` на **полное содержимое** указанного файла.
### Различия между <> и ""

**Угловые скобки `<>`**:
- Поиск в **системных директориях** (`/usr/include`, `/usr/local/include` на Unix)
- Не ищет в текущей директории
- Используется для стандартной библиотеки и системных заголовков

**Кавычки `""`**:
- Поиск **сначала в текущей директории** (или директории, указанной путем)
- Если не найден, продолжает поиск как `<>` (в системных путях)
- Используется для собственных заголовочных файлов проекта

### Управление путями поиска
Флаг компиляции `-I/path/to/headers` добавляет путь для поиска заголовочных файлов.

### Проблема двойного включения (include guards)
**Проблема**: если заголовочный файл включается несколько раз (напрямую или через другие заголовки), происходит множественное определение структур, функций и т.д. — ошибка компиляции.

**Решение 1: Include Guards** (традиционный способ): Использование директив `#ifndef`, `#define`, `#endif` для создания защиты от повторного включения. При первом включении макрос не определен, файл обрабатывается и макрос определяется. При повторном включении макрос уже определен, содержимое пропускается.

**Решение 2: `#pragma once`** (современный, не стандартный, но широко поддерживается): Однострочная директива, которая указывает компилятору, что файл должен быть включен только один раз.

**Преимущества `#pragma once`**:
- Короче и понятнее
- Нет риска коллизии имен макросов
- Может быть быстрее (компилятор не открывает файл повторно)

**Недостаток**: не входит в стандарт C (но поддерживается GCC, Clang, MSVC)

---

## Директива `#define`

### Объектно-подобные макросы (object-like macros)
Простая текстовая подстановка константных значений. Определяются без параметров.
**Важно**: макросы определяются **без точки с запятой** — они не являются выражениями C, а представляют собой текстовую подстановку.
### Функционально-подобные макросы (function-like macros)
Макросы с параметрами, имитирующие функции. **Критически важно**: НЕТ пробела между именем макроса и открывающей скобкой, иначе скобка будет частью замещающего текста.
### Опасности макросов
**Проблема 1: Отсутствие скобок** Без скобок вокруг аргументов и выражения возникают проблемы приоритета операторов. При раскрытии макроса операторы из контекста вызова могут "вклиниться" в выражение макроса.

**Правило**: **ВСЕГДА заключайте в скобки**:
1. Каждый аргумент макроса
2. Всё выражение макроса

**Проблема 2: Множественное вычисление аргументов** Если аргумент макроса используется несколько раз в замещающем тексте, и этот аргумент содержит побочные эффекты (инкремент, вызов функции), эти побочные эффекты выполняются многократно.

**Проблема 3: Побочные эффекты** Связана с предыдущей проблемой — при использовании аргументов с побочными эффектами (например, инкремент) в макросах с условными выражениями, побочный эффект может выполниться или не выполниться в зависимости от ветви, или выполниться дважды.

**Решение**: использовать встроенные функции `inline` (C99) или statement expressions (GNU extension) с локальными переменными для однократного вычисления аргументов.

### Многострочные макросы
Используется обратный слэш `\` в конце каждой строки (кроме последней) для склейки физических строк в одну логическую.
**Идиома `do { ... } while(0)`** — классический трюк для многострочных макросов, позволяющий использовать макрос как единый оператор, требующий точки с запятой после вызова, и корректно работающий в конструкциях if-else без фигурных скобок.
### Вариадические макросы (C99)
Макросы с переменным числом аргументов. Используется специальная многоточие `...` в списке параметров и идентификатор `__VA_ARGS__` для обращения ко всем переменным аргументам.
**`##__VA_ARGS__`** (GNU extension) — удаляет лишнюю запятую перед `__VA_ARGS__`, если переменные аргументы отсутствуют. Критично для создания макросов, работающих как с аргументами, так и без них.
### Отмена макроса (#undef)
Директива `#undef` удаляет определение макроса. После этого макрос можно переопределить заново. Безопасно вызывать для несуществующего макроса — не является ошибкой.

---
## Условная компиляция

### `#ifdef` / `#ifndef`

`#ifdef MACRO_NAME` — код компилируется, если `MACRO_NAME` определен (неважно, какое значение) `#ifndef MACRO_NAME` — код компилируется, если `MACRO_NAME` НЕ определен

Используется для включения/исключения блоков кода в зависимости от наличия определений.
### `#if` / `#elif` / `#else` / `#endif`
Более мощный механизм с вычислением **константных выражений препроцессора**. Позволяет использовать арифметические и логические операции, сравнения.
**Важно**: выражение в `#if` должно быть **константным выражением времени препроцессора**. Можно использовать:

- Целочисленные литералы
- Макросы
- Операторы: `+`, `-`, `*`, `/`, `%`, `<`, `>`, `==`, `!=`, `&&`, `||`, `!`, битовые операции
- **НЕЛЬЗЯ**: переменные, вызовы функций, sizeof (кроме sizeof для типов)

### Оператор defined

`defined(MACRO)` или `defined MACRO` — проверяет, определен ли макрос. Возвращает 1, если определен, 0 иначе.

**Почему defined полезен**: позволяет комбинировать условия в выражениях `#if`, создавая сложную логику проверок нескольких макросов одновременно.

### `#error` и `#warning`

`#error "message"` — останавливает компиляцию с сообщением об ошибке. Используется для принудительного прекращения компиляции при невыполнении обязательных условий.

`#warning "message"` — выводит предупреждение, но продолжает компиляцию (не стандарт C, но широко поддерживается GCC, Clang). Полезно для уведомления о потенциальных проблемах.

### Практическое применение: платформо-зависимый код

Условная компиляция критична для кроссплатформенного кода, где разные платформы требуют разных системных вызовов, заголовочных файлов, констант. Используются предопределенные макросы платформ: `_WIN32`, `__linux__`, `__APPLE__`, `__unix__` и т.д.

### Предопределенные макросы

Компилятор автоматически определяет стандартные макросы:

- `__FILE__` — имя текущего исходного файла (строковый литерал)
- `__LINE__` — номер текущей строки (целое число)
- `__DATE__` — дата компиляции в формате "Mmm dd yyyy"
- `__TIME__` — время компиляции в формате "hh:mm:ss"
- `__func__` — имя текущей функции (C99, не макрос препроцессора, а предопределенный идентификатор)
- `__STDC__` — определен как 1 для стандартных C компиляторов
- `__STDC_VERSION__` — версия стандарта: 199901L (C99), 201112L (C11), 201710L (C17)

Используются для отладки, логирования, проверки версии стандарта.

---

## Оператор # (Stringification)
**Превращает аргумент макроса в строковый литерал**. Ставится перед параметром макроса в замещающем тексте.
### Важное поведение: нет раскрытия макросов!
Оператор `#` применяется к **токену как он есть**, без предварительного раскрытия макросов. Если аргумент сам является макросом, в строку попадет имя макроса, а не его значение.
**Решение: двойное раскрытие** — использование вспомогательного макроса, который сначала раскрывает аргумент, а затем применяет stringification.

### Экранирование кавычек и слэшей
Препроцессор автоматически экранирует специальные символы внутри строкового литерала: добавляет обратные слэши перед `"` и `\`, чтобы результирующая строка была валидным C литералом.

---
## Оператор ## (Token Pasting / Concatenation)
**Склеивает два токена в один**. Используется для динамической генерации идентификаторов на этапе препроцессирования.
Ставится между двумя токенами в замещающем тексте макроса. В результате препроцессор убирает пробелы и сам оператор `##`, соединяя токены в один.
### Практическое применение: генерация имен
Используется для автоматической генерации связанных имен функций, переменных, типов. Критично для создания generic кода и уменьшения дублирования.
### Создание уникальных имен
Комбинация с `__LINE__` позволяет создавать уникальные идентификаторы на каждой строке кода, что полезно для вспомогательных переменных в сложных макросах.
### Проблема: нет раскрытия макросов перед склейкой
Аналогично оператору `#`, оператор `##` работает с токенами **до** раскрытия макросов. Если склеиваемые части являются макросами, склеиваются их имена, а не значения.
**Решение: двойное раскрытие** — использование вспомогательного макроса для предварительного раскрытия аргументов перед склейкой.

---

## Особенности конструирования замещающих значений
### 1. Парентезирование (скобки везде!)
**Правило золотое**: **каждый аргумент в скобки + всё выражение в скобки**. Без этого операторы из контекста вызова "вклиниваются" в выражение макроса из-за приоритетов операторов, что приводит к некорректным результатам.
### 2. Точка с запятой и do-while(0)
Проблема возникает при использовании многострочных макросов в условных операторах без фигурных скобок. Простые блоки `{ }` создают точку с запятой после закрывающей скобки, что "разрывает" конструкцию if-else.
**Идиома `do { ... } while(0)`** решает проблему: создает единый оператор, требующий точки с запятой, и корректно работающий везде, где ожидается один оператор.
### 3. Обратный слэш для многострочных макросов
Обратный слэш `\` в конце строки указывает препроцессору, что определение макроса продолжается на следующей строке.
**Важно**: обратный слэш должен быть **последним символом** на строке (даже пробел или табуляция после него приведет к ошибке или неожиданному поведению).
### 4. Проблема типов и typeof
Функционально-подобные макросы часто требуют объявления временных переменных (для избежания повторного вычисления аргументов), но тип этих переменных неизвестен, если макрос должен быть generic.

**Решение (GNU extension)**: `typeof(expr)` — получает тип выражения на этапе компиляции. Позволяет создавать type-generic макросы.

В стандартном C (до C11 `_Generic`) полностью type-generic макросы с временными переменными невозможны — нужны inline функции или семейство макросов для разных типов.

### 5. Оптимизация: inline vs макросы

**Макросы**:

- ✓ Работают с любыми типами (при правильном конструировании)
- ✓ Нет накладных расходов на вызов (истинный inline)
- ✗ Код дублируется при каждом вызове (увеличение размера исполняемого файла)
- ✗ Побочные эффекты аргументов выполняются многократно
- ✗ Трудно отлаживать (нет стека вызовов, ошибки указывают на место раскрытия)

**Inline функции (C99)**:

- ✓ Полная типобезопасность
- ✓ Нет побочных эффектов с аргументами
- ✓ Отладка проще (есть точка входа, стек вызовов)
- ✗ Работают только с конкретными типами
- ✗ Компилятор может проигнорировать inline (это лишь рекомендация)
- ✗ Небольшие накладные расходы возможны

**Современный подход**: предпочитать `inline` функции для типизированного кода, макросы — только для type-generic операций или когда критична производительность.

### 6. X-макросы (Advanced technique)

Мощный паттерн для генерации повторяющегося кода из табличных данных. Суть: файл с данными содержит только вызовы макроса X с разными аргументами, который определяется по-разному при каждом включении файла для генерации различных конструкций (enum, массивы строк, switch-case и т.д.).

Применение: генерация enums с соответствующими строковыми представлениями, таблиц dispatch для конечных автоматов, сериализация/десериализация структур.

---

## Практические идиомы

### Assert с сообщением

Расширенная версия стандартного `assert()`, выводящая дополнительную информацию: файл, строку, условие и пользовательское сообщение. Использует `__FILE__`, `__LINE__`, оператор `#` для stringification условия.

### Макросы для минимума/максимума

Проблема стандартных макросов MIN/MAX — множественное вычисление аргументов. Решение через statement expressions (GNU extension) с временными переменными и `typeof`.

### Макросы для массивов

Идиома `ARRAY_SIZE(arr)` вычисляет количество элементов статического массива через `sizeof(arr) / sizeof(arr[0])`. Работает только для настоящих массивов, для указателей дает неправильный результат.

---

## Опасности и антипаттерны

### 1. Макросы, зависящие от внешнего контекста

Макросы, использующие глобальные переменные или переменные из окружающей области видимости без явной передачи через параметры. Создают скрытые зависимости, затрудняют понимание и переиспользование кода.

### 2. Макросы с побочными эффектами

Макросы, которые изменяют свои аргументы или глобальное состояние. Нарушают принцип наименьшего удивления — вызов выглядит как чтение, а на самом деле модифицирует данные.

### 3. Макросы, маскирующие операторы

Переопределение синтаксиса языка через макросы (например, BEGIN/END вместо фигурных скобок). Делает код нечитаемым для людей, не знакомых с проектом, затрудняет использование стандартных инструментов.

### 4. Слишком сложные макросы

Если макрос занимает более 5-10 строк или содержит сложную логику, вероятно, он должен быть функцией. Сложные макросы трудно понимать, отлаживать и сопровождать.

---

## Философский аспект

Препроцессор — это **обоюдоострый меч**:

- Позволяет мощную метапрограммацию на уровне текста
- Обеспечивает условную компиляцию для кроссплатформенности
- Но легко создать непонятный, неотлаживаемый, подверженный ошибкам код

**Современные альтернативы** (C11+):

- `_Generic` для type-generic макросов (выбор выражения на основе типа аргумента)
- `inline` функции вместо function-like макросов (где type-generic не требуется)
- `const` переменные вместо object-like макросов (где возможно, дают типобезопасность и область видимости)

Препроцессор критичен для:

- Условной компиляции (платформы, фичи, debug/release режимы)
- Include guards (защита от повторного включения заголовков)
- Совместимости с устаревшим кодом
- Метапрограммирования (когда возможностей языка недостаточно)

Но чрезмерное использование макросов — признак плохого дизайна. **Принцип**: используйте препроцессор, когда других средств языка C недостаточно, и всегда предпочитайте более безопасные альтернативы, если они доступны.