---
sticker: ""
---
# Концептуальная основа динамического выделения памяти
Динамическая память выделяется из кучи (heap) — области памяти процесса, управляемой ОС и библиотекой в runtime.
Отличие от стека заключается в том, что память не выделяется и не очищается автоматическе, а требует явного управления.

### Структура адресного пространства
- Сегмент кода (text) — исполняемый код программы
- Область данных — глобальные и статические переменные
- Куча — растет вверх, управляется через *malloc/free*
- Стек — растет вниз, управляется автоматически

**Критическое отличие**: стековая память освобождается автоматически, динамическая — только явным вызовом `free()`. Отсутствие освобождения приводит к **утечкам памяти (memory leak)**.

---
## Func *malloc*
```c
void* malloc(size_t size);
```
#### Семантика работы
- Выделяет непрерывный (последовательный) блок, размером *size* байт из кучи
- *Returns* `void*` на начало выделенного блока памяти 
	- В случае ошибки возвращает `NULL`
- Память не инициализируется (содержит мусор)

## Func *сalloc*
```c
void* calloc(size_t nmemb, size_t size);
```
#### Семантика работы
- Принимает два аргумента количество элементов `nmemb` и размер элемента  `size`.
- Выделяет непрерывный (последовательный) блок, размером *size* байт из кучи
- *Returns* `void*` на начало выделенного блока памяти 
	- В случае ошибки возвращает `NULL`
- Память инициализируется (заполняется нулями 0 или NULL)

## Func *realloc*
```c
void* realloc(void *ptr, size_t new_size);
```

#### Краевые случаи
 - `ptr == NULL`: поведение эквивалентное `malloc(size)`
 - `new_size == 0`: поведение эквивалентное `free(ptr)` *Returns* NULL
 -  Стандартный случай: Изменяет размер блока `ptr` до `new_size`
#### Обычное поведение
- *Расширяет* память *на месте*, в случае если достаточно места. Адрес *неизменный*.
- *Выделяет* блок памяти *в другом месте*, перемещая старые данные. Адрес *меняется*.
- Ошибка:  *Returns* NULL, старый блок не меняется и остается валидным

##### Важно!
> При использовании `realloc` использовать временный указатель, во избежание утечки памяти, в случае неудачи аллокатора.

---
## Func *free*
```c
void free(void *ptr);
```
### Семантика:
- Освобождает память, ранее выделенную malloc/calloc/realloc
- После вызова указатель становится **висячим (dangling pointer)** — указывает на освобожденную память
- Передача `NULL` — **безопасна** и ничего не делает (стандарт C гарантирует)
- Передача невалидного указателя — **неопределенное поведение (UB)**: может вызвать segmentation fault или повреждение кучи

### Критические ошибки:
- **Double free** — двойное освобождение
- **Use after free** — использование после освобождения:

## Оператор *sizeof*
### Природа sizeof:
**sizeof — это НЕ функция, а ОПЕРАТОР времени компиляции**. Результат вычисляется компилятором **статически** (за редкими исключениями VLA — Variable Length Arrays).
### Возвращаемый тип:
`size_t` — беззнаковый целочисленный тип, достаточный для хранения размера любого объекта в памяти. На 64-битных системах обычно `unsigned long` (8 байт), на 32-битных — `unsigned int` (4 байта).

```c
sizeof(char)     // Всегда 1 (по стандарту C)
sizeof(int)      // Обычно 4, но НЕ гарантировано!
sizeof(double)   // Обычно 8
sizeof(void*)    // 8 на 64-бит, 4 на 32-бит

// Размер массива
int arr[10];
sizeof(arr)           // 40 байт (10 * sizeof(int))
sizeof(arr)/sizeof(arr[0])  // 10 — идиома для длины массива
```

#### Размер структур
 ```c
struct Data {
    char c;     // Смещение 0, размер 1
    // [3 байта padding]
    int i;      // Смещение 4, размер 4
    short s;    // Смещение 8, размер 2
    // [2 байта padding для выравнивания структуры]
};
// Итого: 12 байт

// Поля от большего к меньшему
struct Optimized {
    int i;      // 4 байта
    short s;    // 2 байта
    char c;     // 1 байт
    // [1 байт padding]
}; // Итого: 8 байт вместо 12
 ```


### Особые случаи sizeof:
**VLA (Variable Length Arrays)** — исключение, вычисляется во время выполнения:
```c
int n = 10;
int vla[n];
sizeof(vla) // Вычисляется runtime: n * sizeof(int)
```

