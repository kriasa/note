Директивы препроцессора в языке C. Порядок работы препроцессора. Директивы #include, #define, #ifdef/#ifndef, #endif, #, ##, их назначение, особенности и примеры использования. Особенности конструирования замещающих значений для макроопределений в языке C. 


## Препроцессор: концептуальная основа

**Препроцессор** — это отдельная фаза компиляции, работающая **ДО** собственно компилятора. Это **текстовый процессор**, выполняющий чисто синтаксическую обработку исходного кода на уровне лексем (токенов), без понимания семантики языка C.
### Критическое понимание:
Препроцессор **не знает о типах данных, области видимости, синтаксисе C** — он работает с текстом как с потоком токенов. Это мощный, но **опасный** инструмент: ошибки препроцессора могут привести к трудноотлаживаемым проблемам.

---
## Порядок работы препроцессора
### Фазы трансляции (согласно стандарту C)

**Фаза 1-2**: Физическая обработка файла
- Преобразование исходного файла в поток символов
- Обработка trigraph-последовательностей (устаревшие, `??=` → `#`)
- Склейка строк, заканчивающихся на `\` (line splicing) — позволяет разбивать длинные макросы на несколько физических строк

**Фаза 3**: Токенизация и обработка комментариев
- Исходный текст разбивается на **токены** (ключевые слова, идентификаторы, литералы, операторы)
- Комментарии `/* */` и `//` заменяются на пробелы

**Фаза 4**: Выполнение директив препроцессора
- Обработка всех директив `#include`, `#define`, `#if`, `#ifdef` и т.д.
- Раскрытие макросов
- Условная компиляция

**Фаза 5-9**: Компиляция, линковка
- Препроцессированный текст передается компилятору
- Компиляция в объектный код
- Линковка

### Просмотр результата препроцессирования
Команды `gcc -E source.c -o source.i` или `clang -E source.c -o source.i` позволяют получить файл `.i` с результатом препроцессирования — незаменимо для отладки макросов!

---

## Директива `#include`
### Синтаксис и семантика

`#include <filename>` — для системных заголовочных файлов 

`#include "filename"` — для пользовательских заголовочных файлов

**Механизм работы**: препроцессор **буквально заменяет** строку `#include` на **полное содержимое** указанного файла.
### Различия между <> и ""

**Угловые скобки `<>`**:
- Поиск в **системных директориях** (`/usr/include`, `/usr/local/include` на Unix)
- Не ищет в текущей директории
- Используется для стандартной библиотеки и системных заголовков

**Кавычки `""`**:
- Поиск **сначала в текущей директории** (или директории, указанной путем)
- Если не найден, продолжает поиск как `<>` (в системных путях)
- Используется для собственных заголовочных файлов проекта

---
### Проблема двойного включения (include guards)

**Проблема**: если заголовочный файл включается несколько раз (напрямую или через другие заголовки), происходит множественное определение структур, функций и т.д. — ошибка компиляции.

**Решение 1: Include Guards** (традиционный способ): Использование директив `#ifndef`, `#define`, `#endif` для создания защиты от повторного включения. При первом включении макрос не определен, файл обрабатывается и макрос определяется. При повторном включении макрос уже определен, содержимое пропускается.

**Решение 2: `#pragma once`** (современный, не стандартный, но широко поддерживается): Однострочная директива, которая указывает компилятору, что файл должен быть включен только один раз.

**Преимущества `#pragma once`**:
- Короче и понятнее
- Нет риска коллизии имен макросов
- Может быть быстрее (компилятор не открывает файл повторно)

**Недостаток**: не входит в стандарт C (но поддерживается GCC, Clang, MSVC)

---

## Директива `#define`

Используется для создания макросов и именованных констант.

### Объектно-подобные макросы (object-like macros)
Простая текстовая подстановка константных значений. Определяются без параметров.
**Важно**: макросы определяются **без точки с запятой** — они не являются выражениями C, а представляют собой текстовую подстановку.
### Функционально-подобные макросы (function-like macros)
Макросы с параметрами, имитирующие функции. **Критически важно**: НЕТ пробела между именем макроса и открывающей скобкой, иначе скобка будет частью замещающего текста.

Создает правило замены текста.

- **Константы:** `#define PI 3.14159`
    
- **Макрофункции:** `#define SQUARE(x) ((x) * (x))`

### Отмена макроса (#undef)
Директива `#undef` удаляет определение макроса. После этого макрос можно переопределить заново. Безопасно вызывать для несуществующего макроса — не является ошибкой.

Особенности макросов: Включают текстовую замену без проверки типов. Рекомендуется использовать скобки для предотвращения ошибок: #define BAD_MACRO(x) x * x printf("%d\n", BAD_MACRO(1 + 2)); // Вывод: 5, а не 9

---
## Условная компиляция

#### Условная компиляция (#ifdef, #ifndef, #endif)

Позволяют включать или исключать куски кода.

- **`#ifdef NAME`**: код скомпилируется, только если макрос `NAME` определен.
    
- **`#ifndef NAME`**: код скомпилируется, если макрос `NAME` **не** определен. Это основа **Header Guards** (защиты от двойного включения заголовков).
- `defined(MACRO)` или `defined MACRO` — проверяет, определен ли макрос. Возвращает 1, если определен, 0 иначе.

```
#ifndef MY_HEADER_H
#define MY_HEADER_H

// Весь код заголовка здесь

#endif
```

![[Pasted image 20251218130333.png]]
```c
#include  <stdio.h>
#define DEBUG 1 
int main() { 
    #ifdef DEBUG 
        printf("Режим отладки включен\n"); 
    #else 
        printf("Режим отладки выключен\n"); 
    #endif 
    #ifndef RELEASE 
        printf("Релизный режим не включен\n"); 
    #elif RELEASE == 2 
        printf("Релизный режим 2\n"); 
    #else 
        printf("Релизный режим 1\n"); 
    #endif 
    return 0; 
}
```
---
### Операторы # и

Эти операторы используются только внутри `#define` с аргументами.

#### Оператор # (Строкация / Stringification)

Превращает аргумент макроса в строку в кавычках.

```
#define PRINT_INT(x) printf(#x " = %d\n", x)

int age = 25;
PRINT_INT(age); 
// Превратится в: printf("age" " = %d\n", age);
```

#### Оператор ## (Склеивание / Concatenation)

Склеивает две части текста в одно целое (имя переменной, функции и т.д.).


```
#define MAKE_VAR(name, num) name##num

int MAKE_VAR(count, 5) = 10; 
// Превратится в: int count5 = 10;
```

---

### 4. Особенности конструирования макросов

Макросы — это «глупая» подстановка текста, поэтому при их создании легко совершить две фатальные ошибки.

#### Ошибка 1: Приоритет операций

**Плохо:** `#define MULT(a, b) a * b` Если вызвать `MULT(2 + 2, 2)`, получится `2 + 2 * 2`, что равно **6**, а не 8.**Хорошо:** Всегда берите каждый аргумент и весь макрос в скобки:`#define MULT(a, b) ((a) * (b))`

#### Ошибка 2: Побочные эффекты

**Плохо:** `#define MAX(a, b) ((a) > (b) ? (a) : (b))` Если вызвать `MAX(i++, j)`, то переменная `i` увеличится **дважды**, если она больше `j`._Запомните: в макросы нельзя передавать выражения с инкрементом или вызовом функций._
![[Pasted image 20251218131922.png]]