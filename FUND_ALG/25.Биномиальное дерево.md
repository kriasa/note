 Приоритетные очереди. Биномиальное дерево, ранг биномиального дерева, число элементов в биномиальном дереве заданного ранга. Биномиальная и фибоначчиева приоритетные очереди, их реализация на базе структур данных вида кольцевой список и дерево общего вида. Операции вставки элемента, поиска минимума/максимума, удаления минимума/максимума, слияния с разрушением и без разрушения исходных биномиальных/фибоначчиевых приоритетных очередей; их вычислительные сложности и реализация на языке C.

# Часть 1. Теоретический фундамент

## 1. Биномиальное дерево ($B_k$)

Это основной строительный блок. Биномиальные деревья определяются рекурсивно:

1. **$B_0$**: Дерево из одного узла (корень).
    
2. **$B_k$**: Состоит из двух деревьев $B_{k-1}$, где корень одного дерева становится **самым левым ребенком** корня другого.
    

### Свойства биномиального дерева ранга $k$:

1. **Число узлов:** Ровно $2^k$.
    
2. **Высота дерева:** Ровно $k$.
    
3. **Степень корня (Ранг):** Ровно $k$ (у корня $k$ детей).
    
4. **Дети корня:** Если у нас есть дерево $B_k$, то дети его корня — это корни деревьев $B_0, B_1, B_2, \dots, B_{k-1}$.
    

---

# Часть 2. Биномиальная приоритетная очередь

### Структура

Биномиальная куча — это **набор (список) биномиальных деревьев**, где:

1. Каждое дерево подчиняется **свойству кучи** (ключ родителя $\le$ ключа ребенка).
    
2. В куче может быть **не более одного** дерева каждого ранга.
    

Аналогия с двоичной системой:

Представь число элементов $N = 13$. В двоичной системе это $1101_2$.

Это значит, что биномиальная куча из 13 элементов будет содержать деревья рангов: $B_3$ (8 узлов), $B_2$ (4 узла) и $B_0$ (1 узел). $8+4+1 = 13$.

### Реализация на C (Дерево общего вида)

Мы используем структуру «Левый ребенок — Правый брат» (Left Child - Right Sibling).

C

```
typedef struct Node {
    int key;
    int degree;             // Ранг (число детей)
    struct Node *parent;
    struct Node *child;     // Указатель на первого ребенка (самого левого)
    struct Node *sibling;   // Указатель на следующего брата
} Node;

// Сама куча — это просто список корней (обычно упорядоченный по рангу)
typedef struct {
    Node *head; 
} BinomialHeap;
```

### Основные операции и Сложности

|**Операция**|**Сложность**|**Комментарий**|
|---|---|---|
|**Insert**|$O(\log n)$|Слияние кучи с новым деревом $B_0$.|
|**Find Min**|$O(\log n)$|Проход по списку корней (их всего $\log n$).|
|**Merge**|$O(\log n)$|Аналог сложения двоичных чисел столбиком.|
|**Delete Min**|$O(\log n)$|Удалить корень, развернуть список его детей и слить с основной кучей.|

#### Алгоритм Слияния (Merge) — Самое важное

Слияние двух биномиальных куч похоже на сложение двоичных чисел. Мы идем от $rank=0$ до макс. ранга.

- Если есть два дерева $B_k$ (одно в куче A, другое в B), мы объединяем их в $B_{k+1}$ (одно становится сыном другого) и переносим как «единицу в уме» (carry) на следующий шаг.
    

C

```
// Вспомогательная функция: делает y ребенком z
void linkTrees(Node* y, Node* z) {
    y->parent = z;
    y->sibling = z->child;
    z->child = y;
    z->degree++;
}

// Упрощенный пример слияния списков корней (без "переноса" разрядов, для понимания структуры)
// Полный алгоритм требует обработки carry (как в сумматоре)
Node* mergeHeaps(BinomialHeap* h1, BinomialHeap* h2) {
    // Здесь должна быть логика прохода по спискам h1->head и h2->head
    // и вызов linkTrees для деревьев одинакового ранга.
    // Результат — новый список корней.
    return NULL; // Псевдокод
}
```

---

# Часть 3. Фибоначчиева приоритетная очередь

Это более продвинутая структура. Она "ленивая" (lazy). Она откладывает работу по упорядочиванию деревьев до самого последнего момента (обычно до `DeleteMin`).

### Отличия от Биномиальной кучи:

1. **Структура списков:** Используются **циклические двусвязные списки** (Circular Doubly Linked List) для хранения корней и для хранения детей. Это позволяет вставлять и удалять узлы за $O(1)$.
    
2. **Деревья:** Могут иметь любую форму (не обязательно строгие $B_k$), хотя строятся из биномиальных.
    
3. **Ленивость:** При `Merge` мы просто сцепляем два списка корней вместе, ничего не перестраивая.
    

### Реализация на C (Кольцевой список)

C

```
typedef struct FibNode {
    int key;
    int degree;
    int marked;             // Для операции DecreaseKey (не для билета, но важно знать)
    struct FibNode *parent;
    struct FibNode *child;  // Указатель на одного из детей
    struct FibNode *left;   // Левый сосед (циклический список)
    struct FibNode *right;  // Правый сосед (циклический список)
} FibNode;

typedef struct {
    FibNode *min;           // Указатель сразу на минимальный элемент!
    int n;                  // Количество узлов
} FibonacciHeap;
```

### Основные операции и Сложности (Амортизированные!)

Фибоначчиевы кучи выигрывают за счет амортизации.

|**Операция**|**Сложность (Аморт.)**|**Худший случай**|**Комментарий**|
|---|---|---|---|
|**Insert**|$O(1)$|$O(1)$|Просто добавить узел в список корней и обновить `min`.|
|**Find Min**|$O(1)$|$O(1)$|Мы всегда храним указатель `min`.|
|**Merge**|$O(1)$|$O(1)$|Просто объединить два кольцевых списка.|
|**Delete Min**|$O(\log n)$|$O(n)$|Самая дорогая операция. Запускает **Consolidate**.|

---

### Детальный разбор операций Фибоначчиевой кучи

#### 1. Вставка (Insert)

Мы просто создаем узел и вставляем его в кольцевой список корней рядом с `min`. Если новый ключ меньше `min`, обновляем указатель `min`. Никакого перестроения деревьев.

C

```
void insert(FibonacciHeap* H, int key) {
    FibNode* node = createNode(key); // malloc и инициализация
    if (H->min == NULL) {
        H->min = node;
        node->left = node->right = node; // Замыкаем на себя
    } else {
        // Вставка в кольцевой список справа от min
        node->right = H->min->right;
        node->left = H->min;
        H->min->right->left = node;
        H->min->right = node;
        
        if (key < H->min->key) {
            H->min = node;
        }
    }
    H->n++;
}
```

#### 2. Слияние (Merge)

Слияние без разрушения требует копирования ($O(n)$), что убивает смысл кучи. Поэтому всегда используется слияние с разрушением ($O(1)$).

Мы просто разрываем два кольца (списки корней) и соединяем их в одно большое кольцо.

#### 3. Удаление минимума (Delete Min) и Consolidate

Это единственная операция, которая "платит по счетам" за всю ленивость.

Алгоритм:

1. Удаляем `min` узел из списка корней.
    
2. Всех детей удаленного узла поднимаем в список корней (они становятся сиротами).
    
3. Если корней стало много, запускаем процесс **Уплотнения (Consolidate)**:
    
    - Создаем массив `A` размера $\log n$.
        
    - Проходим по списку корней. Если встречаем два корня одинаковой степени $d$, мы сливаем их (один становится сыном другого), получаем дерево степени $d+1$.
        
    - Повторяем, пока в списке не останется не более одного дерева каждой степени (как в Биномиальной куче).
        
4. Находим новый `min`.
    

### Сравнительная таблица (Резюме для билета)

|**Характеристика**|**Биномиальная куча**|**Фибоначчиева куча**|
|---|---|---|
|**Структура корней**|Связный список (упорядочен)|Циклический двусвязный список (хаос)|
|**Insert**|$O(\log n)$|**$O(1)$**|
|**Merge**|$O(\log n)$|**$O(1)$**|
|**Delete Min**|$O(\log n)$|$O(\log n)$ (амортизировано)|
|**Decrease Key**|$O(\log n)$|**$O(1)$** (амортизировано)|
|**Сложность кода**|Средняя|Очень высокая|

### Слияние с разрушением vs Без разрушения

В обоих типах куч:

1. **С разрушением:** Мы манипулируем указателями. Исходные указатели на кучи (`H1`, `H2`) становятся невалидными или указывают на новую общую кучу. Это быстро ($O(\log n)$ или $O(1)$).
    
2. **Без разрушения:** Требует **глубокого копирования** всех узлов.
    
    - Сложность: $O(N_1 + N_2)$.
        
    - Реализация: Рекурсивный обход деревьев (`malloc` для каждого узла).
        
    - В контексте приоритетных очередей используется крайне редко, так как это слишком медленно.
        

### Итог

На экзамене важно подчеркнуть:

- **Биномиальная куча** — это строгая структура, похожая на двоичное число, оптимизированная для слияния ($O(\log n)$).
    
- **Фибоначчиева куча** — это оптимизация биномиальной. Она делает всё лениво за $O(1)$, а всю "грязную работу" по упорядочиванию скидывает на операцию `DeleteMin`. Это де-факто стандарт для реализации алгоритма Дейкстры и Прима на графах.