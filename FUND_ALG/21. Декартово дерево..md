Декартово дерево. Создание и удаление декартова дерева. Операция поиска элемента в декартовом дереве, её связь с дихотомическим (бинарным) поиском. Операции вставки/удаления элемента. Вычислительные сложности и реализация вышеописанных операций на языке C.

## 1. Что такое Декартово дерево (Treap)?

**Декартово дерево** — это структура данных, объединяющая свойства **бинарного дерева поиска (BST)** и **бинарной кучи (Heap)**. Отсюда и название: **Tre**e + He**ap** = **Treap**.

Каждый узел дерева содержит два значения:

1. **Ключ ($X$):** По ключам дерево является обычным деревом поиска. Для любого узла ключи в левом поддереве меньше ключа узла, а в правом — больше.
    
2. **Приоритет ($Y$):** По приоритетам дерево является кучей. Обычно используется "Max-Heap": приоритет родителя всегда больше приоритетов его детей.
    

**Важнейшая особенность:** Если приоритеты выбирать **случайно**, то дерево с очень высокой вероятностью получится сбалансированным. Его высота будет составлять $O(\log n)$, что гарантирует быструю работу всех операций.

---

## 2. Базовые операции: Split и Merge

В отличие от AVL или Красно-черных деревьев, где используются сложные повороты, в Декартовом дереве всё строится на двух изящных рекурсивных операциях.

### Split (Разрезание)

Операция делит одно дерево на два: $L$ (левое) и $R$ (правое) по некоторому ключу $K$.

- В $L$ уходят все узлы с ключами $\le K$.
    
- В $R$ уходят все узлы с ключами $> K$.
    

**Логика:** Мы сравниваем ключ корня с $K$. Если корень $\le K$, то он и всё его левое поддерево точно идут в $L$. Его правое поддерево мы продолжаем "резать" рекурсивно.

### Merge (Слияние)

Операция объединяет два дерева $L$ и $R$ в одно.

- **Условие:** Все ключи в $L$ должны быть строго меньше всех ключей в $R$.
    
- **Логика:** Мы смотрим на приоритеты корней. Кто "главнее" (приоритет выше), тот становится родителем. Второе дерево рекурсивно прикрепляется к одной из ветвей.
    

---

## 3. Вставка, Удаление и Поиск

### Поиск (Search)

Поиск в Декартовом дереве ничем не отличается от поиска в обычном бинарном дереве. Мы смотрим только на ключи $X$.

- **Связь с бинарным поиском:** Поскольку дерево сбалансировано, путь от корня до любого элемента — это $O(\log n)$. По сути, структура дерева — это "застывший" процесс дихотомического поиска.
    

### Вставка (Insert)

Чтобы вставить ключ $K$:

1. Генерируем для него случайный приоритет $P$.
    
2. Разрезаем (`Split`) дерево по ключу $K$ на две части ($L$ и $R$).
    
3. Создаем новый одиночный узел из $(K, P)$.
    
4. Склеиваем всё обратно: `Merge(Merge(L, newNode), R)`.
    

### Удаление (Delete)

Чтобы удалить ключ $K$:

1. Разрезаем дерево на три части: $L$ (ключи $< K$), $M$ (ключи $= K$), $R$ (ключи $> K$).
    
2. Удаляем узел (или узлы), попавшие в дерево $M$.
    
3. Склеиваем оставшиеся части: `Merge(L, R)`.
    

---

## 4. Реализация на языке C

C

```
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// Структура узла
typedef struct Node {
    int key;            // Ключ (X)
    int priority;       // Приоритет (Y)
    struct Node *left, *right;
} Node;

// Создание нового узла
Node* createNode(int key) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->key = key;
    newNode->priority = rand(); // Случайный приоритет
    newNode->left = newNode->right = NULL;
    return newNode;
}

// РЕАЛИЗАЦИЯ SPLIT
void split(Node* t, int key, Node** l, Node** r) {
    if (t == NULL) {
        *l = *r = NULL;
        return;
    }
    if (t->key <= key) {
        // Корень идет в левую часть, режем его правое дерево
        split(t->right, key, &(t->right), r);
        *l = t;
    } else {
        // Корень идет в правую часть, режем его левое дерево
        split(t->left, key, l, &(t->left));
        *r = t;
    }
}

// РЕАЛИЗАЦИЯ MERGE
Node* merge(Node* l, Node* r) {
    if (l == NULL || r == NULL) return (l != NULL) ? l : r;

    if (l->priority > r->priority) {
        // Левый корень выше (свойство кучи), присоединяем к нему
        l->right = merge(l->right, r);
        return l;
    } else {
        // Правый корень выше
        r->left = merge(l, r->left);
        return r;
    }
}

// Вставка (через split и merge)
Node* insert(Node* root, int key) {
    Node *l, *r;
    split(root, key, &l, &r);
    Node* newNode = createNode(key);
    return merge(merge(l, newNode), r);
}

// Поиск (стандартный BST)
Node* find(Node* root, int key) {
    if (root == NULL || root->key == key) return root;
    if (key < root->key) return find(root->left, key);
    return find(root->right, key);
}

// Удаление дерева из памяти
void freeTreap(Node* root) {
    if (root == NULL) return;
    freeTreap(root->left);
    freeTreap(root->right);
    free(root);
}
```

---

## 5. Вычислительные сложности

Декартово дерево обеспечивает отличную производительность благодаря самобалансировке.

|**Операция**|**Сложность (в среднем)**|**Сложность (худшая)**|
|---|---|---|
|**Поиск**|$O(\log n)$|$O(n)$|
|**Вставка**|$O(\log n)$|$O(n)$|
|**Удаление**|$O(\log n)$|$O(n)$|
|**Split/Merge**|$O(\log n)$|$O(n)$|

_Худший случай ($O(n)$) возможен только если случайные приоритеты выстроятся по порядку, что при использовании хорошего генератора случайных чисел (`rand()`) практически невозможно на больших данных._

### Почему это важно для экзамена?

1. **Элегантность:** Код декартова дерева короче и понятнее, чем у AVL-дерева.
    
2. **Случайность:** Это пример рандомизированного алгоритма.
    
3. **Функциональность:** На базе Treap легко реализовать "неявный ключ" (дерево, которое ведет себя как массив, в который можно вставлять элементы в середину за $\log n$).