Приоритетные очереди. Левосторонняя приоритетная очередь, её реализация на базе структуры данных вида бинарное дерево. Операции вставки элемента, поиска минимума/максимума, удаления минимума/максимума, слияния с разрушением и без разрушения исходных левосторонних приоритетных очередей; их вычислительные сложности и реализация на языке C.

Если обычная бинарная куча (Binary Heap) хороша для добавления и удаления, то **Левосторонняя куча (Leftist Heap)** — это король операции **Слияния (Merge)**.

Давай разберем всё «по косточкам».

---

### 1. Что такое Левосторонняя куча?

Это бинарное дерево, которое обладает двумя главными свойствами:

1. **Свойство Кучи (Heap Property):** Ключ в любом узле меньше (или равен) ключей его детей (для Min-Heap). То есть минимум всегда в корне.
    
2. **Левостороннее свойство (Leftist Property):** Дерево стремится быть «тяжелым» слева. Правая ветка любого узла всегда короче или равна левой ветке.
    

Чтобы понять это математически, введем понятие **NPL (Null Path Length)** — длина нулевого пути.

- **NPL(null)** = -1.
    
- **NPL(узла)** = расстояние до ближайшего отсутствующего потомка (или до `NULL`).
    
- Суть свойства: Для любого узла $X$:
    
    $$NPL(\text{LeftChild}(X)) \ge NPL(\text{RightChild}(X))$$
    

Зачем это нужно?

Это гарантирует, что путь по правым детям (right -> right -> right...) будет самым коротким путем до листа. Длина этого правого пути всегда не превышает $O(\log N)$.

Поскольку мы знаем, что правая сторона короткая, мы будем делать все операции только с правой стороной, и это будет быстро.

---

### 2. Реализация на языке C (Структура данных)

Нам не нужен массив, здесь используется классическое дерево на указателях.

C

```
#include <stdio.h>
#include <stdlib.h>

typedef struct Node {
    int key;            // Значение элемента
    int npl;            // Расстояние до ближайшего NULL (Null Path Length)
    struct Node *left;
    struct Node *right;
} Node;

// Вспомогательная функция (безопасное получение NPL для NULL)
int get_npl(Node* n) {
    if (n == NULL) return -1;
    return n->npl;
}

// Создание нового узла
Node* createNode(int key) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->key = key;
    newNode->npl = 0; // У листа npl всегда 0
    newNode->left = NULL;
    newNode->right = NULL;
    return newNode;
}
```

---

### 3. Операция Слияния (Merge) — Основа всего

В левосторонней куче **Вставка** и **Удаление** — это просто частные случаи **Слияния**. Поэтому разберем его максимально подробно.

Мы сливаем две кучи: H1 и H2.

Алгоритм:

1. **База:** Если `H1` пуста, вернуть `H2`. Если `H2` пуста, вернуть `H1`.
    
2. **Упорядочивание:** Сравниваем корни. Пусть `H1` — это куча с меньшим корнем. (Если нет, меняем указатели `H1` и `H2` местами).
    
3. **Рекурсия:** Сливаем **правую** ветку `H1` с кучей `H2`. Результат пришиваем обратно к `H1->right`.
    
4. **Восстановление свойства:** После слияния правая ветка могла стать длиннее левой. Проверяем:
    
    - Если `NPL(H1->left) < NPL(H1->right)`, то **меняем местами левого и правого ребенка**.
        
5. **Обновление NPL:** $NPL(H1) = NPL(H1->right) + 1$.
    

**Реализация Merge на C (Слияние с разрушением):**

C

```
void swapChildren(Node* n) {
    Node* temp = n->left;
    n->left = n->right;
    n->right = temp;
}

Node* merge(Node* h1, Node* h2) {
    // 1. Базовые случаи
    if (h1 == NULL) return h2;
    if (h2 == NULL) return h1;

    // 2. Гарантируем, что h1 имеет меньший корень (Min-Heap)
    if (h1->key > h2->key) {
        Node* temp = h1;
        h1 = h2;
        h2 = temp;
    }

    // 3. Рекурсивно сливаем правую ветку с h2
    h1->right = merge(h1->right, h2);

    // 4. Проверяем левостороннее свойство
    if (get_npl(h1->left) < get_npl(h1->right)) {
        swapChildren(h1);
    }

    // 5. Обновляем NPL (всегда по правой ветке, она короче)
    h1->npl = get_npl(h1->right) + 1;

    return h1;
}
```

---

### 4. Остальные операции

#### А) Вставка элемента (Insert)

Вставить элемент — это то же самое, что слить текущую кучу с маленькой кучей, состоящей из одного нового узла.

- **Сложность:** $O(\log N)$.
    

C

```
Node* insert(Node* root, int key) {
    Node* newNode = createNode(key);
    return merge(root, newNode);
}
```

#### Б) Поиск минимума

Минимум всегда в корне (свойство кучи).

- **Сложность:** $O(1)$.
    

C

```
int getMin(Node* root) {
    if (!root) return -1; // Ошибка или код пустоты
    return root->key;
}
```

#### В) Удаление минимума (Delete Min)

1. Запоминаем корень.
    
2. У корня есть два поддерева: Левое и Правое.
    
3. Отцепляем их от корня.
    
4. Удаляем старый корень (`free`).
    
5. Сливаем Левое и Правое поддеревья между собой.
    

- **Сложность:** $O(\log N)$.
    

C

```
Node* deleteMin(Node* root) {
    if (!root) return NULL;

    Node* leftChild = root->left;
    Node* rightChild = root->right;

    free(root); // Освобождаем память корня

    return merge(leftChild, rightChild);
}
```

---

### 5. Слияние с разрушением и без разрушения

Это важный теоретический вопрос в билете.

#### 1. Слияние с разрушением (Destructive Merge)

Это то, что реализовано выше.

- **Суть:** Мы меняем указатели `left` и `right` прямо в узлах исходных деревьев.
    
- **Последствие:** Исходные переменные `h1` и `h2` больше нельзя использовать, они становятся частью новой структуры.
    
- **Плюсы:** Максимальная скорость ($O(\log N)$), никакой дополнительной памяти ($O(1)$).
    
- **Где применяется:** В 99% реальных задач на Си.
    

#### 2. Слияние без разрушения (Non-destructive / Persistent)

Требуется, если нам нужно сохранить историю состояний (например, нам нужна и старая куча `h1`, и новая объединенная).

- **Суть:** Мы не имеем права менять поля `->right` у существующих узлов.
    
- **Реализация:** При каждом шаге рекурсии в `merge`, вместо того чтобы менять ссылку у текущего узла, мы должны **создать копию** текущего узла и менять ссылку уже у копии.
    
- **Сложность:** По времени также $O(\log N)$, но по памяти мы тратим $O(\log N)$ на создание новых узлов вдоль правого пути.
    
- **Полное копирование:** Самый примитивный вариант "без разрушения" — это полная копия деревьев ($O(N)$) и потом слияние.
    

---

### 6. Итоговая таблица сложностей

|**Операция**|**Сложность**|**Пояснение**|
|---|---|---|
|**Поиск Min**|$O(1)$|Корень доступен мгновенно.|
|**Merge**|$O(\log N)$|Проход только по правой ветке, длина которой логарифмическая.|
|**Insert**|$O(\log N)$|Сводится к Merge.|
|**Delete Min**|$O(\log N)$|Сводится к Merge детей корня.|

---

### 7. Полный пример программы (main)

Для защиты билета полезно показать, как это работает в сборе.

C

```
// Очистка памяти (рекурсивно)
void freeHeap(Node* root) {
    if (!root) return;
    freeHeap(root->left);
    freeHeap(root->right);
    free(root);
}

int main() {
    Node* root = NULL;

    // Вставка
    root = insert(root, 3);
    root = insert(root, 10);
    root = insert(root, 8);
    root = insert(root, 21);
    root = insert(root, 1); // 1 станет новым корнем

    printf("Minimum: %d\n", getMin(root)); // Вывод: 1

    // Удаление
    root = deleteMin(root); 
    printf("New Minimum: %d\n", getMin(root)); // Вывод: 3 (следующий по величине)

    freeHeap(root);
    return 0;
}
```

### Резюме для ответа преподавателю:

1. **Главная фишка:** Левосторонняя куча специально "сплюснута" вправо. Правый путь всегда короткий.
    
2. **Зачем нужна:** Обычная куча (на массиве) сливается за $O(N)$. Левосторонняя — за $O(\log N)$. Это критически важно в алгоритмах, где нужно объединять очереди (например, в некоторых графовых алгоритмах).
    
3. **Цена:** Использование дополнительной памяти под указатели и поле `npl` (по сравнению с массивом).