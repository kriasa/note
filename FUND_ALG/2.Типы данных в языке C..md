 Типы данных в языке C. Операции над переменными стандартных типов и их особенности. Операция приведения типов. Арифметические, логические и бинарные операции. Операция быстрого возведения в степень, её алгоритмическая сложность.

### Основы Типов Данных в C

Язык C — это язык со статической, строгой типизацией. **Тип данных** определяет:

1. **Объем памяти**, выделяемый под хранение переменной.
2. **Интерпретацию** хранимых битов (целое, вещественное, символ).
3. **Набор допустимых операций**, которые можно применять к переменной.
    
#### A.  Целочисленные Типы (Integers)

|**Тип**|**Размер (Базовый)**|**Диапазон (Примерный)**|**Примечание**|
|---|---|---|---|
|`char`|1 байт|$-128$ до $127$|Используется для хранения символов (ASCII), но по сути это малое целое число.|
|`short`|$\ge 2$ байта|$\pm 32767$|Короткое целое.|
|`int`|$\ge 2$ (чаще 4) байта|$\pm 2$ миллиарда|Основной целочисленный тип, наиболее эффективный для данной архитектуры.|
|`long`|$\ge 4$ байта|$\pm 9 \cdot 10^{18}$ (если 8 байт)|Длинное целое.|
|`long long`|$\ge 8$ байт|$\approx \pm 9 \cdot 10^{18}$|Самое длинное целое (стандарт C99).|

**Модификаторы (Квалификаторы):**

1. **`signed`** (по умолчанию): Числа со знаком (могут быть отрицательными).
2. **`unsigned`**: Только положительные числа (диапазон смещается, удваивая положительную границу).
3. **`const`**: Переменная не может быть изменена после инициализации.
    
#### B. Вещественные (Плавающая Точка) Типы (Floating-Point)

Используются для представления дробных чисел и хранятся в формате, определенном стандартом IEEE 754.

|**Тип**|**Размер**|**Точность**|**Примечание**|
|---|---|---|---|
|`float`|4 байта|Одинарная (6-7 знаков)|Меньшая точность, быстрее.|
|`double`|8 байтов|Двойная (15-17 знаков)|Стандартный тип для большинства вычислений.|
|`long double`|$\ge 8$ байтов|Расширенная|Максимально возможная точность.|

#### Символьный Тип

- **`char`**: Используется для хранения одного символа. В памяти символ хранится как его ASCII-код (или Unicode-код), т.е. как целое число.

### Особенности Операций и Хранения

- **Переполнение (Overflow):**
    
    - **Целочисленные типы:** При выполнении операции, результат которой превышает максимальное значение типа (например, $127 + 1$ для `signed char`), происходит **переполнение**. Поведение `signed` типов при переполнении **не определено** (Undefined Behavior, UB), что может привести к непредсказуемым результатам (чаще всего это "переворот" знака). Переполнение `unsigned` типов **определено** и происходит по модулю, т.е. $255 + 1 = 0$ для 8-битного `unsigned char`.
        
    - **Вещественные типы:** При переполнении (слишком большое число) возникает **Infinity** (бесконечность). При потере точности (слишком маленькое число) — **Zero** (ноль).
        
- **Потеря Точности (Precision Loss):** Происходит при работе с вещественными типами. Невозможно точно представить все действительные числа. Например, $0.1$ в десятичной системе не имеет точного представления в двоичной системе. Сравнение вещественных чисел (через `==`) — **опасная операция**.

``` c
#include <math.h>

#define EPS 1e-9

if (fabs(a - b) < EPS) {
    // считаем равными
}
```

- **Деление Целых Чисел:** Операция `/` между двумя целыми числами дает **целочисленный результат** (отбрасывается дробная часть), а не вещественный. (Пример: `5 / 2 == 2`).

## Проблемы точности вещественных чисел

### Ошибки округления
Не все десятичные числа можно точно представить в двоичной системе
### Сравнение вещественных чисел
Такие сравнения производятся только как разность по модулю `fabs(a - b) < EPS`
### Потеря значимости
При операциях с числами разного масштаба:
``` c
double a = 1e20;
double b = 1.0;
double c = a + b;
\\ c == 1e20
```

### Операции над переменными

#### Арифметические операции

**Основные операторы:**
- `+` — сложение
- `-` — вычитание
- `*` — умножение
- `/` — целочисленно деление (floor div)
- `%` — остаток от деления (только для целых чисел)

**Особенности:**
```c
int a = 7, b = 3;
int result1 = a / b;      // result1 = 2 (целочисленное деление)
float result2 = a / b;    // result2 = 2.0 (оба операнда int)
float result3 = (float)a / b;  // result3 = 2.333... (явное приведение типа)

int c = -7;
int result4 = c % 3;      // result4 = -1 (знак как у делимого)
```

**Инкремент и декремент:**

- `++` — увеличение на 1 (prefix: `++i` или postfix: `i++`)
- `--` — уменьшение на 1

```c
int x = 5;
int y = ++x;  // x = 6, y = 6 (сначала увеличение)
int z = x++;  // x = 7, z = 6 (сначала присваивание)
```

### Логические операции

**Операторы сравнения:**
- `==` — равно
- `!=` — не равно
- `<`, `>` — меньше, больше
- `<=`, `>=` — меньше или равно, больше или равно

**Логические операторы:**
- `&&` — логическое И (AND)
- `||` — логическое ИЛИ (OR)
- `!` — логическое НЕ (NOT)

**Особенности:**
```c
int a = 5, b = 0;
if (a && b) { }  // false, b == 0
if (a || b) { }  // true, a != 0

// Короткое замыкание (short-circuit evaluation)
if (b != 0 && a / b > 2) { }  // второе условие не проверяется, если b == 0
```
В C любое ненулевое значение считается истинным, 0 — ложным.

### Битовые (бинарные) операции

Работают на уровне отдельных битов целых чисел:
- `&` — побитовое И (AND)
- `|` — побитовое ИЛИ (OR)
- `^` — побитовое исключающее ИЛИ (XOR)
- `~` — побитовое НЕ (NOT, инверсия)
- `<<` — сдвиг влево
- `>>` — сдвиг вправо

**Примеры:**
```c
unsigned int a = 12;  // 1100 в двоичной системе
unsigned int b = 10;  // 1010 в двоичной системе

unsigned int c = a & b;   // 1000 = 8
unsigned int d = a | b;   // 1110 = 14
unsigned int e = a ^ b;   // 0110 = 6
unsigned int f = ~a;      // инверсия всех битов

unsigned int g = a << 2;  // 110000 = 48 (умножение на 2²)
unsigned int h = a >> 1;  // 110 = 6 (деление на 2)
```

**Практическое применение:**
```c
// Проверка чётности
if (n & 1) { /* нечётное */ }

// Умножение/деление на степени двойки
int fast_mult = n << 3;  // n * 8
int fast_div = n >> 2;   // n / 4

// Установка/сброс битов
int flags = 0;
flags |= (1 << 3);   // установить 3-й бит
flags &= ~(1 << 3);  // сбросить 3-й бит
```

---
### Приведение типов (Type Casting)

### Неявное приведение (Implicit Casting)

Происходит автоматически при операциях с разными типами. Применяются правила продвижения типов:

1. Если один операнд `long double`, другой преобразуется в `long double`
2. Иначе если один `double`, другой в `double`
3. Иначе если один `float`, другой в `float`
4. Иначе применяется целочисленное продвижение (char, short → int)
5. Если типы различаются, меньший преобразуется в больший
```c
int a = 10;
float b = 3.5;
float result = a + b; // a неявно преобразуется в float
```

### Явное приведение (Explicit Casting)
```c
int a = 10, b = 3;
float result = (float)a / b;  // 3.333...

// Без приведения
float wrong = a / b;  // 3.0 (целочисленное деление, затем преобразование)

// Потеря данных при приведении к меньшему типу
double pi = 3.14159;
int truncated = (int)pi;  // 3 (дробная часть отбрасывается)
```
Может привести к переполнению.

### Операция быстрого возведения в степень

### Быстрое возведение в степень — O(log n)

Основан на принципе "разделяй и властвуй" и бинарном представлении показателя степени:

**Принцип:**

- Если exp чётное: base^exp = (base²)^(exp/2)
- Если exp нечётное: base^exp = base × base^(exp-1)

**Итеративная реализация:**
```c
long long fast_power(long long base, long long exp) {
	long long result = 1;
	
	while (exp > 0) {
		if (exp & 1) {
			result *= base;
		}
		
		base *= base;
		exp >>= 1;
	}
	return result;
}
```

### Пусть:

`base = 2 exp = 13 (1101₂)`

|Итерация|exp|exp&1|result|base|
|---|---|---|---|---|
|1|13|1|2|4|
|2|6|0|2|16|
|3|3|1|32|256|
|4|1|1|8192|65536|
|5|0|—|стоп|—|

✔️ Ответ: `8192 = 2¹³`
#### 1. Алгоритм и Назначение

**Задача:** Вычислить $b^n$ (основание $b$, показатель $n$) за минимальное число умножений.

**Наивный подход:** Использование цикла требует $e$ умножений. Сложность: $O(n)$

**Быстрое возведение в степень (Binary Exponentiation):** Использует двоичное представление показателя $n$. Если $n = e_k e_{k-1} \dots e_0$ в двоичной системе, то:

$$b^e = b^{e_0 \cdot 2^0 + e_1 \cdot 2^1 + \dots + e_k \cdot 2^k} = b^{e_0 \cdot 2^0} \cdot b^{e_1 \cdot 2^1} \cdot \dots \cdot b^{e_k \cdot 2^k}$$

Алгоритм работает за счет двух ключевых операций:

1. Умножение результата: происходит, только если соответствующий бит $n$ равен 1.
2. Квадрирование базы: $b \leftarrow b^2$ на каждой итерации.

#### 2. Алгоритмическая Сложность

Сложность алгоритма быстрого возведения в степень составляет:

$$O(\log_2 n)$$

Обоснование:

В каждой итерации цикла показатель $e$ делится на 2 (операция exp /= 2 в итеративной версии), что соответствует обработке одного бита $n$. Количество итераций равно количеству битов в $n$, то есть $\log_2 n$.

Это значительно эффективнее, чем $O(n)$, и является критически важным алгоритмом в криптографии (например, при модульном возведении в степень).
