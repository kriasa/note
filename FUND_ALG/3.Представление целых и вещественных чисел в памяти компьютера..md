Форматы представления целых и вещественных чисел в памяти компьютера.

## Беззнаковые целые числа (unsigned)

Представляются в обычной двоичной системе счисления. Все биты используются для хранения значения.

**Пример для 8 бит:**
```
Число 173 = 10101101₂

Бит:     7  6  5  4  3  2  1  0
Значение: 1  0  1  0  1  1  0  1
Вес:    128 64 32 16  8  4  2  1

173 = 128 + 32 + 8 + 4 + 1
```

**Диапазоны:**
- 8 бит (unsigned char): 0 до 255
- 16 бит (unsigned short): 0 до 65,535
- 32 бит (unsigned int): 0 до 4,294,967,295
### Знаковые целые числа (signed)

Принципы кодирования:

- Прямой код: Первый бит — знак (0 для положительного, 1 для отрицательного). Проблема: два представления для нуля.(+0 -0) 

- Обратный код: Инвертирование всех бит для отрицательных чисел. Проблема: два представления для нуля. 

- Дополнительный код (используется в современных системах)

#### Прямой код

> **Прямой код** - способ представления двоичных чисел с фиксированной запятой. Главным образом используется для записи неотрицательных чисел

**Прямой код** используется в двух вариантах.  

**В первом (основной) - для записи только неотрицательных чисел:*

**Второй вариант - для записи как положительных, так и отрицательных чисел**.  
В этом случае старший бит (в нашем случае - восьмой) объявляется знаковым разрядом (знаковым битом).  
При этом, если:  
- знаковый разряд равен 0, то число положительное  
- знаковый разряд равен 1, то число отрицательное

В этом случае диапазон десятичных чисел, которые можно записать в прямом коде составляет от - 127 до +127:

---
_Прямой код используется главным образом для представления неотрицательных чисел._  
 _Использование прямого кода для представления отрицательных чисел является неэффективным - очень сложно реализовать арифметические операции и, кроме того, в прямом коде два представления нуля - положительный ноль и отрицательный ноль (чего не бывает):_
 ---
#### Обратный код

**Для неотрицательных чисел обратный код** двоичного числа имеет тот же вид, что и запись неотрицательного числа в прямом коде.  

**Для отрицательных чисел обратный код** получается из неотрицательного числа в прямом коде, путем инвертирования всех битов (1 меняем на 0, а 0 меняем на 1).  

Для преобразования отрицательного числа записанное в обратном коде в положительное достаточного его проинвертировать.
![[Pasted image 20251214231029.png]]

Диапазон десятичных чисел, который можно записать в обратном коде от -127 до + 127

---
#### Дополнительный код

самый распространённый способ представления отрицательных чисел.

**Старший бит (знаковый бит):**
- 0 — положительное число
- 1 — отрицательное число

**Принцип дополнительного кода:**
Для положительных чисел — обычная двоичная запись.

Для отрицательных чисел:
1. Взять модуль числа в двоичной форме
2. Инвертировать все биты
3. Прибавить 1

**Пример для 8 бит:**
```
+5 = 00000101

-5:
Шаг 1: |5| = 00000101
Шаг 2: инверсия = 11111010
Шаг 3: +1 = 11111011

Проверка: 11111011 = -5
```

**Диапазоны для signed:**

- 8 бит (char): -128 до 127
- 16 бит (short): -32,768 до 32,767
- 32 бит (int): -2,147,483,648 до 2,147,483,647

**Преимущества дополнительного кода:**

1. Единственное представление нуля (00000000)
2. Сложение и вычитание работают одинаково для положительных и отрицательных чисел
3. Простая аппаратная реализация
```
// Пример: 5 + (-3) = 2
  00000101  (+5)
+ 11111101  (-3)
----------
  00000010  (+2)  // переполнение старшего бита игнорируется
```


## Представление вещественных чисел

Вещественные числа (`float`, `double`) хранятся в памяти согласно международному стандарту **IEEE 754**. Этот формат использует принцип **научной (плавающей) нотации**, что позволяет представлять очень широкий диапазон чисел, жертвуя при этом абсолютной точностью.

Число $X$ представляется в виде:

$$X = (-1)^S \cdot M \cdot 2^E$$

где:

- S — знак числа (0 для положительных, 1 для отрицательных). 
- M — мантисса (дробная часть числа). 
- E — порядок (степень двойки).

**Мантисса** хранит дробную часть числа в двоичной системе счисления. При записи числа с плавающей точкой оно нормализуется так, чтобы в старшем разряде перед дробной частью всегда стояла единица
![[Pasted image 20251214232434.png]]

#### Порядок 

Порядок указывает степень двойки, на которую нужно умножить нормализованное число. Для хранения порядка используется несколько бит

Порядок хранится не напрямую, а со сдвигом (bias), чтобы обеспечить хранение как положительных, так и отрицательных степеней двойки.
### Структура Форматов IEEE 754

| **Формат**    | **Тип C** | **Общий размер** | **Знак (S)** | **Экспонента (E)** | **Мантисса (M)** | **Bias (Смещение)** |
| ------------- | --------- | ---------------- | ------------ | ------------------ | ---------------- | ------------------- |
| **Одинарная** | `float`   | 32 бита          | 1 бит        | 8 бит              | 23 бита          | 127                 |
| **Двойная**   | `double`  | 64 бита          | 1 бит        | 11 бит             | 52 бита          | 1023                |
### Float (32 бита) — одинарная точность

| Тип      | Биты | Знак | Порядок | Мантисса |
| -------- | ---- | ---- | ------- | -------- |
| `float`  | 32   | 1    | 8       | 23       |
| `double` | 64   | 1    | 11      | 52       |

**Компоненты:**
- **Знак (S):** 1 бит (0 = положительное, 1 = отрицательное)
- **Экспонента (E):** 8 бит, смещение 127 (bias)
- **Мантисса (M):** 23 бита, неявная единица

**Формула:**
```
Значение = (-1)^S × (1.M) × 2^(E-127)
```

**Пример: представление числа 12.375**
```
12.375₁₀ = 1100.011₂ = 1.100011₂ × 2³

S = 0 (положительное)
E = 3 + 127 = 130 = 10000010₂
M = 10001100000000000000000₂ (без первой единицы)

Результат:
0 10000010 10001100000000000000000
```

### Double (64 бита) — двойная точность

| Тип      | Биты | Знак | Порядок | Мантисса |
| -------- | ---- | ---- | ------- | -------- |
| `float`  | 32   | 1    | 8       | 23       |
| `double` | 64   | 1    | 11      | 52       |
**Компоненты:**
- **Знак:** 1 бит
- **Экспонента:** 11 бит, смещение 1023
- **Мантисса:** 52 бита

**Формула:**
```
Значение = (-1)^S × (1.M) × 2^(E-1023)
```

**Денормализованные числа:**

Когда экспонента = 0, но мантисса ≠ 0:
```
Значение = (-1)^S × (0.M) × 2^(-126) для float
```

- **E = 0, M = 0** → в мантиссе **ничего**, экспонента **минимальная** → это ноль
- **E = max, M = 0** → экспонента **максимальная**, мантисса **ноль** → бесконечность
- **E = max, M ≠ 0** → экспонента **максимальная**, но мантисса **не ноль** → значит это _не число_ → NaN


