Функции. Способы передачи аргументов в функции. Возврат значений из функции через возвращаемое значение, через параметры функции. Глобальные и локальные переменные. Область видимости переменных. Модификатор static.


# 1. Функции — основные понятия

**Функция** — это именованный блок кода, который выполняет определенную задачу и может быть вызван из других частей программы. Функция является основной единицей модульности в C.

**Сигнатура функции** включает:
- Тип возвращаемого значения
- Имя функции
- Список параметров с их типами

```c
тип_возвращаемого_значения имя_функции(параметры) { // Тело функции 
return значение; // Необязательно, если тип возвращаемого значения void }
```

**Объявление (declaration)** vs **Определение (definition)**:
- Объявление (прототип) сообщает компилятору о существовании функции:`int calculate(int a, double b);`
- Определение содержит тело функции с реализацией

# 2. Способы передачи аргументов в функции
### 2.1. Передача по значению (pass by value)

**В C существует ТОЛЬКО передача по значению.** Это фундаментальный принцип языка.

- **Принцип:** В функцию передается **копия** фактического значения аргумента.
- **Действие:** Функция работает с этой копией, размещенной в своем локальном стеке.
- **Следствие:** Изменение параметра внутри функции **не влияет** на оригинальную переменную в вызывающей функции.

```c
void increment(int x) { // x — это копия
    x = x + 1; 
    // Оригинальная переменная, переданная в качестве x, не изменится
}
```
### 2.2. По указателю

- **Принцип:** В функцию передается **адрес памяти** оригинальной переменной (т.е., указатель на нее).
- **Действие:** Функция использует оператор разыменования (`*`) для доступа и модификации данных, хранящихся по этому адресу.
- **Следствие:** Изменение значения через разыменованный указатель **непосредственно изменяет** оригинальную переменную в вызывающей функции.
**Преимущество:**

- Позволяет функции **"возвращать" несколько значений** или модифицировать большие структуры/массивы без необходимости их полного копирования.

```c
void increment(int *x) { 
    (*x)++; 
} 

int main() { 
    int a = 5; 
    increment(&a); 
    printf("Value: %d\n", a); 
    return 0; 
} 
Вывод: Value: 6
```


# 3. Возврат значений из функции

Функции в C имеют два основных способа передачи результатов обратно вызывающей стороне:
### 3.1. Через возвращаемое значение (return)
**Ограничения:**

- Нельзя возвращать адрес локальной переменной (она уничтожается при выходе из функции)
- - **Назначение:** Возвращает **одно** значение, тип которого указан в заголовке функции (кроме `void`).
- **Механизм:** Значение копируется из локального стека функции в стек вызывающей функции.
- **Ограничение:** Невозможно вернуть массив или структуру большого размера эффективно (будет копирование), и можно вернуть **только одно скалярное значение**.

```c
int square(int x) { 
    return x * x; 
}
int main() { 
    int result = square(4); 
    printf("Result: %d\n", result); 
    return 0; 
} 
Вывод: Result: 16
```

### 3.2. Через параметры функции (output parameters) по указателю
Используется для возврата **нескольких значений** или больших структур данных:

**Преимущества:**
- **Назначение:** Используется, когда необходимо **вернуть более одного значения** или модифицировать большие структуры/массивы.
- **Механизм:** Функция принимает **указатель** на переменную, которая находится в памяти вызывающей функции.
- **Действие:** Функция использует оператор разыменования (`*`) для записи нового значения напрямую по этому адресу. и локальные переменные

```c
void divide(int a, int b, int *quotient, int *remainder) { 
    *quotient = a / b; 
    *remainder = a % b; 
} 
int main() { 
    int q, r; 
    divide(10, 3, &q, &r); 
    printf("Quotient: %d, Remainder: %d\n", q, r); 
    return 0; 
} 
Вывод: Quotient: 3, Remainder: 1
```
### 4.1. Локальные переменные (automatic variables)

**Локальные переменные:**

- -**Область видимости:** Видимы только внутри блока кода (`{ ... }`), в котором они объявлены (например, внутри функции или цикла).
- **Время жизни (Storage Duration):** Автоматическое. Создаются при входе в блок и **уничтожаются** при выходе из него (хранятся в стеке).
- **Инициализация:** **Не инициализируются** автоматически. Содержат "мусорные" значения, если не инициализированы явно.

```c
void func() {
    int x;  // локальная переменная, содержит неопределённое значение
    int y = 10;  // явная инициализация
}
```
**Время жизни** — от момента объявления до конца блока.
### 4.2. Глобальные переменные
**Глобальные переменные:**

- **Область видимости:** Определяются **вне всех функций** и видны с места их объявления до конца файла.
- **Время жизни:** Статическое. Создаются при запуске программы и **существуют до ее завершения** (хранятся в секции данных).
- **Инициализация:** **Автоматически инициализируются нулем** (или `NULL`), если не инициализированы явно.
- **Рекомендация:** Следует избегать глобальных переменных, так как они усложняют отладку и нарушают принцип инкапсуляции.
- Видны во всех файлах (если не static)

```c
int global = 100;  // глобальная переменная

void func() {
    global++;  // доступна везде
}
```

**Недостатки глобальных переменных:**
- Усложняют отладку
- Создают скрытые зависимости между функциями
- Проблемы с многопоточностью
- Затрудняют повторное использование кода
# 5. Область видимости переменных (scope)

**Область видимости** определяет ту часть программы, где переменная доступна (видима) по своему имени.
### 5.1. Блочная область видимости
```c
int main() {
    int x = 1;
    {
        int x = 2;  // это другая переменная, скрывает внешнюю
        printf("%d\n", x);  // 2
    }
    printf("%d\n", x);  // 1
}
```
Внутренняя переменная **затеняет** (shadows) внешнюю.
### 5.2. Область видимости файла (file scope)
Переменные, объявленные вне функций, имеют область видимости файла:
```c
int file_var;  // видна во всём файле, начиная с точки объявления

void func1() {
    file_var = 10;  // OK
}
```
### 5.3. Правило: переменная видна от точки объявления до конца блока
```c
void example() {
    // x здесь ещё не существует
    int x = 5;
    // x существует отсюда
    {
        int y = x;  // x видна
        // y существует только в этом блоке
    }
    // y здесь больше не существует
}
```

# 6. Модификатор static

Модификатор `static` изменяет либо время жизни переменной, либо область ее видимости.

Модификатор `static` имеет **разное значение** в зависимости от контекста:
### 6.1. static для локальных переменных

Локальная переменная, объявленная с модификатором static , сохраняет своё значение между вызовами функции. В отличие от обычных локальных переменных, которые создаются и уничтожаются каждый раз при входе и выходе из функции, статическая переменная инициализируется только один раз, а её значение сохраняется в памяти до конца программы

**static локальная переменная:**
- Размещается в **сегменте данных**, а не в стеке
- Инициализируется **один раз** при первом вызове функции
- **Сохраняет значение** между вызовами функции
- Область видимости остаётся локальной
```c
void counter() {
    static int count = 0;  // инициализируется один раз
    count++;
    printf("%d\n", count);
}

int main() {
    counter();  // 1
    counter();  // 2
    counter();  // 3
}
```

**Без static:**
```c
void counter() {
    int count = 0;  // создаётся заново каждый раз
    count++;
    printf("%d\n", count);  // всегда 1
}
```

### 6.2. static для глобальных переменных и функций

Глобальная переменная с модификатором static ограничивает свою область видимости только текущим файлом. Это позволяет предотвратить конфликт имён, если другие файлы программы используют глобальные переменные с такими же именами

**static глобальная переменная/функция:**
- Ограничивает область видимости **текущим файлом** (единицей трансляции)
- Реализует **внутреннее связывание** (internal linkage)

Функция, объявленная с модификатором static , также ограничивает свою область видимости текущим файлом. Это полезно для создания функций, которые используются только внутри конкретного модуля или файла, и не должны быть видны за его пределами.

```c
// file1.c
static int secret = 42;  // видна только в file1.c

static void helper() {  // видна только в file1.c
    // ...
}
```

```c
// file2.c
extern int secret;  // ОШИБКА компоновки! secret имеет internal linkage
```

**Без static (external linkage):**
```c
// file1.c
int shared = 100;  // видна во всех файлах

// file2.c
extern int shared;  // OK, получаем доступ
```

Если в другом файле будет объявлена переменная с таким же именем globalVar , они не будут конфликтовать, потому что каждая из них видна только в своём файле

---

Переменные, объявленные с модификатором static , размещаются в статической области памяти (static storage), а не в стеке. Это означает: Память выделяется один раз за время выполнения программы. Такие переменные и функции существуют до завершения программы.

---
### 6.3. Практическое применение static

**1. Инкапсуляция в C:**
```c
// module.c
static int internal_state;  // приватное состояние модуля

static void internal_helper() {  // приватная функция
    // ...
}

void public_api() {  // публичная функция (не static)
    internal_helper();
}
```

**2. Избежание конфликтов имён:**
```c
// file1.c
static void init() { /* ... */ }

// file2.c
static void init() { /* ... */ }  // OK, разные функции
```


**Ключевые моменты для зачёта:**

- В C только передача по значению
- Указатели эмулируют передачу по ссылке
- static меняет время жизни (для локальных) или связывание (для глобальных)
- Локальные переменные НЕ инициализируются автоматически
- Глобальные переменные инициализируются нулями
- Массивы деградируют до указателей при передаче