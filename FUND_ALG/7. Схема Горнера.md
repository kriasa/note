Конвертация чисел из строки и в строку. Схема Горнера и обратная схеме Горнера для преобразования строкового представления числа, записанного в заданной системе счисления, в значение целочисленного типа и наоборот; алгоритмическая сложность и реализация на языке C. 

| Операция       | Алгоритм       | Временная сложность  | Пространственная сложность |
| -------------- | -------------- | -------------------- | -------------------------- |
| Строка → Число | Схема Горнера  | O(n)                 | O(1)                       |
| Число → Строка | Обратная схема | $O(log_{base}(num))$ | $O(log_{base}(num))$       |
## Преобразование Строки в Число (String to Integer)

Эта задача эквивалентна вычислению значения многочлена, заданного его коэффициентами. Для эффективного решения используется **Схема Горнера**.
### Что такое схема Горнера?

**Схема Горнера** — эффективный алгоритм вычисления значения многочлена и преобразования числа из строки в целочисленное значение.

**Принцип:** Число в системе счисления с основанием b можно представить как: 
``` n = a₀ + a₁·b + a₂·b² + a₃·b³ + ... + aₖ·bᵏ ``` 
**Схема Горнера переписывает это как:** 
``` n = a₀ + b·(a₁ + b·(a₂ + b·(a₃ + ... + b·aₖ))) ```
###### Пример для "1234" в десятичной системе: 
``` python
Обычно: 1234 = 4 + 3·10 + 2·10² + 1·10³ = 4 + 30 + 200 + 1000
Схема Горнера (справа налево):
 1234 = 1
 1234 = 1·10 + 2 = 12
 1234 = 12·10 + 3 = 123
 1234 = 123·10 + 4 = 1234 
``` 
### Алгоритм схемы Горнера 

Итеративно обновляем текущее значение, используя следующий символ (цифру) строки:

1. Начальное значение `result` = 0.
2. Для каждой цифры d в строке (слева направо):
    
$$\text{result} = \text{result} \cdot B + d$$

**Алгоритмическая Сложность:**

- **$O(L)$**, где $L$ — длина входной строки.
    
- **Обоснование:** Алгоритм проходит по каждому символу строки ровно один раз. На каждой итерации выполняется одно умножение и одно сложение, что делает сложность линейной по длине числа. Это наиболее эффективный способ.

```c
#include <stdio.h>
#include <ctype.h>
#include <string.h>

// === СХЕМА ГОРНЕРА: строка -> число ===

int char_to_digit(char c) {
    if (c >= '0' && c <= '9') return c - '0';
    if (c >= 'a' && c <= 'z') return c - 'a' + 10;
    if (c >= 'A' && c <= 'Z') return c - 'A' + 10;
    return -1;
}

long long str_to_num(const char *str, int base) {
    if (str == NULL || base < 2 || base > 36) return 0;
    
    long long result = 0;
    int sign = 1;
    
    while (isspace(*str)) str++;
    
    if (*str == '-') {
        sign = -1;
        str++;
    } else if (*str == '+') {
        str++;
    }
    
    while (*str != '\0') {
        int digit = char_to_digit(*str);
        if (digit < 0 || digit >= base) break;
        
        result = result * base + digit;  // СХЕМА ГОРНЕРА
        str++;
    }
    
    return sign * result;
}
```

### Обратная Схема Горнера (Последовательное Деление)

1. Математическая Основа:

Любое число $N$ в системе счисления $B$ можно представить как:

$$N = Q \cdot B + R$$

Где $R$ — это остаток от деления ($N \pmod B$), который всегда равен младшей цифре ($d_0$) числа $N$.

Новое частное $Q$ становится новым числом, и процесс повторяется до тех пор, пока частное не станет нулем.

**2. Алгоритм:**

Итеративно извлекаем цифры числа $N$ (справа налево):

1. Повторять, пока $N > 0$:
    
    - **Получить цифру:** $d = N \pmod B$ (остаток).
    - **Обновить число:** $N = N / B$ (частное).
        
2. Цифры $d$ получаются в порядке $d_0, d_1, d_2, \dots$ (то есть, в обратном порядке). Полученную последовательность необходимо **перевернуть**.
    
**3. Алгоритмическая Сложность:**

- **$O(\log_B N)$**, где $N$ — величина числа.
    
- **Обоснование:** Количество итераций цикла пропорционально количеству цифр в числе. Поскольку количество цифр в числе $N$ в системе $B$ равно $\approx \log_B N$, сложность является логарифмической. Это также наиболее эффективный способ.

```c

// === ОБРАТНАЯ СХЕМА: число -> строка ===

char digit_to_char(int digit) {
    if (digit >= 0 && digit <= 9) return '0' + digit;
    if (digit >= 10 && digit <= 35) return 'A' + (digit - 10);
    return '?';
}

void num_to_str(long long num, int base, char *result) {
    if (result == NULL || base < 2 || base > 36) return;
    
    if (num == 0) {
        strcpy(result, "0");
        return;
    }
    
    int is_negative = 0;
    if (num < 0) {
        is_negative = 1;
        num = -num;
    }
    
    int pos = 0;
    
    // Извлечение цифр (обратная схема)
    while (num > 0) {
        int digit = num % base;
        result[pos++] = digit_to_char(digit);
        num /= base;
    }
    
    if (is_negative) {
        result[pos++] = '-';
    }
    
    result[pos] = '\0';
    
    // Переворот строки
    for (int i = 0; i < pos / 2; i++) {
        char temp = result[i];
        result[i] = result[pos - 1 - i];
        result[pos - 1 - i] = temp;
    }
}
```
