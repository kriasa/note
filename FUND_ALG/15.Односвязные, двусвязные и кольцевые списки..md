Списочные структуры данных. Односвязные, двусвязные и кольцевые списки. Вычислительные сложности операций доступа к элементу (по индексу/значению), вставки/удаления элементов для списков соответствующего типа, их реализация на языке C.

**Списочная структура (Linked List)** — это динамическая структура данных, состоящая из набора узлов (Node), где каждый узел хранит само значение и **указатель** на следующий (и/или предыдущий) узел в последовательности.В отличие от массивов, размер списка не фиксирован, и его элементы могут быть разбросаны в памяти

Типы связных списков 

1. Односвязный список (Singly Linked List): Каждый узел содержит данные и указатель на следующий узел. Последний узел указывает на NULL . 

2. Двусвязный список (Doubly Linked List): Каждый узел содержит данные, указатель на следующий и предыдущий узел. Первый узел ( head ) указывает на Последний узел ( NULL в поле предыдущего. tail ) указывает на NULL в поле следующего. 

3. Кольцевой список (Circular Linked List): Узлы соединены в кольцо. В односвязном кольцевом списке последний узел указывает на первый. В двусвязном кольцевом списке head и tail связаны между собой.
## Односвязный список (Singly Linked List)
### Структура узла
```c
typedef struct Node {
    int data;              // полезная нагрузка
    struct Node *next;     // указатель на следующий узел
} Node;
```
**Важная деталь:** Используем `struct Node *next` внутри определения, так как в момент объявления `typedef` еще не завершен, и имя `Node` еще не доступно.
### Сложности операций

| Операция               | Сложность                          | Комментарий                                  |
| ---------------------- | ---------------------------------- | -------------------------------------------- |
| Доступ по индексу      | **O(n)**                           | Необходим последовательный обход от головы   |
| Поиск по значению      | **O(n)**                           | В худшем случае — полный проход              |
| Вставка в начало       | **O(1)**                           | Просто меняем указатель головы               |
| Вставка в конец        | **O(n)** без tail, **O(1)** с tail | Без хранения указателя на хвост нужен проход |
| Вставка после узла     | **O(1)**                           | Если уже имеем указатель на узел             |
| Удаление из начала     | **O(1)**                           | Перенаправляем head                          |
| Удаление произвольного | **O(n)**                           | Нужен доступ к **предыдущему** узлу          |

### Критическая особенность удаления

В односвязном списке для удаления узла нужен указатель на **предыдущий** узел, так как необходимо изменить его `next`. Это фундаментальное ограничение архитектуры.
### Реализация ключевых операций
```c
struct Node { 
    int data; // может быть и другой тип данных 
    struct Node *pNext; 
}; 
//Объявление 
struct Node *pHead = NULL;

//Создание элемента списка 
struct Node* Create(int data){ 
    struct Node *ptr = NULL; 
    ptr = (struct Node *) malloc(sizeof(struct Node); 
    // обязательно проверка маллока 
    // для этого менять способ реализации, например возвращать код ошибки. 
    ptr->data = data; 
    ptr->pNext = NULL; 
    return ptr; 
} 
//Добавление элемента 
void Insert(struct Node *pNode, struct Node * newNode){ 
    newNode->pNext = pNode->Next; 
    pNode->pNext = newNode; 
} 
//Добавление элемента в начало списка 
void PushFront(struct Node **pHead, struct Node *newNode){ 
    newNode->pNext = *pHead; 
    *pHead = newNode; 
    // pHead = PushFront(pHead, NewN);использование функции
} 
//Удаление элемента 
void Delete(struct Node *pNode){ 
    struct Node * ptr; 
    ptr = pNode->pNext; 
    pNode->pNext = ptr->pNext; 
    // pNode->pNext = pNode->pNext->pNext так можно но не нужно 
    free(ptr); 
} 

void Delete(struct Node **pHead, struct Node *pNode) { 
    if (*pHead == NULL || pNode == NULL) { 
        return; // Нечего удалять 
    } 
    if (*pHead == pNode) { // Удаляем голову списка 
        *pHead = pNode->pNext; 
        free(pNode); 
        return; 
    } 
    // Ищем узел, предшествующий 
    pNode struct Node *current = *pHead; 
    while (current != NULL && current->pNext != pNode) { 
        current = current->pNext; 
    } 
    if (current == NULL) { 
        return; // Узел не найден в списке 
    } 
    // Удаляем pNode 
    current->pNext = pNode->pNext; 
    free(pNode); 
} 

//Удаление из начала списка 
struct Node * ptr = pHead; 
pHead = pHead->pNext; 
free(ptr); // Можно попробовать сделать метод 

//Обход списка 
ptr = pHead; 
while(ptr != NULL) { 
    printf("%d\n", ptr->data); 
    ptr = ptr->pNext; 
}
```

## Двусвязный список (Doubly Linked List)
### Структура узла
```c
typedef struct DNode {
    int data;
    struct DNode *next;
    struct DNode *prev;    // обратная связь!
} DNode;
```

### Преимущества над односвязным
1. **Двунаправленный обход** — можем идти как вперед, так и назад
2. **Удаление за O(1)** — имея указатель на узел, можем удалить его без поиска предыдущего
3. **Более гибкие операции** — вставка перед узлом становится тривиальной
### Сложности операций
| Операция               | Сложность | Отличие от односвязного                       |
| ---------------------- | --------- | --------------------------------------------- |
| Доступ по индексу      | **O(n)**  | Можем оптимизировать: идти с ближайшего конца |
| Поиск по значению      | **O(n)**  | Аналогично                                    |
| Вставка в начало/конец | **O(1)**  | С head и tail                                 |
| Вставка до/после узла  | **O(1)**  | **Преимущество!**                             |
| Удаление узла          | **O(1)**  | **Ключевое преимущество!** Не нужен prev      |
### Реализация удаления узла — O(1)
```c
// Удаление узла, если имеем указатель на него - O(1)
// Это НЕВОЗМОЖНО в односвязном списке!
void delete_node(DNode **head, DNode *node) {
    if (node == NULL) return;
    
    // Перелинковываем соседей
    if (node->prev != NULL)
        node->prev->next = node->next;
    else
        *head = node->next;  // удаляем голову
    
    if (node->next != NULL)
        node->next->prev = node->prev;
    
    free(node);
}

// Вставка после узла - O(1)
void insert_after(DNode *node, int value) {
    if (node == NULL) return;
    
    DNode *new_node = (DNode*)malloc(sizeof(DNode));
    if (!new_node) return;
    
    new_node->data = value;
    new_node->next = node->next;
    new_node->prev = node;
    
    if (node->next != NULL)
        node->next->prev = new_node;
    
    node->next = new_node;
}
```

![[Pasted image 20251216010352.png]]
## Кольцевой список (Circular Linked List)

### Концепция

Последний узел указывает не на `NULL`, а на **первый** узел, образуя цикл. Может быть реализован как на базе односвязного, так и двусвязного списка.

### Структура (односвязная кольцевая версия)

```c
typedef struct CNode {
    int data;
    struct CNode *next;  // last->next указывает на first!
} CNode;
```

**Критическая деталь:** Часто храним указатель не на `head`, а на **`tail`** (последний элемент), так как `tail->next` дает доступ к голове за O(1), и вставка в конец также O(1).

### Особенности работы

1. **Условие завершения обхода** — не `current != NULL`, а `current != start` (после первого прохода)
2. **Пустой список** — указатель равен `NULL`, а не указывает сам на себя (обычная конвенция)
3. **Вставка в начало и конец** — обе O(1) при хранении `tail`

### Сложности операций

|Операция|Сложность|Особенность|
|---|---|---|
|Вставка в начало|**O(1)**|С tail: `new->next = tail->next; tail->next = new`|
|Вставка в конец|**O(1)**|`insert_after(tail); tail = new_node`|
|Доступ/поиск|**O(n)**|Аналогично обычному списку|
|Удаление|**O(n)**|Нужен предыдущий узел (для односвязного)|

### Реализация обхода

```c
// Обход кольцевого списка - O(n)
void traverse(CNode *tail) {
    if (tail == NULL) return;
    
    CNode *start = tail->next;  // голова списка
    CNode *current = start;
    
    do {
        printf("%d ", current->data);
        current = current->next;
    } while (current != start);  // НЕ current != NULL!
    
    printf("\n");
}

// Вставка в конец - O(1)
CNode* insert_end(CNode *tail, int value) {
    CNode *new_node = (CNode*)malloc(sizeof(CNode));
    if (!new_node) return tail;
    
    new_node->data = value;
    
    if (tail == NULL) {
        // Первый элемент - указывает сам на себя
        new_node->next = new_node;
        return new_node;
    }
    
    new_node->next = tail->next;  // новый указывает на голову
    tail->next = new_node;        // старый хвост указывает на новый
    return new_node;              // новый становится хвостом
}
```


![[Pasted image 20251216005012.png]]
## Тонкости для придирчивых преподавателей

1. **NULL vs nullptr:** В C используем `NULL` (определен как `(void*)0` в `<stddef.h>`), в C++ — `nullptr`
    
2. **Проверка malloc:** Всегда проверяем результат! `malloc` может вернуть `NULL` при нехватке памяти
    
3. **Утечки памяти:** При удалении списка обязателен проход с освобождением:
    

```c
void free_list(Node *head) {
    while (head != NULL) {
        Node *temp = head;
        head = head->next;
        free(temp);  // освобождаем ДО перехода
    }
}
```

4. **Двойное освобождение:** `free(ptr); free(ptr);` — undefined behavior! Всегда зануляем: `ptr = NULL;` после `free(ptr);`
    
5. **Размер структур:** `sizeof(Node)` учитывает выравнивание (alignment). На 64-битной системе:
    
    - Односвязный узел: обычно 16 байт (8 данные + 8 указатель с padding)
    - Двусвязный узел: обычно 24 байта (8 + 8 + 8)
