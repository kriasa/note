## Функция с переменным количеством аргументов для конкатенации строк

Для реализации такой функции нам понадобится `<stdarg.h>` и четкая стратегия:

1. Сначала **посчитать общую длину** всех строк, чтобы выделить один раз нужный объем памяти.
2. Затем **скопировать** их одну за другой в выделенный буфер.
    
В качестве "сигнала остановки" (маркера конца) мы будем использовать `NULL`.

Если мы выбираем **один проход** как приоритет (что логично для потоковых данных), то мы обязаны использовать стратегию динамического расширения.

Вот самый чистый код с одним проходом, где мы допускаем временный перерасход ради скорости, но в конце всё равно «подрезаем» строку до идеального размера:

```c
#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>

/**
 * Коды ошибок:
 * 1 - Ошибка памяти (malloc/realloc)
 * 2 - first is NULL
 * 3 - result is NULL
 */
int concat(char **result, char *first, ...) {
    if (first == NULL) return 2;
    if (result == NULL) return 3;

    va_list args;
    va_start(args, first);

    size_t capacity = 16; 
    size_t length = 0;
    char *buffer = (char *)malloc(capacity);

    if (buffer == NULL) {
        va_end(args);
        return 1;
    }

    char *current = first;

    // --- ОДИН ПРОХОД ПО АРГУМЕНТАМ ---
    while (current != NULL) {
        for (size_t i = 0; current[i] != '\0'; i++) {
            // Проверка: хватит ли места для символа и будущего '\0'
            if (length + 1 >= capacity) {
                size_t new_capacity = capacity * 2;
                char *new_buffer = (char *)realloc(buffer, new_capacity);
                
                if (new_buffer == NULL) {
                    free(buffer);
                    va_end(args);
                    return 1;
                }
                buffer = new_buffer;
                capacity = new_capacity;
            }
            buffer[length++] = current[i];
        }
        // Извлекаем следующий аргумент. Назад вернуться уже нельзя.
        current = va_arg(args, char *);
    }

    buffer[length] = '\0';
    va_end(args);

    // Финальный штрих: убираем временный перерасход.
    // realloc до length + 1 обрежет "хвост" capacity и вернет лишнее системе.
    char *final_res = (char *)realloc(buffer, length + 1);
    *result = (final_res != NULL) ? final_res : buffer;

    return 0;
}

int main() {
    char *res = NULL;
    int status = concat(&res, "One ", "pass, ", "dynamic ", "growth.", NULL);

    switch (status) {
        case 0:
            printf("Результат: %s\n", res);
            free(res);
            break;
        case 1: printf("Ошибка памяти\n"); break;
        case 2: printf("First is NULL\n"); break;
        case 3: printf("Result pointer is NULL\n"); break;
    }

    return 0;
}
Результат: One pass, dynamic growth.
```

## На вход через аргументы командой строки подаются имена входного и выходного файлов. Если во входном файле встречается несколько одинаковых подряд идущих слов, то в выходной файл из надо записывать как string(n), где n - сколько раз повторяется слово string. пример: aaa bbb bbb Bbb. -> aaa bbb(2) Bbb. Показать использование в main() использование реализованной функции

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_WORD_LEN 256

/**
 * Функция обрабатывает файлы, сжимая повторяющиеся слова.
 * Реализована с учетом регистра (bbb и Bbb — разные слова).
 */
void process_words_rle(const char *input_path, const char *output_path) {
    FILE *in = fopen(input_path, "r");
    FILE *out = fopen(output_path, "w");

    if (!in || !out) {
        perror("Ошибка при открытии файлов");
        if (in) fclose(in);
        if (out) fclose(out);
        return;
    }

    char current_word[MAX_WORD_LEN];
    char next_word[MAX_WORD_LEN];

    // Читаем первое слово
    if (fscanf(in, "%255s", current_word) != 1) {
        fclose(in);
        fclose(out);
        return;
    }

    int count = 1;

    // Цикл по всем остальным словам файла
    while (fscanf(in, "%255s", next_word) == 1) {
        // Сравниваем текущее слово со следующим
        if (strcmp(current_word, next_word) == 0) {
            count++;
        } else {
            // Слово изменилось — записываем результат предыдущего
            if (count > 1) {
                fprintf(out, "%s(%d) ", current_word, count);
            } else {
                fprintf(out, "%s ", current_word);
            }
            
            // Текущим становится новое слово, счетчик сбрасываем
            strcpy(current_word, next_word);
            count = 1;
        }
    }

    // Не забываем записать самое последнее слово после выхода из цикла
    if (count > 1) {
        fprintf(out, "%s(%d)\n", current_word, count);
    } else {
        fprintf(out, "%s\n", current_word);
    }

    fclose(in);
    fclose(out);
}

int main(int argc, char *argv[]) {
    // 1. Проверка аргументов командной строки
    if (argc != 3) {
        fprintf(stderr, "Использование: %s <входной_файл> <выходной_файл>\n", argv[0]);
        return 1;
    }

    printf("Начинаю обработку слов...\n");
    
    // 2. Вызов основной логики
    process_words_rle(argv[1], argv[2]);

    printf("Готово! Результат записан в %s\n", argv[2]);

    return 0;
}
```

## Даны два файла. В первом: fiiiile, во втором должно быть: fi(4)le

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void encode_rle(const char* input, char* output) {
    int start = 0;  // левая граница
    int end = 0;    // правая граница
    int out_pos = 0;
    
    while (input[start]) {
        // Расширяем правую границу, пока символы одинаковые
        end = start;
        while (input[end] && input[end] == input[start]) {
            end++;
        }
        
        // Вычисляем длину последовательности
        int length = end - start;
        
        // Всегда записываем символ
        output[out_pos++] = input[start];
        
        // Если повторяется больше 1 раза - добавляем количество в скобках
        if (length > 1) {
            output[out_pos++] = '(';
            
            // Преобразуем число в строку
            char num_buf[20];
            int num_len = sprintf(num_buf, "%d", length);
            strcpy(output + out_pos, num_buf);
            out_pos += num_len;
            
            output[out_pos++] = ')';
        }
        
        // Сдвигаем левую границу
        start = end;
    }
    
    output[out_pos] = '\0';
}

int main(int argc, char* argv[]) {
    // Проверка аргументов командной строки
    if (argc != 3) {
        printf("Использование: %s <входной_файл> <выходной_файл>\n", argv[0]);
        printf("Пример: %s input.txt output.txt\n", argv[0]);
        return 1;
    }
    
    // Открываем файлы
    FILE* input_file = fopen(argv[1], "r");
    if (!input_file) {
        printf("Ошибка: не удалось открыть файл '%s'\n", argv[1]);
        return 1;
    }
    
    FILE* output_file = fopen(argv[2], "w");
    if (!output_file) {
        printf("Ошибка: не удалось создать файл '%s'\n", argv[2]);
        fclose(input_file);
        return 1;
    }
    
    // Буферы
    char line[1024];
    char encoded[2048];
    
    printf("Кодирование RLE (все повторения в скобках):\n");
    printf("===========================================\n");
    
    // Обрабатываем файл построчно
    while (fgets(line, sizeof(line), input_file)) {
        // Убираем символ новой строки
        line[strcspn(line, "\n")] = '\0';
        
        // Кодируем строку
        encode_rle(line, encoded);
        
        // Записываем результат
        fprintf(output_file, "%s\n", encoded);
        
        // Выводим для наглядности
        printf("Вход:  %s\n", line);
        printf("Выход: %s\n\n", encoded);
    }
    
    // Закрываем файлы
    fclose(input_file);
    fclose(output_file);
    
    printf("Результат сохранен в '%s'\n", argv[2]);
    
    return 0;
}

```

## Посчитать частоты лексем, используя "метод границ" (видимо, strtok), и записать в выходной файл: A A A B -> A (3) B

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_LINE_SIZE 4096

/**
 * Функция обрабатывает одну строку, используя strtok (метод границ)
 */
void process_line(char *line, FILE *out) {
    // Разделители: пробел, табуляция, перенос строки, знаки препинания
    const char *delimiters = " \t\n\r,.!?;:";
    
    // Получаем первую лексему (токен)
    char *token = strtok(line, delimiters);
    if (token == NULL) return;

    char current_lexeme[256];
    strcpy(current_lexeme, token);
    int count = 1;

    // Проходим по остальным лексемам в строке
    while ((token = strtok(NULL, delimiters)) != NULL) {
        if (strcmp(current_lexeme, token) == 0) {
            count++;
        } else {
            // Записываем результат предыдущей группы
            if (count > 1) {
                fprintf(out, "%s(%d) ", current_lexeme, count);
            } else {
                fprintf(out, "%s ", current_lexeme);
            }
            // Обновляем текущую лексему
            strncpy(current_lexeme, token, sizeof(current_lexeme) - 1);
            count = 1;
        }
    }

    // Записываем последнюю лексему в строке
    if (count > 1) {
        fprintf(out, "%s(%d) ", current_lexeme, count);
    } else {
        fprintf(out, "%s ", current_lexeme);
    }
}

int main(int argc, char *argv[]) {
    if (argc != 3) {
        fprintf(stderr, "Использование: %s <input> <output>\n", argv[0]);
        return 1;
    }

    FILE *in = fopen(argv[1], "r");
    FILE *out = fopen(argv[2], "w");

    if (!in || !out) {
        perror("Ошибка открытия файлов");
        return 1;
    }

    char line[MAX_LINE_SIZE];

    // Читаем файл построчно
    while (fgets(line, sizeof(line), in)) {
        process_line(line, out);
        fprintf(out, "\n"); // Сохраняем структуру строк
    }

    fclose(in);
    fclose(out);
    printf("Частоты лексем посчитаны.\n");
    return 0;
}

```
Представим, что твой файл **input.txt** выглядит так:

Plaintext

```
A A A B
apple apple banana
C, C, C!
```

### Что будет в выходном файле (**output.txt**):

Программа обработает файл построчно и выдаст:

Plaintext

```
A(3) B 
apple(2) banana 
C(3) 
```

---

### Почему вывод именно такой? (Разбор логики)

1. **Первая строка (`A A A B`):**
    
    - `strtok` находит первую `A`.
        
    - Сравнивает со следующей — совпадает. Счетчик = 2.
        
    - Сравнивает со следующей — совпадает. Счетчик = 3.
        
    - Следующее слово `B` — не совпадает. Печатаем `A(3)`.
        
    - Печатаем `B`.
        
2. **Третья строка (`C, C, C!`):**
    
    - Благодаря «методу границ» и списку разделителей `",.! "`, запятые и восклицательные знаки **игнорируются**.
        
    - Программа видит только чистые лексемы: `C`, `C` и `C`.
        
    - Результат: `C(3)`.
---
![[Pasted image 20251218222733.png]]
```c
#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

// Вспомогательная функция для поиска подстроки без учета регистра
char* strstr_case(const char* haystack, const char* needle) {
    if (!*needle) return (char*)haystack;
    for (; *haystack; haystack++) {
        if (tolower((unsigned char)*haystack) == tolower((unsigned char)*needle)) {
            const char *h, *n;
            for (h = haystack, n = needle; *h && *n; h++, n++) {
                if (tolower((unsigned char)*h) != tolower((unsigned char)*n)) break;
            }
            if (!*n) return (char*)haystack;
        }
    }
    return NULL;
}

int substr(char* to_find, int case_sensitive, char*** results, size_t* results_count, ...) {
    // Проверки аргументов (коды ошибок 1, 2, 3)
    if (to_find == NULL) return 1;
    if (results == NULL) return 2;
    if (results_count == NULL) return 3;

    *results_count = 0;
    *results = NULL;

    va_list args;
    va_start(args, results_count);

    size_t capacity = 4;
    *results = (char**)malloc(capacity * sizeof(char*));
    if (*results == NULL) {
        va_end(args);
        return 4;
    }

    char* current_str = va_arg(args, char*);
    while (current_str != NULL) {
        char* found = case_sensitive ? strstr(current_str, to_find) : strstr_case(current_str, to_find);

        if (found) {
            // Расширение массива указателей при необходимости
            if (*results_count >= capacity) {
                capacity *= 2;
                char** temp = (char**)realloc(*results, capacity * sizeof(char*));
                if (temp == NULL) goto cleanup_fail;
                *results = temp;
            }

            // ГЛУБОКОЕ КОПИРОВАНИЕ (выделяем память под саму строку)
            (*results)[*results_count] = (char*)malloc(strlen(current_str) + 1);
            if ((*results)[*results_count] == NULL) goto cleanup_fail;
            
            strcpy((*results)[*results_count], current_str);
            (*results_count)++;
        }
        current_str = va_arg(args, char*);
    }

    va_end(args);
    return 0; // Успех

cleanup_fail:
    va_end(args);
    // Очистка всей выделенной памяти перед возвратом ошибки 4
    for (size_t i = 0; i < *results_count; i++) {
        free((*results)[i]);
    }
    free(*results);
    *results = NULL;
    *results_count = 0;
    return 4;
}

int main() {
    char** found_lines = NULL;
    size_t count = 0;

    int status = substr("Apple", 0, &found_lines, &count, 
                        "I like apple juice", 
                        "Orange is orange", 
                        "APPLE PIE IS BEST", 
                        "Just a string", 
                        NULL);

    switch (status) {
        case 0:
            printf("Найдено строк: %zu\n", count);
            for (size_t i = 0; i < count; i++) {
                printf("[%zu]: %s\n", i, found_lines[i]);
                free(found_lines[i]); // Освобождаем копии строк
            }
            free(found_lines); // Освобождаем массив указателей
            break;
        case 1: printf("Ошибка: подстрока для поиска NULL\n"); break;
        case 2: printf("Ошибка: неверный указатель results\n"); break;
        case 3: printf("Ошибка: неверный указатель results_count\n"); break;
        case 4: printf("Критическая ошибка: не удалось выделить память\n"); break;
    }

    return 0;
}
```