## Функция с переменным количеством аргументов для конкатенации строк

Для реализации такой функции нам понадобится `<stdarg.h>` и четкая стратегия:

1. Сначала **посчитать общую длину** всех строк, чтобы выделить один раз нужный объем памяти.
2. Затем **скопировать** их одну за другой в выделенный буфер.
    
В качестве "сигнала остановки" (маркера конца) мы будем использовать `NULL`.

Если мы выбираем **один проход** как приоритет (что логично для потоковых данных), то мы обязаны использовать стратегию динамического расширения.

Вот самый чистый код с одним проходом, где мы допускаем временный перерасход ради скорости, но в конце всё равно «подрезаем» строку до идеального размера:

```c
#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>

/**
 * Коды ошибок:
 * 1 - Ошибка памяти (malloc/realloc)
 * 2 - first is NULL
 * 3 - result is NULL
 */
int concat(char **result, char *first, ...) {
    if (first == NULL) return 2;
    if (result == NULL) return 3;

    va_list args;
    va_start(args, first);

    size_t capacity = 16; 
    size_t length = 0;
    char *buffer = (char *)malloc(capacity);

    if (buffer == NULL) {
        va_end(args);
        return 1;
    }

    char *current = first;

    // --- ОДИН ПРОХОД ПО АРГУМЕНТАМ ---
    while (current != NULL) {
        for (size_t i = 0; current[i] != '\0'; i++) {
            // Проверка: хватит ли места для символа и будущего '\0'
            if (length + 1 >= capacity) {
                size_t new_capacity = capacity * 2;
                char *new_buffer = (char *)realloc(buffer, new_capacity);
                
                if (new_buffer == NULL) {
                    free(buffer);
                    va_end(args);
                    return 1;
                }
                buffer = new_buffer;
                capacity = new_capacity;
            }
            buffer[length++] = current[i];
        }
        // Извлекаем следующий аргумент. Назад вернуться уже нельзя.
        current = va_arg(args, char *);
    }

    buffer[length] = '\0';
    va_end(args);

    // Финальный штрих: убираем временный перерасход.
    // realloc до length + 1 обрежет "хвост" capacity и вернет лишнее системе.
    char *final_res = (char *)realloc(buffer, length + 1);
    *result = (final_res != NULL) ? final_res : buffer;

    return 0;
}

int main() {
    char *res = NULL;
    int status = concat(&res, "One ", "pass, ", "dynamic ", "growth.", NULL);

    switch (status) {
        case 0:
            printf("Результат: %s\n", res);
            free(res);
            break;
        case 1: printf("Ошибка памяти\n"); break;
        case 2: printf("First is NULL\n"); break;
        case 3: printf("Result pointer is NULL\n"); break;
    }

    return 0;
}
Результат: One pass, dynamic growth.
```

## На вход через аргументы командой строки подаются имена входного и выходного файлов. Если во входном файле встречается несколько одинаковых подряд идущих слов, то в выходной файл из надо записывать как string(n), где n - сколько раз повторяется слово string. пример: aaa bbb bbb Bbb. -> aaa bbb(2) Bbb. Показать использование в main() использование реализованной функции

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_WORD_LEN 256

/**
 * Функция обрабатывает файлы, сжимая повторяющиеся слова.
 * Реализована с учетом регистра (bbb и Bbb — разные слова).
 */
void process_words_rle(const char *input_path, const char *output_path) {
    FILE *in = fopen(input_path, "r");
    FILE *out = fopen(output_path, "w");

    if (!in || !out) {
        perror("Ошибка при открытии файлов");
        if (in) fclose(in);
        if (out) fclose(out);
        return;
    }

    char current_word[MAX_WORD_LEN];
    char next_word[MAX_WORD_LEN];

    // Читаем первое слово
    if (fscanf(in, "%255s", current_word) != 1) {
        fclose(in);
        fclose(out);
        return;
    }

    int count = 1;

    // Цикл по всем остальным словам файла
    while (fscanf(in, "%255s", next_word) == 1) {
        // Сравниваем текущее слово со следующим
        if (strcmp(current_word, next_word) == 0) {
            count++;
        } else {
            // Слово изменилось — записываем результат предыдущего
            if (count > 1) {
                fprintf(out, "%s(%d) ", current_word, count);
            } else {
                fprintf(out, "%s ", current_word);
            }
            
            // Текущим становится новое слово, счетчик сбрасываем
            strcpy(current_word, next_word);
            count = 1;
        }
    }

    // Не забываем записать самое последнее слово после выхода из цикла
    if (count > 1) {
        fprintf(out, "%s(%d)\n", current_word, count);
    } else {
        fprintf(out, "%s\n", current_word);
    }

    fclose(in);
    fclose(out);
}

int main(int argc, char *argv[]) {
    // 1. Проверка аргументов командной строки
    if (argc != 3) {
        fprintf(stderr, "Использование: %s <входной_файл> <выходной_файл>\n", argv[0]);
        return 1;
    }

    printf("Начинаю обработку слов...\n");
    
    // 2. Вызов основной логики
    process_words_rle(argv[1], argv[2]);

    printf("Готово! Результат записан в %s\n", argv[2]);

    return 0;
}
```

## Даны два файла. В первом: fiiiile, во втором должно быть: fi(4)le

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void encode_rle(const char* input, char* output) {
    int start = 0;  // левая граница
    int end = 0;    // правая граница
    int out_pos = 0;
    
    while (input[start]) {
        // Расширяем правую границу, пока символы одинаковые
        end = start;
        while (input[end] && input[end] == input[start]) {
            end++;
        }
        
        // Вычисляем длину последовательности
        int length = end - start;
        
        // Всегда записываем символ
        output[out_pos++] = input[start];
        
        // Если повторяется больше 1 раза - добавляем количество в скобках
        if (length > 1) {
            output[out_pos++] = '(';
            
            // Преобразуем число в строку
            char num_buf[20];
            int num_len = sprintf(num_buf, "%d", length);
            strcpy(output + out_pos, num_buf);
            out_pos += num_len;
            
            output[out_pos++] = ')';
        }
        
        // Сдвигаем левую границу
        start = end;
    }
    
    output[out_pos] = '\0';
}

int main(int argc, char* argv[]) {
    // Проверка аргументов командной строки
    if (argc != 3) {
        printf("Использование: %s <входной_файл> <выходной_файл>\n", argv[0]);
        printf("Пример: %s input.txt output.txt\n", argv[0]);
        return 1;
    }
    
    // Открываем файлы
    FILE* input_file = fopen(argv[1], "r");
    if (!input_file) {
        printf("Ошибка: не удалось открыть файл '%s'\n", argv[1]);
        return 1;
    }
    
    FILE* output_file = fopen(argv[2], "w");
    if (!output_file) {
        printf("Ошибка: не удалось создать файл '%s'\n", argv[2]);
        fclose(input_file);
        return 1;
    }
    
    // Буферы
    char line[1024];
    char encoded[2048];
    
    printf("Кодирование RLE (все повторения в скобках):\n");
    printf("===========================================\n");
    
    // Обрабатываем файл построчно
    while (fgets(line, sizeof(line), input_file)) {
        // Убираем символ новой строки
        line[strcspn(line, "\n")] = '\0';
        
        // Кодируем строку
        encode_rle(line, encoded);
        
        // Записываем результат
        fprintf(output_file, "%s\n", encoded);
        
        // Выводим для наглядности
        printf("Вход:  %s\n", line);
        printf("Выход: %s\n\n", encoded);
    }
    
    // Закрываем файлы
    fclose(input_file);
    fclose(output_file);
    
    printf("Результат сохранен в '%s'\n", argv[2]);
    
    return 0;
}

```

## Посчитать частоты лексем, используя "метод границ" (видимо, strtok), и записать в выходной файл: A A A B -> A (3) B

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_LINE_SIZE 4096

/**
 * Функция обрабатывает одну строку, используя strtok (метод границ)
 */
void process_line(char *line, FILE *out) {
    // Разделители: пробел, табуляция, перенос строки, знаки препинания
    const char *delimiters = " \t\n\r,.!?;:";
    
    // Получаем первую лексему (токен)
    char *token = strtok(line, delimiters);
    if (token == NULL) return;

    char current_lexeme[256];
    strcpy(current_lexeme, token);
    int count = 1;

    // Проходим по остальным лексемам в строке
    while ((token = strtok(NULL, delimiters)) != NULL) {
        if (strcmp(current_lexeme, token) == 0) {
            count++;
        } else {
            // Записываем результат предыдущей группы
            if (count > 1) {
                fprintf(out, "%s(%d) ", current_lexeme, count);
            } else {
                fprintf(out, "%s ", current_lexeme);
            }
            // Обновляем текущую лексему
            strncpy(current_lexeme, token, sizeof(current_lexeme) - 1);
            count = 1;
        }
    }

    // Записываем последнюю лексему в строке
    if (count > 1) {
        fprintf(out, "%s(%d) ", current_lexeme, count);
    } else {
        fprintf(out, "%s ", current_lexeme);
    }
}

int main(int argc, char *argv[]) {
    if (argc != 3) {
        fprintf(stderr, "Использование: %s <input> <output>\n", argv[0]);
        return 1;
    }

    FILE *in = fopen(argv[1], "r");
    FILE *out = fopen(argv[2], "w");

    if (!in || !out) {
        perror("Ошибка открытия файлов");
        return 1;
    }

    char line[MAX_LINE_SIZE];

    // Читаем файл построчно
    while (fgets(line, sizeof(line), in)) {
        process_line(line, out);
        fprintf(out, "\n"); // Сохраняем структуру строк
    }

    fclose(in);
    fclose(out);
    printf("Частоты лексем посчитаны.\n");
    return 0;
}

```
Представим, что твой файл **input.txt** выглядит так:

Plaintext

```
A A A B
apple apple banana
C, C, C!
```

### Что будет в выходном файле (**output.txt**):

Программа обработает файл построчно и выдаст:

Plaintext

```
A(3) B 
apple(2) banana 
C(3) 
```

---

### Почему вывод именно такой? (Разбор логики)

1. **Первая строка (`A A A B`):**
    
    - `strtok` находит первую `A`.
        
    - Сравнивает со следующей — совпадает. Счетчик = 2.
        
    - Сравнивает со следующей — совпадает. Счетчик = 3.
        
    - Следующее слово `B` — не совпадает. Печатаем `A(3)`.
        
    - Печатаем `B`.
        
2. **Третья строка (`C, C, C!`):**
    
    - Благодаря «методу границ» и списку разделителей `",.! "`, запятые и восклицательные знаки **игнорируются**.
        
    - Программа видит только чистые лексемы: `C`, `C` и `C`.
        
    - Результат: `C(3)`.
---
![[Pasted image 20251218222733.png]]
```c
#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

// Вспомогательная функция для поиска подстроки без учета регистра
char* strstr_case(const char* haystack, const char* needle) {
    if (!*needle) return (char*)haystack;
    for (; *haystack; haystack++) {
        if (tolower((unsigned char)*haystack) == tolower((unsigned char)*needle)) {
            const char *h, *n;
            for (h = haystack, n = needle; *h && *n; h++, n++) {
                if (tolower((unsigned char)*h) != tolower((unsigned char)*n)) break;
            }
            if (!*n) return (char*)haystack;
        }
    }
    return NULL;
}

int substr(char* to_find, int case_sensitive, char*** results, size_t* results_count, ...) {
    // Проверки аргументов (коды ошибок 1, 2, 3)
    if (to_find == NULL) return 1;
    if (results == NULL) return 2;
    if (results_count == NULL) return 3;

    *results_count = 0;
    *results = NULL;

    va_list args;
    va_start(args, results_count);

    size_t capacity = 4;
    *results = (char**)malloc(capacity * sizeof(char*));
    if (*results == NULL) {
        va_end(args);
        return 4;
    }

    char* current_str = va_arg(args, char*);
    while (current_str != NULL) {
        char* found = case_sensitive ? strstr(current_str, to_find) : strstr_case(current_str, to_find);

        if (found) {
            // Расширение массива указателей при необходимости
            if (*results_count >= capacity) {
                capacity *= 2;
                char** temp = (char**)realloc(*results, capacity * sizeof(char*));
                if (temp == NULL) goto cleanup_fail;
                *results = temp;
            }

            // ГЛУБОКОЕ КОПИРОВАНИЕ (выделяем память под саму строку)
            (*results)[*results_count] = (char*)malloc(strlen(current_str) + 1);
            if ((*results)[*results_count] == NULL) goto cleanup_fail;
            
            strcpy((*results)[*results_count], current_str);
            (*results_count)++;
        }
        current_str = va_arg(args, char*);
    }

    va_end(args);
    return 0; // Успех

cleanup_fail:
    va_end(args);
    // Очистка всей выделенной памяти перед возвратом ошибки 4
    for (size_t i = 0; i < *results_count; i++) {
        free((*results)[i]);
    }
    free(*results);
    *results = NULL;
    *results_count = 0;
    return 4;
}

int main() {
    char** found_lines = NULL;
    size_t count = 0;

    int status = substr("Apple", 0, &found_lines, &count, 
                        "I like apple juice", 
                        "Orange is orange", 
                        "APPLE PIE IS BEST", 
                        "Just a string", 
                        NULL);

    switch (status) {
        case 0:
            printf("Найдено строк: %zu\n", count);
            for (size_t i = 0; i < count; i++) {
                printf("[%zu]: %s\n", i, found_lines[i]);
                free(found_lines[i]); // Освобождаем копии строк
            }
            free(found_lines); // Освобождаем массив указателей
            break;
        case 1: printf("Ошибка: подстрока для поиска NULL\n"); break;
        case 2: printf("Ошибка: неверный указатель results\n"); break;
        case 3: printf("Ошибка: неверный указатель results_count\n"); break;
        case 4: printf("Критическая ошибка: не удалось выделить память\n"); break;
    }

    return 0;
}
```

## выражение из инфиксной в постфиксную с переменным числом аргументов, структура элемента


```c
#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <stdbool.h>

// Структура оператора (точно по заданию)
typedef struct {
    char* symbol;    // строковое представление оператора
    int priority;    // приоритет (неотрицательное целое)
} Operator;

// Структура для стека (универсальная)
typedef struct {
    void** items;
    int top;
    int capacity;
} Stack;

// ==================== УТИЛИТЫ ДЛЯ СТЕКА ====================

Stack* create_stack(int capacity) {
    Stack* stack = (Stack*)malloc(sizeof(Stack));
    if (!stack) return NULL;
    
    stack->items = (void**)malloc(capacity * sizeof(void*));
    if (!stack->items) {
        free(stack);
        return NULL;
    }
    
    stack->capacity = capacity;
    stack->top = -1;
    return stack;
}

bool push(Stack* stack, void* item) {
    if (!stack || !item) return false;
    
    if (stack->top >= stack->capacity - 1) {
        // Увеличиваем емкость в 2 раза (O(1) амортизированное)
        int new_capacity = stack->capacity * 2;
        void** new_items = (void**)realloc(stack->items, new_capacity * sizeof(void*));
        if (!new_items) return false;
        
        stack->items = new_items;
        stack->capacity = new_capacity;
    }
    
    stack->items[++stack->top] = item;
    return true;
}

void* pop(Stack* stack) {
    if (!stack || stack->top < 0) return NULL;
    return stack->items[stack->top--];
}

void* peek(Stack* stack) {
    if (!stack || stack->top < 0) return NULL;
    return stack->items[stack->top];
}

bool is_empty(Stack* stack) {
    return !stack || stack->top < 0;
}

void free_stack(Stack* stack) {
    if (!stack) return;
    if (stack->items) free(stack->items);
    free(stack);
}

// ==================== ВАЛИДАЦИЯ ОПЕРАТОРОВ ====================

bool validate_operator(const Operator* op) {
    if (!op || !op->symbol) return false;
    
    // 1. Не пустая строка
    if (strlen(op->symbol) == 0) return false;
    
    // 2. Не содержит цифр
    for (int i = 0; op->symbol[i]; i++) {
        if (isdigit((unsigned char)op->symbol[i])) {
            return false;
        }
    }
    
    // 3. Приоритет неотрицательный
    if (op->priority < 0) return false;
    
    return true;
}

bool is_duplicate_operator(const Operator* op, const Operator** operators, int count) {
    for (int i = 0; i < count; i++) {
        if (operators[i] && strcmp(op->symbol, operators[i]->symbol) == 0) {
            return true;
        }
    }
    return false;
}

// ==================== ОСНОВНАЯ ФУНКЦИЯ ====================

/**
 * Прототип точно по заданию: int convert_to_postfix(char* infx_expression, char** postfix_expression, ...);
 * 
 * Коды возврата:
 *  0 - успех
 *  1 - ошибка: некорректный оператор (валидация не прошла)
 *  2 - ошибка: дубликат оператора
 *  3 - ошибка: выделение памяти
 *  4 - ошибка: несогласованные скобки
 */
int convert_to_postfix(char* infx_expression, char** postfix_expression, ...) {
    // Проверка входных параметров
    if (!infx_expression || !postfix_expression) {
        return 3; // Ошибка памяти (некорректные указатели)
    }
    
    *postfix_expression = NULL;
    
    // Собираем операторы из variadic arguments
    va_list args;
    va_start(args, postfix_expression);
    
    // Временный массив для хранения операторов
    Operator** operators = NULL;
    int op_count = 0;
    int op_capacity = 4;
    
    operators = (Operator**)malloc(op_capacity * sizeof(Operator*));
    if (!operators) {
        va_end(args);
        return 3;
    }
    
    // Читаем операторы до NULL
    Operator* current_op;
    while ((current_op = va_arg(args, Operator*)) != NULL) {
        // Проверяем валидацию оператора
        if (!validate_operator(current_op)) {
            free(operators);
            va_end(args);
            return 1; // Ошибка валидации оператора
        }
        
        // Проверяем на дубликаты
        if (is_duplicate_operator(current_op, (const Operator**)operators, op_count)) {
            free(operators);
            va_end(args);
            return 2; // Дубликат оператора
        }
        
        // Добавляем в массив (с динамическим расширением)
        if (op_count >= op_capacity) {
            op_capacity *= 2;
            Operator** new_ops = (Operator**)realloc(operators, op_capacity * sizeof(Operator*));
            if (!new_ops) {
                free(operators);
                va_end(args);
                return 3;
            }
            operators = new_ops;
        }
        
        operators[op_count++] = current_op;
    }
    va_end(args);
    
    // =========== АЛГОРИТМ SHUNTING-YARD ===========
    
    // Стеки для алгоритма
    Stack* op_stack = create_stack(16);
    Stack* output_stack = create_stack(16);
    
    if (!op_stack || !output_stack) {
        if (op_stack) free_stack(op_stack);
        if (output_stack) free_stack(output_stack);
        free(operators);
        return 3;
    }
    
    // Токенизация выражения
    char* token = strtok(infx_expression, " \t\n");
    while (token) {
        // 1. Если токен - число (или операнд) - на выход
        bool is_operand = true;
        for (int i = 0; i < op_count; i++) {
            if (strcmp(token, operators[i]->symbol) == 0) {
                is_operand = false;
                break;
            }
        }
        
        if (is_operand && strcmp(token, "(") != 0 && strcmp(token, ")") != 0) {
            // Это операнд
            char* token_copy = strdup(token);
            if (!token_copy || !push(output_stack, token_copy)) {
                free(operators);
                free_stack(op_stack);
                free_stack(output_stack);
                return 3;
            }
        }
        // 2. Если токен - оператор
        else if (!is_operand) {
            // Находим приоритет текущего оператора
            int current_priority = -1;
            for (int i = 0; i < op_count; i++) {
                if (strcmp(token, operators[i]->symbol) == 0) {
                    current_priority = operators[i]->priority;
                    break;
                }
            }
            
            // Выталкиваем операторы с более высоким или равным приоритетом
            while (!is_empty(op_stack)) {
                char* top_op = (char*)peek(op_stack);
                if (!top_op || strcmp(top_op, "(") == 0) break;
                
                int top_priority = -1;
                for (int i = 0; i < op_count; i++) {
                    if (strcmp(top_op, operators[i]->symbol) == 0) {
                        top_priority = operators[i]->priority;
                        break;
                    }
                }
                
                if (top_priority >= current_priority) {
                    char* popped = (char*)pop(op_stack);
                    if (!push(output_stack, popped)) {
                        free(popped);
                        free(operators);
                        free_stack(op_stack);
                        free_stack(output_stack);
                        return 3;
                    }
                } else {
                    break;
                }
            }
            
            // Помещаем текущий оператор в стек
            char* op_copy = strdup(token);
            if (!op_copy || !push(op_stack, op_copy)) {
                free(op_copy);
                free(operators);
                free_stack(op_stack);
                free_stack(output_stack);
                return 3;
            }
        }
        // 3. Если токен - открывающая скобка
        else if (strcmp(token, "(") == 0) {
            char* paren = strdup("(");
            if (!paren || !push(op_stack, paren)) {
                free(paren);
                free(operators);
                free_stack(op_stack);
                free_stack(output_stack);
                return 3;
            }
        }
        // 4. Если токен - закрывающая скобка
        else if (strcmp(token, ")") == 0) {
            // Выталкиваем операторы до открывающей скобки
            bool found_paren = false;
            while (!is_empty(op_stack)) {
                char* top_op = (char*)peek(op_stack);
                if (!top_op) break;
                
                if (strcmp(top_op, "(") == 0) {
                    found_paren = true;
                    char* popped = (char*)pop(op_stack);
                    free(popped);
                    break;
                } else {
                    char* popped = (char*)pop(op_stack);
                    if (!push(output_stack, popped)) {
                        free(popped);
                        free(operators);
                        free_stack(op_stack);
                        free_stack(output_stack);
                        return 3;
                    }
                }
            }
            
            if (!found_paren) {
                free(operators);
                free_stack(op_stack);
                free_stack(output_stack);
                return 4; // Несогласованные скобки
            }
        }
        
        token = strtok(NULL, " \t\n");
    }
    
    // Выталкиваем оставшиеся операторы
    while (!is_empty(op_stack)) {
        char* top_op = (char*)peek(op_stack);
        if (!top_op) break;
        
        if (strcmp(top_op, "(") == 0) {
            free(operators);
            free_stack(op_stack);
            free_stack(output_stack);
            return 4; // Несогласованные скобки
        }
        
        char* popped = (char*)pop(op_stack);
        if (!push(output_stack, popped)) {
            free(popped);
            free(operators);
            free_stack(op_stack);
            free_stack(output_stack);
            return 3;
        }
    }
    
    // =========== ФОРМИРОВАНИЕ РЕЗУЛЬТАТА ===========
    
    // Подсчитываем общую длину результата
    size_t total_len = 0;
    for (int i = 0; i <= output_stack->top; i++) {
        char* item = (char*)output_stack->items[i];
        total_len += strlen(item) + 1; // +1 для пробела
    }
    
    if (total_len > 0) total_len--; // Убираем последний пробел
    
    // Выделяем память для результата
    char* result = (char*)malloc(total_len + 1);
    if (!result) {
        free(operators);
        free_stack(op_stack);
        free_stack(output_stack);
        return 3;
    }
    
    result[0] = '\0';
    
    // Собираем результат
    for (int i = 0; i <= output_stack->top; i++) {
        char* item = (char*)output_stack->items[i];
        strcat(result, item);
        
        if (i < output_stack->top) {
            strcat(result, " ");
        }
        
        free(item); // Освобождаем копии строк
    }
    
    // Возвращаем результат
    *postfix_expression = result;
    
    // Очистка
    free(operators);
    free_stack(op_stack);
    free_stack(output_stack);
    
    return 0; // Успех
}

// ==================== ДЕМОНСТРАЦИЯ РАБОТЫ ====================

int main() {
    printf("=== Демонстрация работы конвертера инфикс → постфикс ===\n\n");
    
    // Определяем операторы (точно по условию)
    Operator plus = {"+", 1};
    Operator minus = {"-", 1};
    Operator multiply = {"*", 2};
    Operator divide = {"/", 2};
    Operator power = {"**", 3}; // Многосимвольный оператор
    Operator modulo = {"%", 2};
    
    // Тест 1: Простое выражение
    printf("Тест 1: Простое выражение\n");
    {
        char infix[] = "a + b";
        char* postfix = NULL;
        
        // Важно: NULL в конце как терминатор!
        int result = convert_to_postfix(infix, &postfix, 
                                        &plus, &minus, 
                                        NULL);
        
        if (result == 0 && postfix) {
            printf("  Инфикс:   %s\n", infix);
            printf("  Постфикс: %s\n", postfix);
            free(postfix);
        } else {
            printf("  Ошибка: код %d\n", result);
        }
    }
    
    // Тест 2: С приоритетами
    printf("\nТест 2: Выражение с приоритетами\n");
    {
        char infix[] = "a + b * c";
        char* postfix = NULL;
        
        int result = convert_to_postfix(infix, &postfix,
                                        &plus, &minus, &multiply, &divide,
                                        NULL);
        
        if (result == 0 && postfix) {
            printf("  Инфикс:   %s\n", infix);
            printf("  Постфикс: %s\n", postfix);
            free(postfix);
        } else {
            printf("  Ошибка: код %d\n", result);
        }
    }
    
    // Тест 3: Со скобками
    printf("\nТест 3: Выражение со скобками\n");
    {
        char infix[] = "( a + b ) * c";
        char* postfix = NULL;
        
        int result = convert_to_postfix(infix, &postfix,
                                        &plus, &minus, &multiply,
                                        NULL);
        
        if (result == 0 && postfix) {
            printf("  Инфикс:   %s\n", infix);
            printf("  Постфикс: %s\n", postfix);
            free(postfix);
        } else {
            printf("  Ошибка: код %d\n", result);
        }
    }
    
    // Тест 4: Многосимвольный оператор
    printf("\nТест 4: Многосимвольный оператор **\n");
    {
        char infix[] = "a ** b + c";
        char* postfix = NULL;
        
        int result = convert_to_postfix(infix, &postfix,
                                        &plus, &power,
                                        NULL);
        
        if (result == 0 && postfix) {
            printf("  Инфикс:   %s\n", infix);
            printf("  Постфикс: %s\n", postfix);
            free(postfix);
        } else {
            printf("  Ошибка: код %d\n", result);
        }
    }
    
    // Тест 5: Все операторы
    printf("\nТест 5: Сложное выражение\n");
    {
        char infix[] = "a + b * c - d / e % f ** ( g + h )";
        char* postfix = NULL;
        
        int result = convert_to_postfix(infix, &postfix,
                                        &plus, &minus, &multiply, 
                                        &divide, &power, &modulo,
                                        NULL);
        
        if (result == 0 && postfix) {
            printf("  Инфикс:   %s\n", infix);
            printf("  Постфикс: %s\n", postfix);
            free(postfix);
        } else {
            printf("  Ошибка: код %d\n", result);
        }
    }
    
    // Тест 6: Ошибка - дубликат оператора
    printf("\nТест 6: Проверка на дубликат оператора\n");
    {
        char infix[] = "a + b";
        char* postfix = NULL;
        
        // Создаем дубликат +
        Operator plus2 = {"+", 5}; // Другой приоритет, но тот же символ
        
        int result = convert_to_postfix(infix, &postfix,
                                        &plus, &plus2, // ДУБЛИКАТ!
                                        NULL);
        
        printf("  Ожидается ошибка 2 (дубликат). Получено: %d\n", result);
        if (postfix) free(postfix);
    }
    
    // Тест 7: Ошибка - оператор с цифрой
    printf("\nТест 7: Проверка валидации оператора\n");
    {
        char infix[] = "a + b";
        char* postfix = NULL;
        
        Operator invalid_op = {"+1", 1}; // Содержит цифру
        
        int result = convert_to_postfix(infix, &postfix,
                                        &invalid_op,
                                        NULL);
        
        printf("  Ожидается ошибка 1 (некорректный оператор). Получено: %d\n", result);
        if (postfix) free(postfix);
    }
    
    // Тест 8: Ошибка - несогласованные скобки
    printf("\nТест 8: Проверка скобок\n");
    {
        char infix[] = "( a + b";
        char* postfix = NULL;
        
        int result = convert_to_postfix(infix, &postfix,
                                        &plus, &minus,
                                        NULL);
        
        printf("  Ожидается ошибка 4 (несогласованные скобки). Получено: %d\n", result);
        if (postfix) free(postfix);
    }
    
    return 0;
}
```


иосиф флавий

```c
#include <stdio.h>
#include <stdlib.h>

// Структура узла кольцевого списка
typedef struct Node {
    int data;
    struct Node* next;
    struct Node* prev;
} Node;

// Структура кольцевого двусвязного списка
typedef struct {
    Node* head;
    int size;
} CircularList;

// Создание нового узла
Node* create_node(int value) {
    Node* new_node = (Node*)malloc(sizeof(Node));
    if (!new_node) {
        printf("Ошибка выделения памяти\n");
        return NULL;
    }
    new_node->data = value;
    new_node->next = NULL;
    new_node->prev = NULL;
    return new_node;
}

// Инициализация кольцевого списка
CircularList* create_circular_list() {
    CircularList* list = (CircularList*)malloc(sizeof(CircularList));
    if (!list) {
        printf("Ошибка выделения памяти\n");
        return NULL;
    }
    list->head = NULL;
    list->size = 0;
    return list;
}

// Добавление элемента в конец списка
void append(CircularList* list, int value) {
    Node* new_node = create_node(value);
    if (!new_node) return;
    
    if (list->head == NULL) {
        // Первый элемент
        list->head = new_node;
        new_node->next = new_node;
        new_node->prev = new_node;
    } else {
        // Добавление в конец
        Node* last = list->head->prev;
        
        last->next = new_node;
        new_node->prev = last;
        new_node->next = list->head;
        list->head->prev = new_node;
    }
    list->size++;
}

// Удаление узла из списка
void remove_node(CircularList* list, Node* node) {
    if (!list || !node || list->size == 0) return;
    
    if (list->size == 1) {
        // Единственный элемент
        list->head = NULL;
    } else {
        node->prev->next = node->next;
        node->next->prev = node->prev;
        
        // Если удаляем голову, перемещаем голову
        if (node == list->head) {
            list->head = node->next;
        }
    }
    
    free(node);
    list->size--;
}

// Печать списка
void print_list(CircularList* list) {
    if (!list || list->head == NULL) {
        printf("Список пуст\n");
        return;
    }
    
    Node* current = list->head;
    printf("Кольцевой список: ");
    
    do {
        printf("%d ", current->data);
        current = current->next;
    } while (current != list->head);
    printf("\n");
}

// Освобождение памяти списка
void free_list(CircularList* list) {
    if (!list) return;
    
    Node* current = list->head;
    for (int i = 0; i < list->size; i++) {
        Node* next = current->next;
        free(current);
        current = next;
    }
    
    free(list);
}


// Решение задачи Иосифа Флавия
// direction: 1 - по часовой стрелке (вперед), -1 - против часовой стрелки (назад)
void josephus_flavius(CircularList* list, int step, int direction, 
                      int* survivor1, int* survivor2) {
    if (!list || list->size == 0 || step <= 0) {
        *survivor1 = -1;
        *survivor2 = -1;
        return;
    }
    
    printf("\nНачало решения задачи Иосифа Флавия:\n");
    printf("Количество людей: %d\n", list->size);
    printf("Шаг: %d\n", step);
    printf("Направление: %s\n", direction == 1 ? "по часовой стрелке" : "против часовой стрелки");
    print_list(list);
    
    // Создаем копию списка для работы
    CircularList* working_list = create_circular_list();
    Node* current = list->head;
    for (int i = 0; i < list->size; i++) {
        append(working_list, current->data);
        current = current->next;
    }
    
    // Начинаем с головы
    Node* current_node = working_list->head;
    int count = 1;
    
    // Пока в списке больше 2 элементов
    while (working_list->size > 2) {
        // Переходим к следующему человеку
        if (direction == 1) {
            // По часовой стрелке
            current_node = current_node->next;
        } else {
            // Против часовой стрелки
            current_node = current_node->prev;
        }
        count++;
        
        // Если достигли шага, удаляем текущего
        if (count == step) {
            printf("Удален человек с номером: %d\n", current_node->data);
            
            Node* to_remove = current_node;
            
            // Переходим к следующему перед удалением
            if (direction == 1) {
                current_node = current_node->next;
            } else {
                current_node = current_node->prev;
            }
            
            remove_node(working_list, to_remove);
            count = 1; // Сбрасываем счетчик
        }
    }
    
    // Записываем двух последних выживших
    if (working_list->size == 2) {
        *survivor1 = working_list->head->data;
        *survivor2 = working_list->head->next->data;
        
        printf("\nПоследние двое выживших:\n");
        printf("Первый выживший: %d\n", *survivor1);
        printf("Второй выживший: %d\n", *survivor2);
    } else if (working_list->size == 1) {
        *survivor1 = working_list->head->data;
        *survivor2 = *survivor1;
        printf("\nОстался один выживший: %d\n", *survivor1);
    }
    
    free_list(working_list);
}

// Пример использования
int main() {
    // Создаем кольцевой список
    CircularList* list = create_circular_list();
    
    // Добавляем людей (например, 10 человек)
    for (int i = 1; i <= 10; i++) {
        append(list, i);
    }
    
    printf("Исходный список людей:\n");
    print_list(list);
    
    // Параметры задачи
    int step = 3;
    int direction = 1; // 1 - по часовой стрелке, -1 - против
    
    int survivor1, survivor2;
    
    // Решаем задачу Иосифа Флавия
    josephus_flavius(list, step, direction, &survivor1, &survivor2);
    
    // Освобождаем память
    free_list(list);
    
    return 0;
}

```

токенайз 
написать функцию tokenize(char *input, (int)(*handler)(int), int access_empty, char ***lexemes, int *lexemes_count); функция разбивает строку input на лексемы и записывает из в lexemes. функция handler проверяет, является ли символ разделителем. если access_empty != 0, то в lexemes можно записывать пустые строки, иначе нельзя. записать в переменную lexemes_count количество получившихся лексем. вставка символа в строку и вставка строки в lexemes должны работать за О(1). Показать пример в int main()
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int tokenize(char *input, int (*handler)(int), int access_empty, 
             char ***lexemes, int *lexemes_count) {
    
    if (!input || !handler || !lexemes || !lexemes_count) {
        return -1;
    }
    
    *lexemes_count = 0;
    *lexemes = NULL;
    int array_capacity = 4;
    *lexemes = (char **)malloc(array_capacity * sizeof(char *));
    if (!*lexemes) return -1;
    
    char *current = input;
    
    int buf_capacity = 16;
    char *buffer = (char *)malloc(buf_capacity);
    if (!buffer) {
        free(*lexemes);
        *lexemes = NULL;
        return -1;
    }
    int buf_len = 0;
    
    int at_start_of_token = 1;
    
    while (1) {
        if (handler(*current) || *current == '\0') {
            // ПРОСТАЯ И ПРАВИЛЬНАЯ ЛОГИКА:
            int should_save = (buf_len > 0 || (access_empty && at_start_of_token));
            
            if (should_save) {
                // Завершаем буфер
                if (buf_len >= buf_capacity) {
                    buf_capacity = buf_len + 1;
                    char *temp = (char *)realloc(buffer, buf_capacity);
                    if (!temp) goto cleanup;
                    buffer = temp;
                }
                buffer[buf_len] = '\0';
                
                // Добавляем в массив
                if (*lexemes_count >= array_capacity) {
                    array_capacity *= 2;
                    char **temp = (char **)realloc(*lexemes, array_capacity * sizeof(char *));
                    if (!temp) {
                        free(buffer);
                        goto cleanup;
                    }
                    *lexemes = temp;
                }
                (*lexemes)[*lexemes_count] = buffer;
                (*lexemes_count)++;
                
                // Новый буфер если не конец строки
                if (*current != '\0') {
                    buf_capacity = 16;
                    buffer = (char *)malloc(buf_capacity);
                    if (!buffer) goto cleanup;
                    buf_len = 0;
                    at_start_of_token = 1;
                }
            } else {
                // Не сохраняем лексему
                if (*current == '\0') {
                    free(buffer);
                }
            }
            
            if (*current == '\0') break;
            current++;
            
        } else {
            // Добавляем символ
            if (buf_len >= buf_capacity - 1) {
                buf_capacity *= 2;
                char *temp = (char *)realloc(buffer, buf_capacity);
                if (!temp) goto cleanup;
                buffer = temp;
            }
            buffer[buf_len++] = *current;
            current++;
            at_start_of_token = 0;
        }
    }
    
    return 0;
    
cleanup:
    if (*lexemes) {
        for (int i = 0; i < *lexemes_count; i++) free((*lexemes)[i]);
        free(*lexemes);
        *lexemes = NULL;
    }
    *lexemes_count = 0;
    return -1;
}

int is_comma(int ch) { return ch == ','; }

void free_tokens(char ***lexemes, int count) {
    if (!lexemes || !*lexemes) return;
    for (int i = 0; i < count; i++) free((*lexemes)[i]);
    free(*lexemes);
    *lexemes = NULL;
}

void print_tokens(char **lexemes, int count) {
    printf("[");
    for (int i = 0; i < count; i++) {
        printf("\"%s\"", lexemes[i][0] == '\0' ? "" : lexemes[i]);
        if (i < count - 1) printf(", ");
    }
    printf("]\n");
}

int main() {
    printf("=== ОКОНЧАТЕЛЬНАЯ ВЕРСИЯ ===\n\n");
    
    char **lex = NULL;
    int cnt = 0;
    
    // Все тесты
    struct {
        char *input;
        int access_empty;
        char *expected[10];
        int expected_count;
        char *description;
    } tests[] = {
        {"", 1, {""}, 1, "Пустая строка, access_empty=1 -> [\"\"]"},
        {"", 0, {}, 0, "Пустая строка, access_empty=0 -> []"},
        {",", 1, {"", ""}, 2, "Один разделитель, access_empty=1 -> [\"\", \"\"]"},
        {",", 0, {}, 0, "Один разделитель, access_empty=0 -> []"},
        {",,", 1, {"", "", ""}, 3, "Два разделителя, access_empty=1 -> [\"\", \"\", \"\"]"},
        {",,", 0, {}, 0, "Два разделителя, access_empty=0 -> []"},
        {"a", 1, {"a"}, 1, "Одна лексема без разделителей -> [\"a\"]"},
        {"a,b", 1, {"a", "b"}, 2, "Две лексемы -> [\"a\", \"b\"]"},
        {",a,,b,", 1, {"", "a", "", "b", ""}, 5, "Сложный случай -> [\"\", \"a\", \"\", \"b\", \"\"]"},
        {",a,,b,", 0, {"a", "b"}, 2, "Сложный случай без пустых -> [\"a\", \"b\"]"},
    };
    
    int all_passed = 1;
    for (int i = 0; i < sizeof(tests)/sizeof(tests[0]); i++) {
        printf("Тест %d: %s\n", i+1, tests[i].description);
        printf("  Вход: \"%s\", access_empty=%d\n", tests[i].input, tests[i].access_empty);
        
        tokenize(tests[i].input, is_comma, tests[i].access_empty, &lex, &cnt);
        
        int passed = (cnt == tests[i].expected_count);
        if (passed) {
            for (int j = 0; j < cnt; j++) {
                if (strcmp(lex[j], tests[i].expected[j]) != 0) {
                    passed = 0;
                    break;
                }
            }
        }
        
        printf("  Ожидаем: %d лексем ", tests[i].expected_count);
        print_tokens(tests[i].expected, tests[i].expected_count);
        
        printf("  Получили: %d лексем ", cnt);
        print_tokens(lex, cnt);
        
        printf("  Результат: %s\n\n", passed ? "✓ ПРОШЕЛ" : "✗ НЕ ПРОШЕЛ");
        if (!passed) all_passed = 0;
        
        free_tokens(&lex, cnt);
    }
    
    printf("=== ИТОГ: %s ===\n", all_passed ? "ВСЕ ТЕСТЫ ПРОЙДЕНЫ" : "ЕСТЬ ОШИБКИ");
    
    return 0;
}
```

## свой fprintf

```c
#include <stdio.h>
#include <stdarg.h>
#include <limits.h>

void my_fprintf(FILE* stream, const char* format, ...) {
    va_list args;
    va_start(args, format);
    
    for (const char* p = format; *p != '\0'; p++) {
        // Если не спецификатор — просто печатаем символ
        if (*p != '%') {
            fputc(*p, stream);
            continue;
        }
        
        p++; // Пропускаем '%'
        
        // Обработка %%
        if (*p == '%') {
            fputc('%', stream);
            continue;
        }
        
        switch (*p) {
            case 'd': {
                int value = va_arg(args, int);
                char buffer[12]; 
                int i = 0;
                int negative = 0;
                
                // Обработка отрицательных чисел и INT_MIN
                if (value == INT_MIN) {
                    const char* min_str = "-2147483648";
                    while (*min_str) fputc(*min_str++, stream);
                    break;
                }
                if (value < 0) {
                    negative = 1;
                    value = -value;
                }
                
                // Перевод в строку (в обратном порядке)
                do {
                    buffer[i++] = '0' + (value % 10);
                    value /= 10;
                } while (value > 0);
                
                if (negative) fputc('-', stream);
                
                // Вывод из буфера в правильном порядке
                while (--i >= 0) {
                    fputc(buffer[i], stream);
                }
                break;
            }
            
            case 's': {
                char* str = va_arg(args, char*);
                if (str == NULL) str = "(null)";
                while (*str) fputc(*str++, stream);
                break;
            }
            
            case 'c': {
                fputc(va_arg(args, int), stream);
                break;
            }
            
            default:
                fputc('%', stream);
                fputc(*p, stream);
        }
    }
    va_end(args);
}
```

## **делегирует эту работу `vsnprintf`**.
```c
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>


// Статус коды только для my_fprintf
typedef enum {
    MY_FPRINTF_SUCCESS = 0,
    MY_FPRINTF_ERROR_NULL_STREAM = -1,
    MY_FPRINTF_ERROR_NULL_FORMAT = -2,
    MY_FPRINTF_ERROR_VSNPRINTF_SIZE_FAILED = -3,
    MY_FPRINTF_ERROR_MALLOC_FAILED = -4,
    MY_FPRINTF_ERROR_VSNPRINTF_FORMAT_FAILED = -5,
    MY_FPRINTF_ERROR_FWRITE_FAILED = -6
} MyFprintfStatus;


MyFprintfStatus my_fprintf(FILE* stream, const char* format, ...) {
    if (stream == NULL) {
        return MY_FPRINTF_ERROR_NULL_STREAM;
    }

    if (format == NULL) {
        return MY_FPRINTF_ERROR_NULL_FORMAT;
    }

    va_list args;
    va_start(args, format);

    int needed_size = vsnprintf(NULL, 0, format, args);

    if (needed_size < 0) {
        va_end(args);
        return MY_FPRINTF_ERROR_VSNPRINTF_SIZE_FAILED;
    }

    char* buffer = (char*)malloc(sizeof(char) * (needed_size + 1));

    if (buffer == NULL) {
        va_end(args);
        return MY_FPRINTF_ERROR_MALLOC_FAILED;
    }

    va_end(args);
    va_start(args, format);

    int result = vsnprintf(buffer, needed_size + 1, format, args);
    va_end(args);

    if (result < 0) {
        free(buffer);
        return MY_FPRINTF_ERROR_VSNPRINTF_FORMAT_FAILED;
    }

    size_t bytes_written = fwrite(buffer, 1, result, stream);
    free(buffer);

    if (bytes_written != (size_t)result) {
        return MY_FPRINTF_ERROR_FWRITE_FAILED;
    }
    
    return MY_FPRINTF_SUCCESS;

}

```
## over_fprintf с hex float
```c
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Схема Горнера для целых чисел
char* horner_convert(unsigned long long num, int base, int uppercase) {
    if (base < 2 || base > 36) return NULL;
    
    char* buf = malloc(65); // Максимум 64 бита + '\0'
    if (!buf) return NULL;
    
    int i = 0;
    
    if (num == 0) {
        buf[i++] = '0';
    } else {
        while (num > 0) {
            unsigned int digit = num % base;
            
            if (digit < 10) {
                buf[i++] = '0' + digit;           // '0' + digit
            } else {
                if (uppercase) {
                    buf[i++] = 'A' + (digit - 10); // 'A' + (digit - 10)
                } else {
                    buf[i++] = 'a' + (digit - 10); // 'a' + (digit - 10)
                }
            }
            
            num /= base;  // СХЕМА ГОРНЕРА: делим на основание
        }
        
        // Реверс результата (цифры были в обратном порядке)
        for (int j = 0; j < i/2; j++) {
            char tmp = buf[j];
            buf[j] = buf[i - j - 1];
            buf[i - j - 1] = tmp;
        }
    }
    
    buf[i] = '\0';
    return buf;
}

// РУЧНАЯ РЕАЛИЗАЦИЯ FLOAT В HEX (IEEE 754)
char* float_to_hex_manual(double num, int uppercase) {
    char* buf = malloc(50);
    if (!buf) return NULL;
    
    // Union для доступа к битам double
    union {
        double f;
        unsigned long long u;
    } converter;
    
    converter.f = num;
    
    unsigned long long u = converter.u;
    int sign = (u >> 63) & 1;
    int exponent = (u >> 52) & 0x7FF;
    unsigned long long mantissa = u & 0xFFFFFFFFFFFFF;
    
    int pos = 0;
    
    // Префикс
    buf[pos++] = '0';
    buf[pos++] = uppercase ? 'X' : 'x';
    
    // Специальные случаи: NaN, Inf
    if (exponent == 0x7FF) {
        if (mantissa == 0) {
            // Бесконечность
            if (sign) buf[pos++] = '-';
            buf[pos++] = uppercase ? 'I' : 'i';
            buf[pos++] = uppercase ? 'N' : 'n';
            buf[pos++] = uppercase ? 'F' : 'f';
        } else {
            // NaN
            buf[pos++] = uppercase ? 'N' : 'n';
            buf[pos++] = uppercase ? 'A' : 'a';
            buf[pos++] = uppercase ? 'N' : 'n';
        }
        buf[pos] = '\0';
        return buf;
    }
    
    // Знак
    if (sign) {
        buf[pos++] = '-';
    }
    
    // Ноль
    if (exponent == 0 && mantissa == 0) {
        buf[pos++] = '0';
        buf[pos++] = '.';
        buf[pos++] = '0';
        buf[pos++] = 'p';
        buf[pos++] = '+';
        buf[pos++] = '0';
        buf[pos] = '\0';
        return buf;
    }
    
    if (exponent == 0) {
        // Денормализованные числа
        buf[pos++] = '0';
        buf[pos++] = '.';
        
        // Мантисса (13 hex цифр)
        for (int i = 12; i >= 0; i--) {
            int digit = (mantissa >> (i * 4)) & 0xF;
            
            if (digit < 10) {
                buf[pos++] = '0' + digit;
            } else {
                buf[pos++] = (uppercase ? 'A' : 'a') + (digit - 10);
            }
        }
        
        // Экспонента для денормализованных = -1022
        buf[pos++] = 'p';
        buf[pos++] = '-';
        
        // Конвертируем 1022 в строку
        char* exp_str = horner_convert(1022, 10, 0);
        if (exp_str) {
            int len = strlen(exp_str);
            memcpy(buf + pos, exp_str, len);
            pos += len;
            free(exp_str);
        }
    } else {
        // Нормализованные числа
        buf[pos++] = '1';
        buf[pos++] = '.';
        
        // Мантисса (13 hex цифр)
        for (int i = 12; i >= 0; i--) {
            int digit = (mantissa >> (i * 4)) & 0xF;
            
            if (digit < 10) {
                buf[pos++] = '0' + digit;
            } else {
                buf[pos++] = (uppercase ? 'A' : 'a') + (digit - 10);
            }
        }
        
        // Убираем trailing нули
        while (pos > 4 && buf[pos-1] == '0' && buf[pos-2] != '.') {
            pos--;
        }

        // Экспонента
        int exp_value = exponent - 1023;
        buf[pos++] = 'p';
        
        if (exp_value >= 0) {
            buf[pos++] = '+';
        } else {
            buf[pos++] = '-';
            exp_value = -exp_value;
        }
        
        // Конвертируем экспоненту в строку (схема Горнера для десятичной)
        if (exp_value == 0) {
            buf[pos++] = '0';
        } else {
            char exp_buf[10];
            int exp_pos = 0;
            
            while (exp_value > 0) {
                exp_buf[exp_pos++] = '0' + (exp_value % 10);
                exp_value /= 10;
            }
            
            // Реверс
            for (int i = exp_pos - 1; i >= 0; i--) {
                buf[pos++] = exp_buf[i];
            }
        }
    }
    
    buf[pos] = '\0';
    return buf;
}

// ОСНОВНАЯ ФУНКЦИЯ - простая и понятная
int over_fprintf_simple(FILE* stream, const char* format, ...) {
    if (!stream || !format) return -1;
    
    va_list args;
    va_start(args, format);
    
    int total = 0;
    const char* p = format;
    
    while (*p) {
        if (*p == '%') {
            p++;
            
            // Обработка кастомных спецификаторов
            if (*p == 'b') {
                // Двоичная система - наша реализация
                unsigned int num = va_arg(args, unsigned int);
                char* str = horner_convert(num, 2, 0);
                if (str) {
                    total += fwrite(str, 1, strlen(str), stream);
                    free(str);
                }
                p++;
            } 
            else if (*p == 'o') {
                // Восьмеричная система
                unsigned int num = va_arg(args, unsigned int);
                char* str = horner_convert(num, 8, 0);
                if (str) {
                    total += fwrite(str, 1, strlen(str), stream);
                    free(str);
                }
                p++;
            } 
            else if (*p == 'x') {
                // Hex нижний регистр
                unsigned int num = va_arg(args, unsigned int);
                char* str = horner_convert(num, 16, 0);
                if (str) {
                    total += fwrite(str, 1, strlen(str), stream);
                    free(str);
                }
                p++;
            } 
            else if (*p == 'X') {
                // Hex верхний регистр
                unsigned int num = va_arg(args, unsigned int);
                char* str = horner_convert(num, 16, 1);
                if (str) {
                    total += fwrite(str, 1, strlen(str), stream);
                    free(str);
                }
                p++;
            } 
            else if (*p == 'a' || *p == 'A') {
                // Float в hex - наша ручная реализация IEEE 754
                double num = va_arg(args, double);
                char* str = float_to_hex_manual(num, (*p == 'A'));
                if (str) {
                    total += fwrite(str, 1, strlen(str), stream);
                    free(str);
                }
                p++;
            } 
            else {
                // ВСЕ СТАНДАРТНЫЕ СПЕЦИФИКАТОРЫ - через vsnprintf
                char small_fmt[3] = {'%', *p, '\0'};
                char buf[256];
                va_list args_copy;
                va_copy(args_copy, args);
                
                // Форматируем стандартный спецификатор
                int len = vsnprintf(buf, sizeof(buf), small_fmt, args_copy);
                va_end(args_copy);
                
                // Пропускаем соответствующий аргумент из основного списка
                if (*p == 'd' || *p == 'i') {
                    va_arg(args, int);
                } else if (*p == 'u') {
                    va_arg(args, unsigned int);
                } else if (*p == 'f' || *p == 'e' || *p == 'g') {
                    va_arg(args, double);
                } else if (*p == 'c') {
                    va_arg(args, int);
                } else if (*p == 's') {
                    va_arg(args, char*);

                } else if (*p == 'p') {
                    va_arg(args, void*);
                } else if (*p == '%') {
                    // Процентный знак - ничего не пропускаем
                }
                
                if (len > 0) {
                    total += fwrite(buf, 1, len, stream);
                }
                p++;
            }
        } else {
            // Обычный символ
            fputc(*p, stream);
            total++;
            p++;
        }
    }
    
    va_end(args);
    return total;
}

// ТЕСТОВАЯ ФУНКЦИЯ
int main() {
    printf("=== Тест over_fprintf_simple ===\n\n");
    
    printf("1. СТАНДАРТНЫЕ СПЕЦИФИКАТОРЫ (через vsnprintf):\n");
    over_fprintf_simple(stdout, "  Десятичное: %d\n", 42);
    over_fprintf_simple(stdout, "  Беззнаковое: %u\n", 255);
    over_fprintf_simple(stdout, "  Строка: %s\n", "Hello World");
    over_fprintf_simple(stdout, "  Символ: %c\n", 'A');
    over_fprintf_simple(stdout, "  Float: %.2f\n", 3.14159);
    over_fprintf_simple(stdout, "  Научный: %e\n", 3.14159);
    over_fprintf_simple(stdout, "  Процент: %%\n");
    
    printf("\n2. КАСТОМНЫЕ СПЕЦИФИКАТОРЫ (наша реализация):\n");
    
    printf("  а) Двоичная система (схема Горнера):\n");
    over_fprintf_simple(stdout, "      42 = %b\n", 42);
    over_fprintf_simple(stdout, "      255 = %b\n", 255);
    over_fprintf_simple(stdout, "      0 = %b\n", 0);
    
    printf("\n  б) Восьмеричная система (схема Горнера):\n");
    over_fprintf_simple(stdout, "      42 = %o\n", 42);
    over_fprintf_simple(stdout, "      255 = %o\n", 255);
    
    printf("\n  в) Шестнадцатеричная система (схема Горнера):\n");
    over_fprintf_simple(stdout, "      255 = %x (нижний регистр)\n", 255);
    over_fprintf_simple(stdout, "      255 = %X (верхний регистр)\n", 255);
    over_fprintf_simple(stdout, "      0xDEADBEEF = %x\n", 0xDEADBEEF);
    
    printf("\n  г) Float в hex (ручная реализация IEEE 754):\n");
    printf("    Для сравнения стандартный printf:\n");
    printf("      1.0 = %a\n", 1.0);
    printf("      3.14 = %a\n", 3.14);
    printf("      0.0 = %a\n", 0.0);
    printf("      -3.14 = %a\n", -3.14);
    
    printf("\n    Наша реализация:\n");
    over_fprintf_simple(stdout, "      1.0 = %a\n", 1.0);
    over_fprintf_simple(stdout, "      3.14 = %a\n", 3.14);
    over_fprintf_simple(stdout, "      0.0 = %a\n", 0.0);
    over_fprintf_simple(stdout, "      -3.14 = %a\n", -3.14);
    over_fprintf_simple(stdout, "      3.14 = %A (верхний регистр)\n", 3.14);
    
    printf("\n3. СМЕШАННЫЙ ВЫВОД:\n");
    over_fprintf_simple(stdout, "  Число %d: двоичное=%b, восьмеричное=%o, hex=%x\n", 
                        42, 42, 42, 42);
    over_fprintf_simple(stdout, "  Float %f в hex: %a\n", 3.14159, 3.14159);
    
    return 0;
}

```
## вычисление в постфиксной форме
```c
#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <ctype.h>

// Структура для оператора
typedef struct {
    char* op;           // Строка-оператор
    double (*func)(double, double); // Функция для вычисления
} Operator;

// Базовые математические операции
double add(double a, double b) { return a + b; }
double subtract(double a, double b) { return a - b; }
double multiply(double a, double b) { return a * b; }
double divide(double a, double b) { 
    if (b == 0) {
        fprintf(stderr, "Ошибка: деление на ноль\n");
        return 0;
    }
    return a / b; 
}
double power(double a, double b) { return pow(a, b); }

// Стек для вычислений
typedef struct {
    double* data;
    int capacity;
    int top;
} Stack;

Stack* create_stack(int capacity) {
    // Явное приведение типа malloc + проверка
    Stack* stack = (Stack*)malloc(sizeof(Stack));
    if (stack == NULL) {
        fprintf(stderr, "Ошибка: не удалось выделить память для стека\n");
        return NULL;
    }
    
    // Явное приведение типа malloc + проверка
    stack->data = (double*)malloc(capacity * sizeof(double));
    if (stack->data == NULL) {
        fprintf(stderr, "Ошибка: не удалось выделить память для данных стека\n");
        free(stack);  // Важно освободить уже выделенную память
        return NULL;
    }
    
    stack->capacity = capacity;
    stack->top = -1;
    return stack;
}

void free_stack(Stack* stack) {
    if (stack == NULL) {
        return;  // Защита от двойного освобождения
    }
    
    if (stack->data != NULL) {
        free(stack->data);
        stack->data = NULL;  // Защита от use-after-free
    }
    
    free(stack);
}

void push(Stack* stack, double value) {
    if (stack == NULL || stack->data == NULL) {
        fprintf(stderr, "Ошибка: некорректный стек\n");
        return;
    }
    
    if (stack->top >= stack->capacity - 1) {
        fprintf(stderr, "Ошибка: переполнение стека\n");
        return;
    }
    stack->data[++stack->top] = value;
}

double pop(Stack* stack) {
    if (stack == NULL || stack->data == NULL) {
        fprintf(stderr, "Ошибка: некорректный стек\n");
        return 0;
    }
    
    if (stack->top < 0) {
        fprintf(stderr, "Ошибка: пустой стек\n");
        return 0;
    }
    return stack->data[stack->top--];
}

int is_empty(Stack* stack) {
    if (stack == NULL) return 1;
    return stack->top == -1;
}

// Вспомогательная функция для безопасного освобождения
static void cleanup(Operator* operators, Stack* stack) {
    if (operators != NULL) {
        free(operators);
    }
    if (stack != NULL) {
        free_stack(stack);
    }
}

// Основная функция вычисления постфиксного выражения
double evaluate_postfix(const char* expression, int count, ...) {
    // Проверка входных параметров
    if (expression == NULL) {
        fprintf(stderr, "Ошибка: пустое выражение\n");
        return 0;
    }
    
    if (count < 0) {
        fprintf(stderr, "Ошибка: некорректное количество операторов\n");
        return 0;
    }
    
    // Явное приведение типа malloc + проверка для массива операторов
    Operator* operators = (Operator*)malloc(count * sizeof(Operator));
    if (operators == NULL && count > 0) {
        fprintf(stderr, "Ошибка: не удалось выделить память для операторов\n");
        return 0;
    }
    
    // Получаем операторы из переменных аргументов
    va_list args;
    va_start(args, count);
    
    for (int i = 0; i < count; i++) {
        Operator op = va_arg(args, Operator);
        operators[i] = op;
    }
    
    va_end(args);
    
    // Создаем стек для вычислений с проверкой
    Stack* stack = create_stack(100);
    if (stack == NULL) {
        fprintf(stderr, "Ошибка: не удалось создать стек\n");
        free(operators);
        return 0;
    }
    
    // Буфер для чтения токенов
    char buffer[256];
    int buf_pos = 0;
    
    // Парсим выражение
    for (int i = 0; expression[i] != '\0'; i++) {
        // Пропускаем пробелы
        if (isspace(expression[i])) {
            if (buf_pos > 0) {
                buffer[buf_pos] = '\0';
                
                // Пробуем интерпретировать как число
                if (isdigit(buffer[0]) || (buffer[0] == '-' && isdigit(buffer[1]))) {
                    double num = atof(buffer);
                    push(stack, num);
                } else {
                    // Ищем оператор
                    int found = 0;
                    for (int j = 0; j < count; j++) {
                        if (strcmp(buffer, operators[j].op) == 0) {
                            if (stack->top < 1) {
                                fprintf(stderr, "Ошибка: недостаточно операндов для оператора %s\n", buffer);
                                cleanup(operators, stack);
                                return 0;
                            }
                            
                            double b = pop(stack);
                            double a = pop(stack);
                            double result = operators[j].func(a, b);
                            push(stack, result);
                            found = 1;
                            break;
                        }
                    }
                    
                    if (!found) {
                        fprintf(stderr, "Ошибка: неизвестный оператор '%s'\n", buffer);
                        cleanup(operators, stack);
                        return 0;
                    }
                }
                
                buf_pos = 0;
            }
            continue;
        }
        
        // Добавляем символ в буфер
        buffer[buf_pos++] = expression[i];
        
        // Защита от переполнения
        if (buf_pos >= 255) {
            fprintf(stderr, "Ошибка: слишком длинный токен\n");
            cleanup(operators, stack);
            return 0;
        }
    }
    
    // Обработка последнего токена
    if (buf_pos > 0) {
        buffer[buf_pos] = '\0';
        
        if (isdigit(buffer[0]) || (buffer[0] == '-' && isdigit(buffer[1]))) {
            double num = atof(buffer);
            push(stack, num);
        } else {
            int found = 0;
            for (int j = 0; j < count; j++) {
                if (strcmp(buffer, operators[j].op) == 0) {
                    if (stack->top < 1) {
                        fprintf(stderr, "Ошибка: недостаточно операндов для оператора %s\n", buffer);
                        cleanup(operators, stack);
                        return 0;
                    }
                    
                    double b = pop(stack);
                    double a = pop(stack);
                    double result = operators[j].func(a, b);
                    push(stack, result);
                    found = 1;
                    break;
                }
            }
            
            if (!found) {
                fprintf(stderr, "Ошибка: неизвестный оператор '%s'\n", buffer);
                cleanup(operators, stack);
                return 0;
            }
        }
    }
    
    // Результат должен быть единственным элементом в стеке
    if (stack->top != 0) {
        fprintf(stderr, "Ошибка: некорректное выражение\n");
        cleanup(operators, stack);
        return 0;
    }
    
    double result = pop(stack);
    
    // Очистка памяти
    cleanup(operators, stack);
    
    return result;
}

// Пример использования
int main() {
    // Определяем операторы
    Operator plus = {"+", add};
    Operator minus = {"-", subtract};
    Operator multiply_op = {"*", multiply};
    Operator divide_op = {"/", divide};
    Operator power_op = {"^", power};
    
    // Пример 1: (3 + 4) * 2 => 3 4 + 2 *
    const char* expr1 = "3 4 + 2 *";
    printf("Выражение: %s\n", expr1);
    printf("Результат: %.2f\n\n", evaluate_postfix(expr1, 4, plus, minus, multiply_op, divide_op));
    
    // Пример 2: (10 - 3) / 2 => 10 3 - 2 /
    const char* expr2 = "10 3 - 2 /";
    printf("Выражение: %s\n", expr2);
    printf("Результат: %.2f\n\n", evaluate_postfix(expr2, 4, plus, minus, multiply_op, divide_op));
    
    // Пример 3: 2 ^ 3 + 4 => 2 3 ^ 4 +
    const char* expr3 = "2 3 ^ 4 +";
    printf("Выражение: %s\n", expr3);
    printf("Результат: %.2f\n\n", evaluate_postfix(expr3, 5, plus, minus, multiply_op, divide_op, power_op));
    
    // Пример 4: сложное выражение
    const char* expr4 = "5 1 2 + 4 * + 3 -";
    printf("Выражение: %s\n", expr4);
    printf("Результат: %.2f\n\n", evaluate_postfix(expr4, 4, plus, minus, multiply_op, divide_op));
    
    return 0;
}
```


## вычисление инфиксных выражений
```c
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>
#include <math.h>

#define INITIAL_CAPACITY 10

// Стек операндов на динамическом массиве
typedef struct {
    double* data;
    int top;
    int capacity;
} OperandStack;

// Стек операторов на динамическом массиве
typedef struct {
    char* data;
    int top;
    int capacity;
} OperatorStack;

// Инициализация стека операндов
void initOperandStack(OperandStack* s) {
    s->capacity = INITIAL_CAPACITY;
    s->data = (double*)malloc(s->capacity * sizeof(double));
    if (!s->data) {
        printf("Ошибка выделения памяти\n");
        exit(1);
    }
    s->top = -1;
}

// Инициализация стека операторов
void initOperatorStack(OperatorStack* s) {
    s->capacity = INITIAL_CAPACITY;
    s->data = (char*)malloc(s->capacity * sizeof(char));
    if (!s->data) {
        printf("Ошибка выделения памяти\n");
        exit(1);
    }
    s->top = -1;
}

// Проверка на пустоту стека операндов
int isOperandEmpty(OperandStack* s) {
    return s->top == -1;
}

// Проверка на пустоту стека операторов
int isOperatorEmpty(OperatorStack* s) {
    return s->top == -1;
}

// Увеличение емкости стека операндов
void resizeOperandStack(OperandStack* s) {
    s->capacity *= 2;
    s->data = (double*)realloc(s->data, s->capacity * sizeof(double));
    if (!s->data) {
        printf("Ошибка выделения памяти\n");
        exit(1);
    }
}

// Увеличение емкости стека операторов
void resizeOperatorStack(OperatorStack* s) {
    s->capacity *= 2;
    s->data = (char*)realloc(s->data, s->capacity * sizeof(char));
    if (!s->data) {
        printf("Ошибка выделения памяти\n");
        exit(1);
    }
}

// Добавление в стек операндов
void pushOperand(OperandStack* s, double value) {
    if (s->top == s->capacity - 1) {
        resizeOperandStack(s);
    }
    s->data[++(s->top)] = value;
}

// Добавление в стек операторов
void pushOperator(OperatorStack* s, char op) {
    if (s->top == s->capacity - 1) {
        resizeOperatorStack(s);
    }
    s->data[++(s->top)] = op;
}

// Извлечение из стека операндов
double popOperand(OperandStack* s) {
    if (isOperandEmpty(s)) {
        printf("Стек операндов пуст\n");
        exit(1);
    }
    return s->data[(s->top)--];
}

// Извлечение из стека операторов
char popOperator(OperatorStack* s) {
    if (isOperatorEmpty(s)) {
        printf("Стек операторов пуст\n");
        exit(1);
    }
    return s->data[(s->top)--];
}

// Просмотр вершины стека операторов
char peekOperator(OperatorStack* s) {
    if (isOperatorEmpty(s)) {
        return '\0';
    }
    return s->data[s->top];
}

// Получение приоритета оператора
int getPriority(char op) {
    switch (op) {
        case '+':
        case '-':
            return 1;
        case '*':
        case '/':
            return 2;
        case '^':
            return 3;
        default:
            return 0;
    }
}

// Выполнение операции
double applyOperation(double a, double b, char op) {
    switch (op) {
        case '+': return a + b;
        case '-': return a - b;
        case '*': return a * b;
        case '/':
            if (b == 0) {
                printf("Ошибка: деление на ноль\n");
                exit(1);
            }
            return a / b;
        case '^': return pow(a, b);
        default:
            printf("Неизвестный оператор: %c\n", op);
            exit(1);
    }
}

// Очистка стека операндов
void freeOperandStack(OperandStack* s) {
    free(s->data);
    s->data = NULL;
    s->top = -1;
    s->capacity = 0;
}

// Очистка стека операторов
void freeOperatorStack(OperatorStack* s) {
    free(s->data);
    s->data = NULL;
    s->top = -1;
    s->capacity = 0;
}

// Вычисление выражения
double evaluateExpression(const char* expression) {
    OperandStack operands;
    OperatorStack operators;
    initOperandStack(&operands);
    initOperatorStack(&operators);
    
    int i = 0;
    int len = strlen(expression);
    
    while (i < len) {
        // Пропускаем пробелы
        if (expression[i] == ' ') {
            i++;
            continue;
        }
        
        // Если число
        if (isdigit(expression[i]) || (expression[i] == '.')) {
            char* end;
            double num = strtod(&expression[i], &end);
            pushOperand(&operands, num);
            i = end - expression;
        }
        // Если открывающая скобка
        else if (expression[i] == '(') {
            pushOperator(&operators, expression[i]);
            i++;
        }
        // Если закрывающая скобка
        else if (expression[i] == ')') {
            while (!isOperatorEmpty(&operators) && peekOperator(&operators) != '(') {
                char op = popOperator(&operators);
                double b = popOperand(&operands);
                double a = popOperand(&operands);
                pushOperand(&operands, applyOperation(a, b, op));
            }
            // Удаляем '('
            if (!isOperatorEmpty(&operators) && peekOperator(&operators) == '(') {
                popOperator(&operators);
            }
            i++;
        }
        // Если оператор
        else if (expression[i] == '+' || expression[i] == '-' || 
                 expression[i] == '*' || expression[i] == '/' || 
                 expression[i] == '^') {
            
            // Обработка унарного минуса
            if (expression[i] == '-' && (i == 0 || expression[i-1] == '(' || 
                (!isdigit(expression[i-1]) && expression[i-1] != ')'))) {
                i++;
                if (isdigit(expression[i]) || expression[i] == '.') {
                    char* end;
                    double num = strtod(&expression[i], &end);
                    pushOperand(&operands, -num);
                    i = end - expression;
                    continue;
                }
                i--; // Вернемся назад, если не число
            }
            
            while (!isOperatorEmpty(&operators) && 
                   getPriority(peekOperator(&operators)) >= getPriority(expression[i]) &&
                   peekOperator(&operators) != '(') {
                
                // Особый случай для оператора ^ (правоассоциативный)
                if (expression[i] == '^' && peekOperator(&operators) == '^') {
                    break;
                }
                
                char op = popOperator(&operators);
                double b = popOperand(&operands);
                double a = popOperand(&operands);
                pushOperand(&operands, applyOperation(a, b, op));
            }
            pushOperator(&operators, expression[i]);
            i++;
        }
        else {
            printf("Неизвестный символ: %c\n", expression[i]);
            freeOperandStack(&operands);
            freeOperatorStack(&operators);
            exit(1);
        }
    }
    
    // Выполняем оставшиеся операции
    while (!isOperatorEmpty(&operators)) {
        char op = popOperator(&operators);
        double b = popOperand(&operands);
        double a = popOperand(&operands);
        pushOperand(&operands, applyOperation(a, b, op));
    }
    
    double result = popOperand(&operands);
    
    // Очистка памяти
    freeOperandStack(&operands);
    freeOperatorStack(&operators);
    
    return result;
}

// Удаление пробелов из строки
void removeSpaces(char* str) {
    int count = 0;
    for (int i = 0; str[i]; i++) {
        if (str[i] != ' ') {
            str[count++] = str[i];
        }
    }
    str[count] = '\0';
}

int main() {
    printf("=== Калькулятор инфиксных выражений (стек на массиве) ===\n\n");
    
    // Тестовые примеры
    char* tests[] = {
        "3+4*2/(1-5)^2",    // 3.50
        "10+2*6",           // 22.00
        "(5+3)*2",          // 16.00
        "2^3+4",            // 12.00
        "-5+3",             // -2.00
        "2+3*4",            // 14.00
        "2*3+4",            // 10.00
        "2*(3+4)",          // 14.00
        "3+4*2/(1-5)^2^3"   // 3.00
    };
    
    int num_tests = sizeof(tests) / sizeof(tests[0]);
    
    for (int i = 0; i < num_tests; i++) {
        char expr[100];
        strcpy(expr, tests[i]);
        printf("Выражение: %s\n", expr);
        double result = evaluateExpression(expr);
        printf("Результат: %.2f\n\n", result);
    }
    
    // Интерактивный режим
    char input[100];
    printf("Введите выражение (или 'exit' для выхода):\n");
    
    while (1) {
        printf("> ");
        if (fgets(input, sizeof(input), stdin) == NULL) {
            break;
        }
        
        // Удаляем перевод строки
        input[strcspn(input, "\n")] = 0;
        
        if (strcmp(input, "exit") == 0) {
            break;
        }
        
        if (strlen(input) == 0) {
            continue;
        }
        
        // Удаляем пробелы для более удобного парсинга
        removeSpaces(input);
        
        double result = evaluateExpression(input);
        printf("Результат: %.2f\n", result);
    }
    
    return 0;
}
```

## задача сережи 

```c
#include <stdio.h>
#include <stdlib.h>

#define MAX_SIZE 100

// Функция для нахождения минимального элемента в строке
int findMinInRow(int matrix[MAX_SIZE][MAX_SIZE], int row, int cols) {
    int min = matrix[row][0];
    for (int j = 1; j < cols; j++) {
        if (matrix[row][j] < min) {
            min = matrix[row][j];
        }
    }
    return min;
}

// Функция для нахождения максимального элемента в столбце
int findMaxInColumn(int matrix[MAX_SIZE][MAX_SIZE], int col, int rows) {
    int max = matrix[0][col];
    for (int i = 1; i < rows; i++) {
        if (matrix[i][col] > max) {
            max = matrix[i][col];
        }
    }
    return max;
}

int main() {
    FILE *inputFile, *outputFile;
    int matrix[MAX_SIZE][MAX_SIZE];
    int rows = 0, cols = 0;
    
    // Открываем входной файл
    inputFile = fopen("input.txt", "r");
    if (inputFile == NULL) {
        printf("Ошибка: не удалось открыть файл input.txt\n");
        return 1;
    }
    
    // Считываем матрицу из файла
    char buffer[1000];
    while (fgets(buffer, sizeof(buffer), inputFile) != NULL && rows < MAX_SIZE) {
        int num;
        int count = 0;
        char *ptr = buffer;
        
        // Парсим строку
        while (sscanf(ptr, "%d", &num) == 1) {
            if (count < MAX_SIZE) {
                matrix[rows][count] = num;
                count++;
            }
            
            // Пропускаем пробелы и табуляции
            while (*ptr == ' ' || *ptr == '\t' || *ptr == '\n') ptr++;
            while (*ptr != ' ' && *ptr != '\t' && *ptr != '\n' && *ptr != '\0') ptr++;
            while (*ptr == ' ' || *ptr == '\t' || *ptr == '\n') ptr++;
            
            if (*ptr == '\0') break;
        }
        
        if (rows == 0) {
            cols = count; // Запоминаем количество столбцов из первой строки
        } else if (count != cols) {
            printf("Ошибка: несовпадение количества элементов в строках\n");
            fclose(inputFile);
            return 1;
        }
        
        rows++;
    }
    
    fclose(inputFile);
    
    // Проверяем, что матрица была считана
    if (rows == 0 || cols == 0) {
        printf("Ошибка: файл пуст или содержит некорректные данные\n");
        return 1;
    }
    
    // Выводим матрицу на экран
    printf("Считанная матрица (%d x %d):\n", rows, cols);
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            printf("%4d ", matrix[i][j]);
        }
        printf("\n");
    }
    
    // Открываем выходной файл
    outputFile = fopen("output.txt", "w");
    if (outputFile == NULL) {
        printf("Ошибка: не удалось создать файл output.txt\n");
        return 1;
    }
    
    // Ищем элементы, которые являются минимальными в строке и максимальными в столбце
    printf("\nЭлементы, минимальные в строке и максимальные в столбце:\n");
    fprintf(outputFile, "Элементы матрицы, минимальные в строке и максимальные в столбце:\n");
    int found = 0;
    
    for (int i = 0; i < rows; i++) {
        int rowMin = findMinInRow(matrix, i, cols);
        
        for (int j = 0; j < cols; j++) {
            if (matrix[i][j] == rowMin) {
                int colMax = findMaxInColumn(matrix, j, rows);
                
                if (matrix[i][j] == colMax) {
                    printf("Элемент [%d][%d] = %d\n", i, j, matrix[i][j]);
                    fprintf(outputFile, "Элемент [%d][%d] = %d\n", i, j, matrix[i][j]);
                    found = 1;
                }
            }
        }
    }
    
    if (!found) {
        printf("Таких элементов не найдено\n");
        fprintf(outputFile, "Таких элементов не найдено\n");
    }
    
    fclose(outputFile);
    printf("\nРезультат записан в файл output.txt\n");
    
    return 0;
}
```

## Считывание матрицы из файла, вычисление ее размеров, заполнение пропущенных элементов нулями и вывод транспонированной матрицы

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_LINE_LENGTH 1024

int main() {
    FILE *file, *output_file;
    char filename[100];
    int **matrix = NULL;
    int **transposed = NULL;
    int rows = 0, cols = 0;
    int max_cols = 0;
    char line[MAX_LINE_LENGTH];
    
    printf("Введите имя файла с матрицей: ");
    scanf("%s", filename);
    
    file = fopen(filename, "r");
    if (file == NULL) {
        printf("Ошибка: не удалось открыть файл %s\n", filename);
        return 1;
    }
    
    // Первый проход: определение размеров
    while (fgets(line, sizeof(line), file) != NULL) {
        int col = 0;
        char *token = strtok(line, " \t\n");
        
        while (token != NULL) {
            col++;
            token = strtok(NULL, " \t\n");
        }
        
        if (col > max_cols) {
            max_cols = col;
        }
        
        rows++;
    }
    
    cols = max_cols;
    
    // Выделение памяти
    matrix = (int **)malloc(rows * sizeof(int *));
    for (int i = 0; i < rows; i++) {
        matrix[i] = (int *)malloc(cols * sizeof(int));
        // Явная инициализация всех элементов нулями
        for (int j = 0; j < cols; j++) {
            matrix[i][j] = 0;
        }
    }
    
    // Возврат к началу файла
    rewind(file);
    
    // Второй проход: чтение данных
    int current_row = 0;
    while (fgets(line, sizeof(line), file) != NULL && current_row < rows) {
        int col = 0;
        char *token = strtok(line, " \t\n");
        
        while (token != NULL && col < cols) {
            matrix[current_row][col] = atoi(token);
            col++;
            token = strtok(NULL, " \t\n");
        }
        
        current_row++;
    }
    
    fclose(file);
    
    // Вывод исходной матрицы
    printf("Исходная матрица (%d x %d):\n", rows, cols);
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            printf("%4d ", matrix[i][j]);
        }
        printf("\n");
    }
    
    // Выделение памяти для транспонированной матрицы
    transposed = (int **)malloc(cols * sizeof(int *));
    for (int i = 0; i < cols; i++) {
        transposed[i] = (int *)malloc(rows * sizeof(int));
    }
    
    // Транспонирование
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            transposed[j][i] = matrix[i][j];
        }
    }
    
    // Вывод транспонированной матрицы
    printf("\nТранспонированная матрица (%d x %d):\n", cols, rows);
    for (int i = 0; i < cols; i++) {
        for (int j = 0; j < rows; j++) {
            printf("%4d ", transposed[i][j]);
        }
        printf("\n");
    }
    
    // Запись результатов в выходной файл
    output_file = fopen("output.txt", "w");
    if (output_file == NULL) {
        printf("Ошибка: не удалось создать выходной файл\n");
    } else {
        fprintf(output_file, "Исходная матрица (%d x %d):\n", rows, cols);
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                fprintf(output_file, "%4d ", matrix[i][j]);
            }
            fprintf(output_file, "\n");
        }
        
        fprintf(output_file, "\nТранспонированная матрица (%d x %d):\n", cols, rows);
        for (int i = 0; i < cols; i++) {
            for (int j = 0; j < rows; j++) {
                fprintf(output_file, "%4d ", transposed[i][j]);
            }
            fprintf(output_file, "\n");
        }
        
        fclose(output_file);
        printf("\nРезультаты записаны в файл 'output.txt'\n");
    }
    
    // Освобождение памяти
    for (int i = 0; i < rows; i++) {
        free(matrix[i]);
    }
    free(matrix);
    
    for (int i = 0; i < cols; i++) {
        free(transposed[i]);
    }
    free(transposed);
    
    return 0;
}
```

## На языке С опишите типы структур для  
- элемента односвязного списка (со значением типа tvalue) - ul item  
- односвязного списка - ul  
Реализуйте функцию поиска всех элементов списка, удовлетворяющих переданному предикату. Прототиг  
функции:  
int find_by(ul* where, int (*predicate)(tvalue value), ul* result);  
Элементы, удовлетворяющие предикату, необходимо скопировать в результирующий список так, чтобы он был  
независим от входного списка в контексте вызова.  
Обработайте всевозможные ошибки, которые могут возникнуть при выполнении функции.  
Продемонстрируйте вызов функции.
```c
#include <stdio.h>
#include <stdlib.h>

// Тип значения элемента списка
typedef int tvalue;

// Элемент односвязного списка
typedef struct ul_item {
    tvalue value;           // Значение элемента
    struct ul_item* next;   // Указатель на следующий элемент
} ul_item;

// Односвязный список
typedef struct ul {
    ul_item* head;          // Указатель на первый элемент
    ul_item* tail;          // Указатель на последний элемент (для быстрого добавления)
    size_t size;            // Количество элементов в списке
} ul;

// Функция для создания нового элемента списка
static ul_item* create_item(tvalue value) {
    ul_item* new_item = (ul_item*)malloc(sizeof(ul_item));
    if (!new_item) return NULL;
    
    new_item->value = value;
    new_item->next = NULL;
    return new_item;
}

// Функция для инициализации списка
void ul_init(ul* list) {
    if (!list) return;
    list->head = NULL;
    list->tail = NULL;
    list->size = 0;
}

// Функция для добавления элемента в конец списка
int ul_append(ul* list, tvalue value) {
    if (!list) return 0;
    
    ul_item* new_item = create_item(value);
    if (!new_item) return 0;
    
    if (list->head == NULL) {
        list->head = new_item;
        list->tail = new_item;
    } else {
        list->tail->next = new_item;
        list->tail = new_item;
    }
    
    list->size++;
    return 1;
}

// Функция для освобождения памяти, занятой списком
void ul_clear(ul* list) {
    if (!list) return;
    
    ul_item* current = list->head;
    while (current) {
        ul_item* next = current->next;
        free(current);
        current = next;
    }
    
    list->head = NULL;
    list->tail = NULL;
    list->size = 0;
}

// Функция поиска элементов по предикату
int find_by(ul* where, int (*predicate)(tvalue value), ul* result) {
    // Проверка входных параметров
    if (!where || !predicate || !result) {
        return 0; // Невалидные параметры
    }
    
    // Очищаем результат (на случай, если там что-то было)
    ul_clear(result);
    
    ul_item* current = where->head;
    
    while (current) {
        // Проверяем, удовлетворяет ли элемент предикату
        if (predicate(current->value)) {
            // Создаем копию элемента для нового списка
            ul_item* new_item = create_item(current->value);
            if (!new_item) {
                // Если не удалось выделить память, очищаем результат и возвращаем ошибку
                ul_clear(result);
                return 0;
            }
            
            // Добавляем элемент в результат
            if (result->head == NULL) {
                result->head = new_item;
                result->tail = new_item;
            } else {
                result->tail->next = new_item;
                result->tail = new_item;
            }
            result->size++;
        }
        current = current->next;
    }
    
    return 1; // Успешное выполнение
}

// Примеры предикатов для тестирования
int is_even(tvalue value) {
    return value % 2 == 0;
}

int is_positive(tvalue value) {
    return value > 0;
}

int is_greater_than_5(tvalue value) {
    return value > 5;
}

// Вспомогательная функция для печати списка
void print_list(const ul* list, const char* name) {
    if (!list) {
        printf("%s: NULL\n", name);
        return;
    }
    
    printf("%s (size: %zu): ", name, list->size);
    
    ul_item* current = list->head;
    while (current) {
        printf("%d", current->value);
        if (current->next) printf(" -> ");
        current = current->next;
    }
    printf("\n");
}


// Демонстрация вызова функции
int main() {
    // Создаем и заполняем исходный список
    ul source_list, result_list;
    
    ul_init(&source_list);
    ul_init(&result_list);
    
    // Добавляем элементы в исходный список
    for (int i = 1; i <= 10; i++) {
        if (!ul_append(&source_list, i)) {
            fprintf(stderr, "Ошибка при добавлении элемента %d\n", i);
            ul_clear(&source_list);
            return 1;
        }
    }
    
    printf("Исходный список:\n");
    print_list(&source_list, "source_list");
    
    printf("\n1. Поиск четных чисел:\n");
    if (find_by(&source_list, is_even, &result_list)) {
        print_list(&result_list, "even_numbers");
    } else {
        printf("Ошибка при выполнении find_by\n");
    }
    
    printf("\n2. Поиск положительных чисел:\n");
    ul_clear(&result_list); // Очищаем предыдущий результат
    if (find_by(&source_list, is_positive, &result_list)) {
        print_list(&result_list, "positive_numbers");
    } else {
        printf("Ошибка при выполнении find_by\n");
    }
    
    printf("\n3. Поиск чисел больше 5:\n");
    ul_clear(&result_list);
    if (find_by(&source_list, is_greater_than_5, &result_list)) {
        print_list(&result_list, "greater_than_5");
    } else {
        printf("Ошибка при выполнении find_by\n");
    }
    
    printf("\n4. Тест с пустым списком:\n");
    ul empty_list, empty_result;
    ul_init(&empty_list);
    ul_init(&empty_result);
    
    if (find_by(&empty_list, is_even, &empty_result)) {
        print_list(&empty_result, "empty_result");
    }
    
    printf("\n5. Тест обработки ошибок (невалидные параметры):\n");
    // Передача NULL вместо списка
    if (!find_by(NULL, is_even, &result_list)) {
        printf("Корректно обработана ошибка: NULL список\n");
    }
    
    // Передача NULL вместо предиката
    if (!find_by(&source_list, NULL, &result_list)) {
        printf("Корректно обработана ошибка: NULL предикат\n");
    }
    
    // Передача NULL вместо результата
    if (!find_by(&source_list, is_even, NULL)) {
        printf("Корректно обработана ошибка: NULL результат\n");
    }
    
    // Освобождение памяти
    ul_clear(&source_list);
    ul_clear(&result_list);
    ul_clear(&empty_list);
    ul_clear(&empty_result);
    
    return 0;
}
```

### Пример работы программы:

text

Исходный список:
source_list (size: 10): 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9 -> 10

1. Поиск четных чисел:
even_numbers (size: 5): 2 -> 4 -> 6 -> 8 -> 10

2. Поиск положительных чисел:
positive_numbers (size: 10): 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8 -> 9 -> 10

3. Поиск чисел больше 5:
greater_than_5 (size: 5): 6 -> 7 -> 8 -> 9 -> 10

4. Тест с пустым списком:
empty_result (size: 0): 

5. Тест обработки ошибок:
Корректно обработана ошибка: NULL список
Корректно обработана ошибка: NULL предикат
Корректно обработана ошибка: NULL результат

---


## Структура односвязного списка. Написать функцию int calc_accum(list* first, type** result, type init_accum, type (*accum)(type init_acc, type current_acc), int direction, int (*condition)(type item)); Если direction==0, то на вход даётся указатель на первый элемент двусвязного списка, иначе даётся на последний. Обработать все возможные ошибки, проверить входных указатели на NULL, вернуть не 0 в этом случае



```c
#include <stdio.h>
#include <stdlib.h>

// Определим тип данных для списка (например, int)
typedef int type;

// Структура узла двусвязного списка
typedef struct Node {
    type data;
    struct Node* next;
    struct Node* prev;
} Node;

// Основная функция накопления (fold/reduce)
int calc_accum(
    Node* entry_point,           // Точка входа (первый или последний)
    type** result,               // Указатель на результат (выделяем память)
    type init_accum,             // Начальное значение аккумулятора
    type (*accum)(type acc, type curr), // Функция накопления
    int direction,               // 0 - вперед, иначе - назад
    int (*condition)(type item)  // Предикат (условие)
) {
    // 1. Проверка входных указателей на NULL
    if (entry_point == NULL || result == NULL || accum == NULL || condition == NULL) {
        return 1; // Возвращаем ненулевое значение при ошибке
    }

    // 2. Выделение памяти под результат
    *result = (type*)malloc(sizeof(type));
    if (*result == NULL) {
        return 2; // Ошибка выделения памяти
    }

    type current_res = init_accum;
    Node* current_node = entry_point;

    // 3. Обход списка
    while (current_node != NULL) {
        // Проверяем условие для текущего элемента
        if (condition(current_node->data)) {
            current_res = accum(current_res, current_node->data);
        }

        // Выбор направления движения
        if (direction == 0) {
            current_node = current_node->next;
        } else {
            current_node = current_node->prev;
        }
    }

    // 4. Запись итогового значения
    **result = current_res;

    return 0; // Успешное завершение
}

// --- Примеры вспомогательных функций ---

type sum_func(type acc, type curr) { return acc + curr; }
int is_even(type item) { return item % 2 == 0; }

int main() {
    // Демонстрация создания простого списка: [10] <-> [21] <-> [30]
    Node n1 = {10, NULL, NULL}, n2 = {21, NULL, &n1}, n3 = {30, NULL, &n2};
    n1.next = &n2; n2.next = &n3;

    type* result = NULL;
    
    // Считаем сумму четных чисел, начиная с первого элемента
    int status = calc_accum(&n1, &result, 0, sum_func, 0, is_even);

    if (status == 0) {
        printf("Result: %d\n", *result);
        free(result);
    } else {
        printf("Error code: %d\n", status);
    }

    return 0;
}
```

## ДЕМО

![[Pasted image 20251219164216.png]]


![[Pasted image 20251219164323.png]]

![[Pasted image 20251219164354.png]]



```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

// Структура для хранения строки матрицы
typedef struct {
    int* data;
    int length;
} MatrixRow;

int main(int argc, char* argv[]) {
    if (argc < 3) {
        printf("Использование: %s <input_file> <output_file>\n", argv[0]);
        return 1;
    }

    FILE *fin = fopen(argv[1], "r");
    FILE *fout = fopen(argv[2], "w");

    if (!fin || !fout) {
        printf("Ошибка открытия файлов.\n");
        if (fin) fclose(fin);
        if (fout) fclose(fout);
        return 1;
    }

    MatrixRow* rows = NULL;
    int row_count = 0;
    int max_cols = 0;

    char line[4096]; // Буфер для чтения строки файла
    while (fgets(line, sizeof(line), fin)) {
        // Увеличиваем массив структур строк
        rows = realloc(rows, (row_count + 1) * sizeof(MatrixRow));
        rows[row_count].data = NULL;
        rows[row_count].length = 0;

        char* ptr = line;
        int val;
        int offset;

        // Извлекаем числа из строки
        while (sscanf(ptr, "%d%n", &val, &offset) == 1) {
            rows[row_count].data = realloc(rows[row_count].data, (rows[row_count].length + 1) * sizeof(int));
            rows[row_count].data[rows[row_count].length] = val;
            rows[row_count].length++;
            ptr += offset;
        }

        if (rows[row_count].length > max_cols) {
            max_cols = rows[row_count].length;
        }
        
        if (rows[row_count].length > 0) {
            row_count++;
        }
    }

    // Вывод размеров в стандартный поток
    printf("Размеры матрицы: %d строк, %d столбцов\n", row_count, max_cols);

    // Вывод индексов и элементов в выходной файл
    // Согласно условию: недостающие элементы считаются нулями
    for (int i = 0; i < row_count; i++) {
        for (int j = 0; j < max_cols; j++) {
            int current_val = (j < rows[i].length) ? rows[i].data[j] : 0;
            // Выводим: [строка][столбец] = значение
            fprintf(fout, "[%d][%d] = %d\n", i, j, current_val);
        }
    }

    // Очистка памяти
    for (int i = 0; i < row_count; i++) {
        free(rows[i].data);
    }
    free(rows);
    fclose(fin);
    fclose(fout);

    return 0;
}
```