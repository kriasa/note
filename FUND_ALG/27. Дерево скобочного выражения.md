Дерево скобочного выражения. Вычисление арифметических выражений с помощью деревьев. Алгоритм конвертации строкового представления арифметического выражения, записанного в инфиксной форме, в дерево арифметического выражения. Алгоритм вычисления значения арифметического выражения по его дереву.


### 1. Что такое дерево арифметического выражения?

Это бинарное дерево, в котором:

- **Листья** (конечные узлы) содержат **операнды** (числа или переменные).
- **Внутренние узлы** содержат **операторы** ($+$, $-$, $*$, $/$).
    
Для каждого оператора его левый потомок — это левый аргумент, а правый потомок — правый аргумент.

**Пример:** Выражение $(2 \times (3 + 4))$

---

### 2. Конвертация инфиксной записи в дерево

Прямой перевод из инфиксной формы (где оператор между числами) в дерево сложен из-за приоритетов и скобок. Обычно этот процесс разбивают на два этапа:

#### Этап А: Перевод в ОПЗ (Обратную польскую запись)

Используется **алгоритм «Сортировочная станция» (Shunting-yard)** Эдсгера Дейкстры.

- Числа отправляются в выходную очередь.
- Операторы складываются в стек с учетом приоритета.
- Скобки управляют выталкиванием операторов из стека.
    

#### Этап Б: Построение дерева из ОПЗ

Имея выражение в постфиксной форме (например, `2 3 4 + *`), мы используем стек узлов:

1. Читаем символ.
2. Если это **число**: создаем узел-лист и кладем его в стек.
3. Если это **оператор**:
    
    - Достаем из стека два узла (это будут правый и левый потомки).
    - Создаем новый узел с этим оператором.
    - Привязываем к нему потомков и кладем этот «куст» обратно в стек.
        
4. В конце в стеке останется один узел — **корень** всего дерева.
    

---

### 3. Алгоритм вычисления значения по дереву

Вычисление дерева — это классический пример **рекурсивного обхода**. Чтобы узнать значение корня, нужно сначала узнать значения его детей. Это **постфиксный обход** (Post-order traversal): Лево → Право → Узел.

**Логика функции `evaluate(node)`:**

1. Если узел — **число**, вернуть его значение.
    
2. Если узел — **оператор**:
    
    - $L = \text{evaluate}(\text{node.left})$
    - $R = \text{evaluate}(\text{node.right})$
    - Вернуть результат применения оператора к $L$ и $R$.
        

---

### 4. Реализация на языке C

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

// Структура узла дерева
typedef struct Node {
    char op;            // Оператор (+, -, *, /) или '\0' для чисел
    int value;          // Значение (если это число)
    struct Node *left;
    struct Node *right;
} Node;

// Вспомогательная функция для создания нового узла
Node* createNode(char op, int val) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->op = op;
    newNode->value = val;
    newNode->left = newNode->right = NULL;
    return newNode;
}

// Рекурсивное освобождение памяти дерева
void freeTree(Node* root) {
    if (root == NULL) return;
    freeTree(root->left);
    freeTree(root->right);
    free(root);
}

// Приоритет операций
int priority(char op) {
    if (op == '+' || op == '-') return 1;
    if (op == '*' || op == '/') return 2;
    return 0;
}

// 1 & 2. КОНВЕРТАЦИЯ: Инфиксная форма -> Дерево
// Используем алгоритм сортировочной станции, но вместо вывода строки строим узлы
Node* buildTreeFromInfix(const char* infix) {
    Node* nodesStack[100]; // Стек для узлов дерева
    char opsStack[100];    // Стек для операторов
    int nTop = -1, oTop = -1;

    // Вспомогательная функция для "схлопывания" оператора в узел дерева
    void processOp() {
        Node* newNode = createNode(opsStack[oTop--], 0);
        newNode->right = nodesStack[nTop--];
        newNode->left = nodesStack[nTop--];
        nodesStack[++nTop] = newNode;
    }

    for (int i = 0; infix[i] != '\0'; i++) {
        if (isspace(infix[i])) continue;

        if (isdigit(infix[i])) {
            int val = 0;
            while (isdigit(infix[i])) {
                val = val * 10 + (infix[i++] - '0');
            }
            i--; // Возврат указателя после цикла
            nodesStack[++nTop] = createNode('\0', val);
        } 
        else if (infix[i] == '(') {
            opsStack[++oTop] = '(';
        } 
        else if (infix[i] == ')') {
            while (oTop >= 0 && opsStack[oTop] != '(') {
                processOp();
            }
            oTop--; // Удаляем '('
        } 
        else { // Оператор (+, -, *, /)
            while (oTop >= 0 && priority(opsStack[oTop]) >= priority(infix[i])) {
                processOp();
            }
            opsStack[++oTop] = infix[i];
        }
    }

    while (oTop >= 0) {
        processOp();
    }

    return nodesStack[nTop]; // Корень дерева
}

// 3. ВЫЧИСЛЕНИЕ: Алгоритм вычисления значения по дереву
int evaluate(Node* root) {
    if (root == NULL) return 0;
    
    // Если это лист (число)
    if (root->left == NULL && root->right == NULL) {
        return root->value;
    }

    // Рекурсивно вычисляем левое и правое поддеревья
    int leftVal = evaluate(root->left);
    int rightVal = evaluate(root->right);

    switch (root->op) {
        case '+': return leftVal + rightVal;
        case '-': return leftVal - rightVal;
        case '*': return leftVal * rightVal;
        case '/': 
            if (rightVal == 0) {
                printf("Ошибка: Деление на ноль!\n");
                exit(1);
            }
            return leftVal / rightVal;
    }
    return 0;
}

int main() {
    char expression[100];
    printf("Введите арифметическое выражение (например, (2+3)*4 ): ");
    fgets(expression, 100, stdin);
    expression[strcspn(expression, "\n")] = 0; // Удаление символа переноса

    // Строим дерево
    Node* root = buildTreeFromInfix(expression);

    // Вычисляем результат
    int result = evaluate(root);
    printf("Результат вычисления по дереву: %d\n", result);

    // Освобождаем память
    freeTree(root);
    printf("Память успешно очищена.\n");

    return 0;
}
```

Давай разберем работу этого кода на классическом примере выражения: **`(2 + 3) * 4`**.

Этот пример хорош тем, что в нем есть и приоритет операций (умножение), и скобки, которые этот приоритет меняют.

---

### 1. Этап построения дерева (Функция `buildTreeFromInfix`)

Код читает строку слева направо. Для этого он использует два "хранилища": **Стек узлов** (куда кладем готовые части дерева) и **Стек операторов** (где временно держим знаки и скобки).

**Шаг 1: Видим `(`**

- Кладём `(` в стек операторов.
    
- _Стек опер:_ `(` | _Стек узлов:_ (пусто)
    

**Шаг 2: Видим `2`**

- Создаем узел-лист с числом `2`. Кладём его в стек узлов.
    
- _Стек опер:_ `(` | _Стек узлов:_ `[2]`
    

**Шаг 3: Видим `+`**

- Кладём `+` в стек операторов.
    
- _Стек опер:_ `(`, `+` | _Стек узлов:_ `[2]`
    

**Шаг 4: Видим `3`**

- Создаем узел с числом `3`. Кладём в стек узлов.
    
- _Стек опер:_ `(`, `+` | _Стек узлов:_ `[2]`, `[3]`
    

**Шаг 5: Видим `)`**

- Это сигнал: "пора закрывать скобку". Мы достаем `+` из стека операторов и создаем для него узел.
    
- Его **правой** рукой берем `3` (верхний из стека узлов), а **левой** — `2`.
    
- Получившийся "мини-куст" `(2+3)` кладем обратно в стек узлов.
    
- _Стек опер:_ (пусто) | _Стек узлов:_ `[(2+3)]`
    

**Шаг 6: Видим `*`**

- Кладём `*` в стек операторов.
    
- _Стек опер:_ `*` | _Стек узлов:_ `[(2+3)]`
    

**Шаг 7: Видим `4`**

- Создаем узел `4`, кладем в стек.
    
- _Стек опер:_ `*` | _Стек узлов:_ `[(2+3)]`, `[4]`
    

**Финал построения:**

- Строка закончилась. Достаем последний оператор `*`.
    
- Его правой рукой берем `4`, а левой — наш куст `(2+3)`.
    
- Теперь в стеке один единственный узел — это **корень** всего дерева (`*`).
    

---

### 2. Этап вычисления (Функция `evaluate`)

Теперь включается рекурсия. Она работает по принципу "снизу вверх".

1. **Вызов для корня `*`**: "Чтобы умножить, мне нужно знать, что слева и что справа".
    
2. **Идем влево**: Там узел `+`. Он говорит: "Чтобы сложить, мне нужно знать числа".
    
3. **Идем еще глубже**:
    
    - Слева от `+` число `2`. Возвращаем его.
        
    - Справа от `+` число `3`. Возвращаем его.
        
4. **Считаем узел `+`**: $2 + 3 = 5$. Результат `5` возвращается наверх к корню.
    
5. **Идем вправо от корня**: Там число `4`. Возвращаем его.
    
6. **Финальный расчет**: Корень умножает пришедшую пятерку на четверку: $5 \times 4 = 20$.
    

---

### 3. Этап очистки (Функция `freeTree`)

Это очень важный момент для Си. Программа не может просто "забыть" дерево.

- Функция заходит в корень `*`.
    
- Она говорит: "Я не могу удалиться, пока живы мои дети".
    
- Она спускается к самому низу (к `2`, `3`, `4`) и удаляет их с помощью `free()`.
    
- Только когда листья удалены, она удаляет узел `+`.
    
- И в самом конце удаляется корень `*`.
![[Pasted image 20251219010823.png]]

---

### 5. Вычислительная сложность

- **Построение дерева:** $O(n)$, где $n$ — количество символов в выражении. Мы один раз проходим по строке и совершаем константные операции со стеком.
    
- **Вычисление (Evaluation):** $O(n)$, так как мы посещаем каждый узел дерева ровно один раз.
    
- **Память:** $O(n)$ для хранения всех узлов дерева.
    

### Главные тезисы для ответа:

1. **Дерево отражает иерархию:** Операции с низким приоритетом ($+$, $-$) обычно находятся ближе к корню, а с высоким ($*$, $/$) или в скобках — глубже в листьях.
    
2. **Дерево убирает неоднозначность:** В дереве не нужны скобки, так как структура связей однозначно определяет порядок действий.
    
3. **Связь с обходами:** * _Инфиксный обход_ дерева дает исходное выражение.
    
    - _Постфиксный обход_ дает выражение в ОПЗ.
        
    - _Префиксный обход_ дает польскую нотацию.