Отношение порядка на пространстве элементов. Кастомизация операции отношения порядка для заданного контекста в языке C. Быстрая сортировка и функция qsort. Алгоритм дихотомического поиска, его алгоритмическая сложность.

---
## 1. Отношение порядка и его кастомизация в Си

**Отношение порядка** — это правило, которое позволяет определить для любых двух элементов $a$ и $b$, в каком отношении они находятся: $a < b$, $a > b$ или $a = b$.

В языке Си для кастомизации этого правила используется **функция-компаратор**. Это функция, которая принимает два указателя и возвращает целое число:

- **< 0**, если первый элемент «меньше» второго.
- **0**, если элементы «равны».
- **> 0**, если первый элемент «больше» второго.
    

Это позволяет сортировать любые данные (числа, строки, структуры) по любым критериям.

---

## 2. Быстрая сортировка и функция `qsort`

**Быстрая сортировка (Quick Sort)** — это алгоритм «разделяй и властвуй». Он выбирает опорный элемент (pivot) и перераспределяет массив так, чтобы слева были элементы меньше опорного, а справа — больше.

- **Средняя сложность**: $O(n \log n)$.
- **Худшая сложность**: $O(n^2)$ (редко, при неудачном выборе опорного элемента).
![[Pasted image 20251219003946.png]]
![[Pasted image 20251219004012.png]]
```c
int partition(int arr[], int low, int high) {
    int pivot = arr[high]; // Опорный элемент
    int i = (low - 1);    // Индекс меньшего элемента

    for (int j = low; j < high; j++) {
        // Если текущий элемент меньше или равен опорному
        if (arr[j] <= pivot) {
            i++; 
            // Меняем местами arr[i] и arr[j]
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }
    }
    // Ставим опорный элемент на его место (в середину)
    int temp = arr[i + 1];
    arr[i + 1] = arr[high];
    arr[high] = temp;

    return (i + 1); // Возвращаем индекс опоры
}

void quickSort(int arr[], int low, int high) {
    if (low < high) {
        // pi - индекс разделения
        int pi = partition(arr, low, high);

        // Рекурсивно сортируем левую и правую части
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}
```
### 1. Выбор опорного элемента (Pivot)

Допустим, у нас есть массив: `[3, 5, 8, 1, 2, 9, 4, 7, 6]`. Выберем в качестве **pivot** последний элемент: **6**.

### 2. Процесс разделения (Partitioning)

Мы используем два указателя (или индекса). Один («медленный» — `i`) отмечает границу элементов, которые точно меньше 6. Второй («быстрый» — `j`) бежит по всему массиву и сравнивает числа с нашей шестеркой.

- **Начало:** `i` стоит перед первым элементом. `j` указывает на `3`.
    
- **Сравнение:** `3 < 6`? Да. Увеличиваем `i`, меняем местами `data[i]` и `data[j]`. (3 остается на месте).
    
- **Сравнение:** `5 < 6`? Да. `i` двигается, 5 остается на месте.
    
- **Сравнение:** `8 < 6`? Нет. Ничего не делаем, `j` идет дальше.
    
- **Сравнение:** `1 < 6`? Да. Увеличиваем `i` (теперь он указывает на 8). Меняем местами **8** и **1**.
    
    - _Массив сейчас:_ `[3, 5, 1, 8, 2, 9, 4, 7, 6]`
        
- **Сравнение:** `2 < 6`? Да. Увеличиваем `i` (указывает на 8). Меняем местами **8** и **2**.
    
    - _Массив сейчас:_ `[3, 5, 1, 2, 8, 9, 4, 7, 6]`
        
- **Сравнение:** `9 < 6`? Нет.
    
- **Сравнение:** `4 < 6`? Да. Увеличиваем `i` (указывает на 8). Меняем местами **8** и **4**.
    
    - _Массив сейчас:_ `[3, 5, 1, 2, 4, 9, 8, 7, 6]`
        
- **Финал прохода:** Ставим **pivot (6)** сразу после `i`. Меняем местами **9** (первый элемент, который больше 6) и **6**.
    
    - _Итог прохода:_ `[3, 5, 1, 2, 4] | 6 | [8, 7, 9]`
        

---

### 3. Результат прохода

После одного такого прохода число **6** заняло своё **окончательное место** в отсортированном массиве.

- Все числа слева (`3, 5, 1, 2, 4`) — меньше 6.
    
- Все числа справа (`8, 7, 9`) — больше 6.
    

Теперь алгоритм **рекурсивно** повторяет то же самое отдельно для левой части и отдельно для правой.
В стандартной библиотеке Си (`stdlib.h`) реализована универсальная функция `qsort`.

### Прототип `qsort`:
![[Pasted image 20251219003604.png]]

```c
void qsort(void *base, size_t nmemb, size_t size, 
           int (*compar)(const void *, const void *));
```

### Пример: Сортировка структуры «Студент» по возрасту

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct {
    char name[50];
    int age;
} Student;

// Функция-компаратор: кастомизация порядка
int compare_students(const void *a, const void *b) {
    Student *s1 = (Student *)a;
    Student *s2 = (Student *)b;
    // Сортировка по возрастанию возраста
    return s1->age - s2->age;
}

int main() {
    Student group[] = { {"Ivan", 20}, {"Anna", 18}, {"Petr", 19} };
    int n = 3;

    qsort(group, n, sizeof(Student), compare_students);

    for(int i = 0; i < n; i++) 
        printf("%s (%d)\n", group[i].name, group[i].age);
    
    return 0;
}
```

---

## 3. Алгоритм дихотомического (бинарного) поиска

**Дихотомический поиск** — это эффективный метод поиска элемента в **отсортированном** массиве.

**Алгоритм**:

1. Найти середину массива.
2. Если искомое значение равно среднему — поиск окончен.
3. Если искомое меньше среднего — отбросить правую половину и повторить поиск в левой.
4. Если искомое больше среднего — отбросить левую половину и искать в правой.
    

### Реализация на Си:

```c
int binary_search(int arr[], int n, int target) {
    int left = 0, right = n - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2; // Защита от переполнения
        
        if (arr[mid] == target) return mid; // Нашли
        if (arr[mid] < target) left = mid + 1;
        else right = mid - 1;
    }
    return -1; // Не нашли
}
```

### Алгоритмическая сложность поиска:

- **Временная сложность**: $O(\log n)$. Это означает, что для массива из 1 000 000 элементов потребуется максимум 20 проверок.
- **Пространственная сложность**: $O(1)$ для итеративного подхода.
- **Главное условие**: массив **обязательно** должен быть отсортирован.


![[Pasted image 20251219003508 1.png]]
---

|**Понятие**|**Главное**|**Сложность**|
|---|---|---|
|**Компаратор**|Функция `int(const void*, const void*)`|—|
|**qsort**|Стандартная быстрая сортировка в Си|$O(n \log n)$|
|**Бинарный поиск**|Поиск делением пополам (в отсорт. массиве)|$O(\log n)$|