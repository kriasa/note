
Структуры и объединения в языке C, их размер, определение и особенности использования. Оператор “.”. Указатели на структуры в языке C, оператор “->”.


### Концептуальная основа

**Структура** — это пользовательский составной тип данных, объединяющий несколько переменных (называемых **полями** или **членами**) под одним именем. Это механизм **логической группировки** данных, позволяющий моделировать сложные сущности предметной области.

В отличие от массивов (гомогенные коллекции одного типа), структуры — **гетерогенные**: каждое поле может иметь свой тип.

Особенности: 
- Все поля структуры размещаются в памяти последовательно (в порядке объявления), с учетом выравнивания. 
- Размер структуры определяется как сумма размеров её полей + выравнивание.

### Объявление структуры
```c
// Способ 1: Определение типа структуры
struct Point {
    int x;
    int y;
};

// Способ 2: С typedef для удобства
typedef struct {
    int x;
    int y;
} Point;

// Способ 3: Совмещенный (традиционный)
typedef struct Point {
    int x;
    int y;
} Point;

// Способ 4: Анонимная структура (C11)
struct {
    int x;
    int y;
} point1, point2; // Объявление переменных
```

### Создание переменных структур
```c
// Без typedef:
struct Point p1;

// С typedef:
Point p2;

// Инициализация при объявлении (C89):
struct Point p3 = {10, 20};

// Designated initializers (C99):
struct Point p4 = {.y = 20, .x = 10}; // Порядок не важен!

// Частичная инициализация:
struct Point p5 = {10}; // x=10, y=0 (остальные обнуляются)

// Полное обнуление:
struct Point p6 = {0}; // Все поля = 0
```

**Важно**: неинициализированные локальные структуры содержат **мусор**, глобальные автоматически **обнуляются**.

---

## Оператор доступа к полям "."
### Синтаксис и семантика
```c
struct Point p = {5, 10};
int x_value = p.x;  // Чтение поля
p.y = 15;           // Запись поля
```

**Оператор "."** — это оператор прямого доступа к члену структуры. Компилятор **статически** вычисляет смещение поля относительно начала структуры.

### Как это работает на низком уровне
```c
struct Point {
    int x;  // Смещение 0
    int y;  // Смещение 4 (на 32/64-бит системах)
};

Point p;
p.x = 10; // Эквивалентно: *(int*)((char*)&p + 0) = 10;
p.y = 20; // Эквивалентно: *(int*)((char*)&p + 4) = 20;
```

Компилятор заменяет `p.x` на **адрес_p + смещение_x**, никаких runtime вычислений!

### Вложенные структуры

```c
struct Rectangle {
    struct Point top_left;
    struct Point bottom_right;
};

struct Rectangle rect = {{0, 0}, {10, 20}};
int x = rect.top_left.x;  // Цепочка операторов "."
```

---
## Размер структуры и выравнивание (alignment)
### Проблема выравнивания памяти

Процессоры эффективнее читают данные, выровненные по адресам, кратным размеру типа данных. **Невыровненный доступ** может быть:
- Медленнее (требует нескольких обращений к памяти)
- Запрещен аппаратно (на некоторых архитектурах вызывает bus error)

### Правила выравнивания
1. **Каждое поле выравнивается** по адресу, кратному своему размеру (или требованию архитектуры)
2. **Размер структуры кратен** наибольшему выравниванию её полей (для массивов структур)

### Примеры padding (заполнения)

**Пример 1: Плохое расположение полей**
```c
struct Bad {
    char c;     // 1 байт, смещение 0
    // [3 байта padding]
    int i;      // 4 байта, смещение 4
    char d;     // 1 байт, смещение 8
    // [3 байта padding для выравнивания структуры]
};
sizeof(struct Bad) // 12 байт (1+3+4+1+3)
```

**Пример 2: Оптимальное расположение**
```c
struct Good {
    int i;      // 4 байта, смещение 0
    char c;     // 1 байт, смещение 4
    char d;     // 1 байт, смещение 5
    // [2 байта padding]
};
sizeof(struct Good) // 8 байт (4+1+1+2)
```
**Правило оптимизации**: располагайте поля **от большего к меньшему** по размеру.

---
## Операции со структурами
### Присваивание структур
```c
struct Point p1 = {10, 20};
struct Point p2 = p1; // Побитовое копирование всей структуры
```
**Важно**: это **shallow copy** (поверхностное копирование). Если структура содержит указатели, копируются **адреса**, а не данные!
```c
struct String {
    char *data;
    size_t length;
};

struct String s1 = {strdup("hello"), 5};
struct String s2 = s1; // s1.data и s2.data указывают на одну память!
free(s1.data);
// s2.data теперь висячий указатель!
```
### Сравнение структур
```c
if (p1 == p2) // ОШИБКА! Оператор == не работает для структур
```

Нужно сравнивать **поэлементно** или использовать `memcmp`:

```c
if (memcmp(&p1, &p2, sizeof(struct Point)) == 0) // Работает, но опасно!
```

**Проблема memcmp**: сравнивает и padding байты, которые могут содержать мусор! Безопаснее:
```c
if (p1.x == p2.x && p1.y == p2.y)
```
### Передача структур в функции

**По значению** (копирование):
```c
void print_point(struct Point p) { // Копируется вся структура!
    printf("(%d, %d)\n", p.x, p.y);
}
```

**По указателю** (эффективнее):
```c
void print_point(const struct Point *p) { // Передается только адрес
    printf("(%d, %d)\n", p->x, p->y);
}
```


---
## Указатели на структуры и оператор "->"
### Оператор доступа через указатель
```c
struct Point p = {10, 20};
struct Point *ptr = &p;

// Способ 1: Разыменование и точка
(*ptr).x = 30;

// Способ 2: Оператор стрелка (синтаксический сахар)
ptr->x = 30; // Эквивалентно (*ptr).x
```

**Оператор "->"** — это сокращение для `(*ptr).member`. Приоритет операторов:

- `ptr->x` эквивалентно `(*ptr).x`
- `*ptr.x` — **ошибка компиляции** (точка имеет выше приоритет)

### Почему -> критически важен

При работе с динамическими структурами данных (списки, деревья) почти всегда используются указатели:
```c
struct Node {
    int data;
    struct Node *next;
};

struct Node *head = malloc(sizeof(struct Node));
head->data = 42;
head->next = NULL;
```

Без оператора `->` код был бы неудобочитаем:
```c
(*head).data = 42;
(*(*head).next).data = 100; // Кошмар!
head->next->data = 100;      // Читаемо!
```

---
## Объединения (union)
### Концептуальная основа

**Объединение** — это тип данных, где все поля **разделяют одну область памяти**. В каждый момент времени **валидно только одно поле** (последнее записанное).
### Объявление и использование
```c
union Data {
    int i;
    float f;
    char c;
};

union Data d;
d.i = 42;           // Записываем int
printf("%d\n", d.i); // 42

d.f = 3.14f;        // Перезаписываем как float
printf("%d\n", d.i); // Мусор! Интерпретируем биты float как int
printf("%f\n", d.f); // 3.14
```

### Размер объединения
```c
sizeof(union Data) // Размер самого БОЛЬШОГО поля + выравнивание
```

Пример:
```c
union Example {
    char c;        // 1 байт
    int i;         // 4 байта
    double d;      // 8 байт
};
sizeof(union Example) // 8 байт (размер double)
```

### Применение объединений
**1. Экономия памяти** (когда поля взаимоисключающие):
```c
struct Packet {
    enum { TYPE_INT, TYPE_FLOAT, TYPE_STRING } type;
    union {
        int i;
        float f;
        char *str;
    } data;
};
```

**2. Интерпретация байтов (type punning)**:
```c
union FloatBytes {
    float f;
    unsigned char bytes[4];
};

union FloatBytes fb;
fb.f = 3.14f;
// Можем анализировать байтовое представление float
printf("Байты: %02x %02x %02x %02x\n", 
       fb.bytes[0], fb.bytes[1], fb.bytes[2], fb.bytes[3]);
```
**Внимание**: чтение поля, которое не было последним записанным — **неопределенное поведение** в стандарте C (хотя многие компиляторы это поддерживают).

**3. Определение endianness (порядка байтов)**:
```c
union {
    uint32_t value;
    uint8_t bytes[4];
} test = {.value = 0x12345678};

if (test.bytes[0] == 0x78) {
    printf("Little-endian\n"); // Младший байт по младшему адресу
} else {
    printf("Big-endian\n");
}
```

---
