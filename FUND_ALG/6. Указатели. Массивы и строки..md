Тип указателя. Арифметика указателей. Массивы и строки. Операции над строками и их непосредственная реализация.

**Указатель** — это переменная, **хранящая адрес другой переменной в памяти**.

> Указатель не хранит значение, он хранит **место, где это значение лежит**.

Тип указателя определяет:

1. **какого типа данные лежат по этому адресу**
2. **на сколько байт сдвигается указатель при арифметике**

```c
// УКАЗАТЕЛИ
int *ptr = NULL;           // Инициализация нулём (адрес 0x0)
int *ptr = &var;           // Взятие адреса
int val = *ptr;            // Разыменование
ptr++;                     // Сдвиг на sizeof(int)
printf("Значение a: %d\n", a); 
printf("Адрес a: %p\n", (void *)ptr); 
printf("Значение через указатель: %d\n", *ptr); 
return 0;
```

#### Арифметика указателей

Арифметика указателей подчиняется строгим правилам, которые гарантируют, что указатель всегда будет указывать на следующий элемент того же типа.

При выполнении операций с указателем адрес памяти изменяется не на единицу, а на **размер типа данных**, на который он указывает. Это называется **масштабным коэффициентом (Scale Factor)**.

1. Прибавление целого числа:
    $$p + N \Rightarrow \text{Адрес} (p) + N \cdot \text{sizeof}(\text{тип, на который указывает } p)$$
    
    - Пример: Если int *p; хранит адрес 0x1000, и sizeof(int) равно 4 байтам, то:
        
        p + 1 указывает на адрес 0x1004 (следующий int).
        p + 3 указывает на адрес 0x100C.
        
2. Вычитание целого числа:
    
    Действует аналогично прибавлению, но в обратном направлении.
    
3. Вычитание двух указателей:
    
    Результатом является целое число, представляющее количество элементов между двумя адресами, а не количество байтов.
    
    - Указатели должны быть одного и того же типа.
        $$\text{p2} - \text{p1} \Rightarrow \frac{\text{Адрес}(\text{p2}) - \text{Адрес}(\text{p1})}{\text{sizeof}(\text{тип})}$$
        

```c
// АРИФМЕТИКА
ptr + n    // ptr + n * sizeof(тип)
ptr - p2   // (ptr - p2) / sizeof(тип)  — количество элементов
```
### Б. Недопустимые Операции

Категорически запрещены и не имеют смысла следующие операции:

- Умножение указателей.
- Деление указателей.
- Сложение двух указателей (результатом был бы адрес, лежащий за пределами разумного диапазона данных).

#### Массивы

**Массив** — это непрерывный участок памяти, содержащий элементы одного типа.

**Имя массива** (без квадратных скобок) в большинстве контекстов интерпретируется как **константный указатель** на его первый элемент.
```c
int arr[3] = {1, 2, 3}; int *ptr = arr; // Указывает на arr[0]
```
**Доступ к элементам:** Доступ к элементам массива через индекс `A[i]` является лишь синтаксическим "сахаром" для доступа через арифметику указателей:
```c
// МАССИВЫ
arr[i]  ≡  *(arr + i)      // Эквивалентность
sizeof(arr) — даёт полный размер массива **только в той области, где массив объявлен**, вне функции он становится указателем.
```

- В функции `arr` **уже не массив**, а **указатель на первый элемент**.
- Поэтому `sizeof(arr)` вернёт **размер указателя**, а не всего массива.

Когда массив передается в функцию в качестве аргумента, он **"затухает" (decays)** до указателя на свой первый элемент.

```c
void func(int arr[], int n) { ... } // Внутри функции это int*
// Эквивалентно:
void func(int *arr,  int n) { ... }
```

Следовательно, функция не знает фактический размер исходного массива и должна получать его размер отдельным аргументом.

#### Строки

**Строка** — это массив символов `char`, **заканчивающийся нулевым символом `'\0'`**.
```c
char str[] = "Hello"; 
char *ptr = str; // Указывает на 'H'
```

## Основные операции над строками

(определены в `<string.h>`)

| Функция  | Назначение                                |
| -------- | ----------------------------------------- |
| `strlen` | длина строки                              |
| `strcpy` | копирование                               |
| `strstr  |  ищет **подстроку** внутри другой строки. |
| `strcat` | конкатенация                              |
| `strcmp` | сравнение                                 |
## Реализация строковых функций вручную

### 11.1 `strlen` (Определение длины)

```c
size_t my_strlen(const char *str) { 
    size_t len = 0; 
    while (*str++) { 
       len++; 
    } 
    return len; 
}
```

---

### 11.2 `strcpy` (Копирование)

```c
char *my_strcpy(char *dest, const char *src) { 
    char *ptr = dest; 
    while (*src) { 
        *ptr++ = *src++; 
    } 
    *ptr = '\0'; 
    return dest; 
}
```

---

### 11.3 `strcmp`

```c
int my_strcmp(const char *a, const char *b) {
    while (*a && (*a == *b)) {
        a++;
        b++;
    }
    return *(unsigned char *)str1 - *(unsigned char *)str2;
}
```

### strcat (Конкатенация/Объединение)

```c
char *my_strcat(char *dest, const char *src) { 
    char new_d[strlen(dest) + strlen(src)]; 
    while () while (*src) { 
        *ptr++ = *src++; 
    } *ptr = '\0'; 
    return dest; 
}
```
### strstr  ищет **подстроку** внутри другой строки

```c
char *my_strstr(const char *haystack, const char *needle) { 
    if (!*needle) { // Если искомая строка пустая, возвращаем начало haystack
        return (char *)haystack; 
    } 
    while (*haystack) { 
        const char *h = haystack; 
        const char *n = needle; // Сравниваем символы текущей позиции haystack и needle
        while (*h && *n && *h == *n) { 
           h++; 
           n++; 
        } 
        if (!*n) { // Если needle полностью совпал, возвращаем указатель 
           return (char *)haystack; 
        } 
        haystack++; // Переходим к следующей позиции 
    } 
    return NULL; 
}
```

```c
// СТРОКИ
'\0' — байт 0, конец строки
"literal" — read-only память
char arr[] = "str" — копия в стек, изменяемая
char *ptr = "str"  — указатель на read-only, НЕизменяемая
```
#### 2. `"literal"` — read-only память

- Строковый литерал `"literal"` хранится в **памяти только для чтения**, обычно в сегменте `.rodata` программы.
- Попытка изменить такой литерал через указатель **приведёт к UB (Undefined Behavior)**.
    
`char *s = "hello"; s[0] = 'H'; // ❌ UB, нельзя менять`

- Можно только читать: `printf("%s", s);` ✅
    

---

#### 3. `char arr[] = "str"` — копия в стек, изменяемая

- Когда объявляем массив символов **через `[]`**, компилятор создаёт **копию литерала в памяти переменной**, обычно на **стеке**.
- Эта копия **может быть изменена**.

`char arr[] = "hello"; arr[0] = 'H'; // ✅ можно printf("%s", arr); // Hello`

- Размер массива = **длина строки + 1 для '\0'**.
- Это **реальный массив**, а не просто указатель.
    
---
#### 4. `char *ptr = "str"` — указатель на read-only, НЕизменяемая

- Здесь `ptr` — **указатель на литерал** `"str"`.
- Литерал хранится в **памяти только для чтения**.
- Нельзя менять содержимое через `ptr`.

`char *ptr = "hello"; ptr[0] = 'H'; // ❌ UB`

- Можно менять сам указатель:

`ptr = "world"; // ✅ теперь ptr указывает на другой литерал`

```c
// БЕЗОПАСНОСТЬ
Всегда: ptr = NULL после free
Проверка: if (ptr != NULL) перед *ptr
Размер: передавайте отдельным параметром
```
