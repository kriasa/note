Алгоритмическая сложность. «О большое». Худший\лучший\средний случай.

Алгоритмическая сложность — это способ классификации алгоритмов по тому, как время их выполнения или объем требуемой памяти (**пространственная сложность**) растет с увеличением размера входных данных (**$n$**).

Основная цель анализа сложности — **предсказать производительность** алгоритма при работе с очень большими объемами данных, независимо от конкретной машины, на которой он будет запущен.

Обычно рассматривают два вида ресурсов:

1. **Временная сложность** — сколько элементарных операций выполняет алгоритм.
2. **Пространственная сложность** — сколько дополнительной памяти требуется.

В фундаментальных алгоритмах чаще всего анализируют **временную сложность**.

### Асимптотический анализ

При анализе алгоритмов нас интересует **поведение при больших `n`**, поэтому:

- игнорируют константы;
- игнорируют слагаемые меньшего порядка;
- оценивают скорость роста функции.

Пример:

`T(n) = 3n² + 5n + 10  →  O(n²)`
### 1. Нотация «О большое» (Big O Notation)

**Определение:**

Нотация «О большое» ($O$) описывает **верхнюю границу** или **худший случай** (worst-case scenario) времени выполнения алгоритма. Это функция, которая показывает, как быстро растет время работы алгоритма при стремлении размера входных данных ($n$) к бесконечности.

$O(g(n))$ означает, что существует такая константа $c > 0$ и число $n_0 > 0$, что для всех $n \ge n_0$, время выполнения $T(n)$ удовлетворяет неравенству:

$$T(n) \le c \cdot g(n)$$

где:

- $T(n)$ — фактическое время выполнения (или количество операций).
- 
- $g(n)$ — функция, описывающая класс сложности (например, $n, n^2, \log n$).
- 
- $c$ — константа, которая позволяет нам игнорировать низкоуровневые детали реализации и специфику машины.
 Константа $c$ позволяет нам **игнорировать скорость процессора**. Мы говорим: "Мой алгоритм будет работать **не хуже**, чем $g(n)$, умноженное на **некоторую (неважную) константу $c$**." Это делает наш анализ **универсальным** и независимым от оборудования.
 
- $n_0$ — пороговое значение, после которого это соотношение гарантированно выполняется.
Мы говорим: "Нас не интересует, что происходит с очень маленькими $n$. Нас интересует только, как алгоритм ведет себя, когда $n$ становится **достаточно большим**." Число $n_0$ — это **пороговое значение**, после которого наша простая функция $c \cdot g(n)$ гарантированно "перекрывает" фактическое время $T(n)$.

    
### Примеры распространённых сложностей

| Сложность  | Название                |
| ---------- | ----------------------- |
| O(1)       | константная             |
| O(log n)   | логарифмическая         |
| O(n)       | линейная                |
| O(n log n) | линейно-логарифмическая |
| O(n²)      | квадратичная            |
| O(n³)      | кубическая              |
| O(2ⁿ)      | экспоненциальная        |

### 2. Анализ Случаев (Cases Analysis)

#### A. Худший Случай (Worst-Case Scenario)

- **Обозначение:** Используется нотация **«О большое» ($O$)**.
    
- **Описание:** Это **максимальное время**, которое может потребоваться алгоритму для завершения работы, независимо от конкретного набора входных данных. Входные данные специально подобраны для того, чтобы заставить алгоритм выполнить **наибольшее количество шагов**.
    
- **Важность:** Это наиболее **важный и надежный** показатель производительности, поскольку он дает гарантию: _"Вне зависимости от того, что мне подадут на вход, алгоритм никогда не будет работать дольше этого времени."_
    
**Пример:** линейный поиск

```
int linear_search(int a[], int n, int x) {
    for (int i = 0; i < n; i++) {
        if (a[i] == x)
            return i;
    }
    return -1;
}
```

- элемент отсутствует или стоит в конце массива;
- выполняется `n` проверок;

➡ **Худший случай: O(n)**
    

#### B. Лучший Случай (Best-Case Scenario)

- **Обозначение:** Используется нотация **«Омега большое» ($\Omega$)**.
    
- **Описание:** Это **минимальное время**, которое потребуется алгоритму. Входные данные идеально подходят для алгоритма, что позволяет ему выполнить **наименьшее количество шагов**.
    
- **Важность:** Этот показатель имеет **наименьшую практическую ценность**, поскольку он редко отражает реальное поведение алгоритма. Однако он помогает понять минимальную границу, ниже которой алгоритм работать не может.
    
**Пример:** тот же линейный поиск

- элемент стоит на первой позиции;
- одна проверка;

➡ **Лучший случай: O(1)**
    

#### C. Средний Случай (Average-Case Scenario)

- **Обозначение:** Используется нотация **«Тета большое» ($\Theta$)** или также **«О большое» ($O$)** для верхних границ.
    
- **Описание:** Это время, которое потребуется алгоритму при обработке **типичного или случайного** набора входных данных. Для вычисления этого показателя необходимо знать **вероятностное распределение** всех возможных входных данных.
    
- **Важность:** Этот показатель часто **наиболее точно** отражает реальную производительность алгоритма на практике.
    
**Пример:** линейный поиск

- в среднем элемент находится в середине массива;
- примерно `n / 2` проверок;
    
➡ **Средний случай: O(n)**
