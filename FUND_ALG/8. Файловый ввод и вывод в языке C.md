Файловый ввод/вывод в языке C. Методы чтения и записи файлов. Циклы чтения файлов с обработкой символа конца файла и без неё. Типизированные и не типизированные файлы. Структура FILE. Форматируемый ввод/вывод. Методы выделения лексем из входного строкового потока. Принцип границы и функция strtok.

# Что такое файл на самом деле?

**Файл** — это абстракция над последовательностью байтов, хранящихся на устройстве (диск, SSD, сеть).

На уровне операционной системы:
- **Файловый дескриптор** (UNIX) или **хэндл** (Windows) — целое число, идентифицирующее открытый файл
- ОС поддерживает таблицу открытых файлов для каждого процесса
- Каждая запись содержит: позицию чтения/записи, режим доступа, буферы

В C эта сложность скрыта за структурой `FILE`.

## Тип FILE

```c
FILE *f;
```

- `FILE` — структура, которая **описывает открытый файл**, включая:
    
    - указатель на позицию в файле (текущий байт)
    - буфер
    - режим открытия
- `FILE *` — указатель на эту структуру
## Открытие и закрытие файла

```c
FILE *f = fopen("file.txt", "r"); // открыть для чтения 
if (!f) { /* ошибка открытия */ }  
fclose(f); // закрыть файл
```

- Режимы:
    
    - `"r"` — чтение
    - `"w"` — запись (создаёт или очищает файл)
    - `"a"` — дозапись (append)


### Структура `FILE`

Структура **`FILE`** является ключевой. Это непрозрачный (opaque) тип данных, определенный в `stdio.h`, который содержит всю служебную информацию о потоке:

1. **Указатель на буфер:** Область памяти для временного хранения данных.
2. **Текущая позиция в файле:** Указатель, показывающий, где будет происходить следующее чтение/запись.
3. **Текущее состояние потока:** Флаги ошибок, флаг конца файла (EOF).
4. **Режим доступа:** (например, чтение, запись, бинарный).
    
Для работы с файлом программист использует **указатель на `FILE`** (`FILE *`).Пользователь fopen , работает с файлами через указатели на эту структуру, используя функции вроде fread , fwrite , fclose и другие.


### Методы Чтения и Записи Файлов

Функции для работы с текстовыми файлами: 
Чтение: 
- fgetc — чтение одного символа. 
- **Поведение fgets:**
- Читает **до size-1** символов
- Останавливается при '\n' (и **включает** его в строку)
- Добавляет '\0' в конец
- Возвращает NULL при EOF или ошибке
- 
- fgets — чтение строки (до `\n` или конца файла)
- fscanf — чтение форматированного ввода (Возвращает число успешно считанных элементов)
Запись: 
- fputc — записать **один символ** в файл
- fputs — записать **строку** в файл
- fprintf — запись форматированного вывода (Возвращает количество записанных символов)

### Обработка конца файла

### Цикл Чтения с Обработкой EOF (Предпочтительный)

Этот цикл **корректно** обрабатывает EOF, сравнивая результат присваивания с константой EOF.

```c
while ((c = fgetc(file)) != EOF) { 
   putchar(c); 
}
```

### Цикл Чтения Без Обработки EOF (Некорректный)

```c
char c; // ОШИБКА: char не может хранить EOF
FILE *fp = fopen("input.txt", "r");

while (!feof(fp)) { // ОШИБКА: feof проверяет только состояние, но не читает
    c = fgetc(fp); // Читаем, но не проверяем результат
    // ... обработка c ...
}
```


**Проблема:** `feof` сообщает об успехе/неудаче _предыдущей_ операции. Поэтому, когда файл закончится, `fgetc` вернет `EOF`, но цикл успеет один раз «обработать» это пустое значение, часто дублируя последний символ.

**Почему `int`?** `char` может хранить только 256 значений. Нам нужно 257-е значение (EOF), которое обычно равно `-1`. В `int` оно не перепутается с обычным символом.

**EOF (End Of File)** макрос— это не символ, а **константа** (отрицательное целое число, обычно $-1$), которую функции ввода (`fgetc`, `scanf`, `getchar`) возвращают, когда:

1. Достигнут конец файла.
2. Произошла ошибка ввода/вывода.
    

Функции символьного ввода возвращают `int` (а не `char`), чтобы иметь возможность вернуть все $256$ символьных значений и специальное значение `EOF`.


# Бинарные и текстовые файлы
### Нетипизированные (бинарные) файлы

**Нетипизированный файл** — просто последовательность байтов без структуры.

**Характеристики:**
- Компактны (нет текстового представления)
- Зависят от архитектуры (endianness, размер типов)
- Быстрое чтение/запись
- Нечитаемы человеком
- Проблема переносимости
![[Pasted image 20251215015105.png]]
### Типизированные (текстовые) файлы

**Типизированный файл** — содержит данные в текстовом формате с явной структурой. Данные хранятся как последовательность символов (ASCII/Unicode).

**Характеристики:**
- Содержат данные в текстовом (читаемом для человека) формате. 
- Преобразуют данные (например, числа или символы) в строки при записи, а при чтении — обратно из строк. 
- Строки разделяются символами новой строки
- Медленнее (преобразование число↔строка)

![[Pasted image 20251215015025.png]]

---

![[Pasted image 20251215014934.png]]
### Форматированный Ввод/Вывод (Formatted I/O)

Используются для чтения/записи данных, представленных в текстовом виде (как числа, строки, символы).

|**Функция**|**Назначение**|**Особенности**|
|---|---|---|
|`fprintf(fp, format, ...)`|Форматированная запись|Записывает данные в файл `fp` согласно строке формата (аналогично `printf`).|
|`fscanf(fp, format, ...)`|Форматированное чтение|Читает данные из файла `fp`, пытаясь сопоставить их со строкой формата (аналогично `scanf`).|

**Проблема `fscanf`:** Очень чувствителен к формату. Часто используются более надежные методы: чтение всей строки (`fgets`), а затем ее парсинг (`sscanf`).
## Выделение лексем из строки

**Лексема (Token)** — это осмысленная минимальная единица данных (слово, число, оператор), выделенная из входного потока (строки).

### А. Принцип Границы и Функция `strtok`

Для выделения лексем из строки (парсинг) используется принцип **границы (Delimiter)**.

**Функция `char *strtok(char *str, const char *delim)`:**

1. **Назначение:** Разделяет строку `str` на последовательность лексем, используя символы-разделители, указанные в строке `delim`.
    
2. **Принцип работы (Принцип Границы):**
    
    - `strtok` **разрушает (разбивает)** исходную строку, заменяя найденные символы-разделители **нулевыми символами (`\0`)**.
        
    - **Первый вызов:** Принимает исходную строку `str`. Находит первую лексему, заменяет разделитель на `\0` и возвращает указатель на начало лексемы.
        
    - **Последующие вызовы:** Принимает **`NULL`** в качестве первого аргумента. Это указывает `strtok` продолжить работу с места, где она остановилась в **предыдущем** вызове (сохраняя внутреннее статическое состояние).

**Принцип границы:** лексема ограничена:
1. Началом строки
2. Концом строки
3. Разделителями (пробел, запятая, и т.д.)
![[Pasted image 20251215014858.png]]
#### Алгоритмическая сложность

1.Чтение/запись файла: Простая запись: O(n), где n — размер файла. Форматированный ввод/вывод: зависит от сложности обработки форматов. 
2.Работа с strtok : O(k), где k — длина строки, так как каждый символ проверяется один раз

```c
#include <stdio.h>
#include <string.h>

char text[] = "слово1,слово2;слово3.слово4";
const char delimiters[] = ",;.";

char *token;

// Первый вызов: передаем строку для инициализации
token = strtok(text, delimiters); 

while (token != NULL) {
    printf("Лексема: %s\n", token);
    
    // Последующие вызовы: передаем NULL
    token = strtok(NULL, delimiters); 
}
```

```python
Строка: "apple,banana:cherry grape"
Разделители: ",: "
Лексемы: "apple", "banana", "cherry", "grape"
```

```c
// Концептуальная реализация strtok
static char *last_position = NULL;  // Статическая переменная!

char* my_strtok(char *str, const char *delim) {
    if (str != NULL) {
        last_position = str;
    }
    
    if (last_position == NULL) {
        return NULL;
    }
    
    // Пропустить начальные разделители
    last_position += strspn(last_position, delim);
    
    if (*last_position == '\0') {
        last_position = NULL;
        return NULL;
    }
    
    char *token_start = last_position;
    
    // Найти конец лексемы
    last_position += strcspn(last_position, delim);
    
    if (*last_position != '\0') {
        *last_position = '\0';  // МОДИФИКАЦИЯ СТРОКИ!
        last_position++;
    } else {
        last_position = NULL;
    }
    
    return token_start;
}

char str[] = "apple,:banana:cherry grape";  // КОПИЯ! Не литерал!

char *token = strtok(str, ",: ");
while (token != NULL) {
    printf("Token: %s\n", token);
    token = strtok(NULL, ",: ");
}

// Вывод:
// Token: apple
// Token: banana
// Token: cherry
// Token: grape
```

**Что происходит со строкой:**
```c
До strtok:
str: "apple,banana:cherry grape"

После 1-го вызова:
str: "apple\0banana:cherry grape"
      ^---- token указывает сюда
      
После 2-го вызова:
str: "apple\0banana\0cherry grape"
             ^---- token указывает сюда

После 3-го вызова:
str: "apple\0banana\0cherry\0grape"
                     ^---- token

После 4-го вызова:
str: "apple\0banana\0cherry\0grape\0"
                            ^---- token

После 5-го вызова:
token == NULL (лексемы кончились)
```