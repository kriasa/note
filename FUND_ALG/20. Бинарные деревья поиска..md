Бинарные деревья поиска. Создание и удаление бинарного дерева. Операция поиска элемента в дереве, её связь с дихотомическим (бинарным) поиском. Операции префиксного, инфиксного и постфиксного обхода бинарного дерева, вставки/удаления элемента. Вычислительные сложности и реализация вышеописанных операций на языке C.

### 1. Что такое Бинарное дерево поиска (BST)?

Это иерархическая структура данных, состоящая из узлов. Для каждого узла выполняется **правило BST**:

- Значение в **левом** поддереве меньше значения узла.
- Значение в **правом** поддереве больше значения узла.
    

**Структура узла на языке C:**

```c
typedef struct Node {
    int data;
    struct Node *left;
    struct Node *right;
} Node;
```

---

### 2. Операция поиска и связь с дихотомическим поиском

Поиск в BST идеологически идентичен **бинарному (дихотомическому) поиску** в отсортированном массиве:

1. Мы сравниваем искомое значение с текущим узлом.
2. Если они равны — поиск завершен.
3. Если искомое меньше — мы «отсекаем» всю правую часть и идем влево.
4. Если больше — «отсекаем» левую часть и идем вправо.
    

**Сложность:**

- В среднем: **$O(\log n)$**.
- В худшем случае (если дерево выродилось в список): **$O(n)$**.
    

**Реализация:**

```c
Node* search(Node* root, int key) {
    if (root == NULL || root->data == key) return root;
    if (key < root->data) return search(root->left, key);
    return search(root->right, key);
}
```

---

### 3. Обходы дерева (Traversal)

Обходы позволяют посетить все узлы дерева в определенном порядке.

1. **Инфиксный (In-order):** Лево → Узел → Право.
    
    - _Важно:_ Для BST этот обход выдает элементы в **строго возрастающем порядке**.
        
2. **Префиксный (Pre-order):** Узел → Лево → Право. Используется для копирования дерева.
    
3. **Постфиксный (Post-order):** Лево → Право → Узел. Используется для удаления дерева (сначала удаляем детей, потом сам узел).
    

```c
// ============ АЛГОРИТМЫ ОБХОДА ============

// Прямой обход (pre-order): корень -> левый -> правый

void preorder(Tree_Node* node) {
    if (node == NULL) return;
    printf("%d ", node->data);
    preorder(node->left);
    preorder(node->right);

}
// Симметричный обход (in-order): левый -> корень -> правый
void inorder(Tree_Node* node) {
    if (node == NULL) return;
    inorder(node->left);
    printf("%d ", node->data);
    inorder(node->right);
}
// Обратный обход (post-order): левый -> правый -> корень
void postorder(Tree_Node* node) {
    if (node == NULL) return;
    postorder(node->left);
    postorder(node->right);
    printf("%d ", node->data);
}
```
обратный
![[Pasted image 20251219005309 1.png]]
прямой
![[Pasted image 20251219005324.png]]
концевой
![[Pasted image 20251219005335 1.png]]

---

### 4. Вставка и удаление

#### Вставка (Insert)

Новый элемент всегда вставляется как «лист» (узел без детей). Мы просто идем по дереву до тех пор, пока не найдем подходящее пустое место (NULL).

Сложность: $O(\log n)$ (в среднем).

#### Удаление (Delete) — самая сложная операция

Рассматриваются три случая:

1. **Узел — лист:** Просто удаляем его.
2. **Один ребенок:** Заменяем удаляемый узел его ребенком.
3. **Два ребенка:** Ищем самый маленький элемент в **правом** поддереве (successor), копируем его значение в удаляемый узел, а затем удаляем этот самый маленький элемент.
    

---

### 5. Создание и полное удаление дерева

Создание — это инициализация корня как `NULL`. Полное удаление требует постфиксного обхода, чтобы не потерять указатели на детей.

```c
void deleteTree(Node* root) {
    if (root == NULL) return;
    deleteTree(root->left);
    deleteTree(root->right);
    free(root);
}
```

---

### 6. Реализация основных операций (Полный код)

```c
#include <stdio.h>
#include <stdlib.h>
typedef struct Node {
    int data;
    struct Node *left;
    struct Node *right;
} Node;

Node* createNode(int value) {
    Node* newNode = malloc(sizeof(Node));
    newNode->data = value;
    newNode->left = newNode->right = NULL;
    return newNode;
}

// Вставка
Node* insert(Node* root, int value) {
    if (root == NULL) return createNode(value);
    if (value < root->data)
        root->left = insert(root->left, value);
    else
        root->right = insert(root->right, value);
    return root;
}

// Поиск минимума (нужен для удаления)
Node* minValueNode(Node* node) {
    Node* current = node;
    while (current && current->left != NULL)
        current = current->left;
    return current;
}

// Удаление узла
Node* deleteNode(Node* root, int key) {
    if (root == NULL) return root;

    if (key < root->data)
        root->left = deleteNode(root->left, key);
    else if (key > root->data)
        root->right = deleteNode(root->right, key);
    else {
        // Узел с одним ребенком или без детей
        if (root->left == NULL) {
            Node* temp = root->right;
            free(root);
            return temp;
        } else if (root->right == NULL) {
            Node* temp = root->left;
            free(root);
            return temp;
        }
        // Узел с двумя детьми
        Node* temp = minValueNode(root->right);
        root->data = temp->data;
        root->right = deleteNode(root->right, temp->data);
    }
    return root;
}
```

---

### Итоговая таблица сложностей

|**Операция**|**Средняя (сбалансированное)**|**Худшая (вырожденное в список)**|
|---|---|---|
|**Поиск**|$O(\log n)$|$O(n)$|
|**Вставка**|$O(\log n)$|$O(n)$|
|**Удаление**|$O(\log n)$|$O(n)$|
|**Обход**|$O(n)$|$O(n)$|

