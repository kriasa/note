Приоритетные очереди. Бинарная приоритетная очередь, её реализация на базе структуры данных вида динамический массив. Операции вставки элемента, поиска минимума/максимума, удаления минимума/максимума, слияния с разрушением и без разрушения исходных бинарных приоритетных очередей; их вычислительные сложности и реализация на языке C.

Этот билет посвящен **Приоритетным очередям** и их самой эффективной классической реализации — **Бинарной куче (Binary Heap)**.

---

### 1. Что такое Приоритетная очередь?

Это абстрактная структура данных, где у каждого элемента есть «приоритет». В отличие от обычной очереди (FIFO), здесь первым выходит элемент с **наивысшим приоритетом** (либо самый маленький — Min-Heap, либо самый большой — Max-Heap).

### 2. Бинарная куча на базе динамического массива

Бинарная куча — это «почти полное» бинарное дерево. Его удобнее всего хранить в обычном **массиве**, не тратя память на указатели `left` и `right`.

**Схема индексации (для элемента с индексом `i`):**

- **Корень:** индекс `0`.
    
- **Левый сын:** `2 * i + 1`.
    
- **Правый сын:** `2 * i + 2`.
    
- **Родитель:** `(i - 1) / 2`.
    

[Image: Схема представления дерева в виде массива: узлы дерева нумеруются по слоям сверху вниз, слева направо]

---

### 3. Реализация на языке C

Для динамического массива создадим структуру:

C

```
#include <stdio.h>
#include <stdlib.h>

typedef struct {
    int *data;     // Динамический массив
    int size;     // Текущее кол-во элементов
    int capacity; // Максимальный объем
} PriorityQueue;

PriorityQueue* create(int cap) {
    PriorityQueue* pq = malloc(sizeof(PriorityQueue));
    pq->data = malloc(cap * sizeof(int));
    pq->size = 0;
    pq->capacity = cap;
    return pq;
}
```

---

### 4. Основные операции и их механика

#### А) Поиск минимума/максимума

В куче самый приоритетный элемент всегда находится в корне (индекс `0`).

- **Сложность:** $O(1)$.
    
- **Код:** `return pq->data[0];`
    

#### Б) Вставка элемента (Sift Up / Просеивание вверх)

1. Новый элемент добавляется в самый конец массива.
    
2. Затем он «всплывает»: сравнивается с родителем и меняется с ним местами, пока не станет меньше родителя (для Min-Heap).
    

**Сложность:** $O(\log n)$.

C

```
void insert(PriorityQueue* pq, int value) {
    pq->data[pq->size] = value;
    int i = pq->size++;
    // Просеивание вверх
    while (i > 0 && pq->data[i] < pq->data[(i - 1) / 2]) {
        int temp = pq->data[i];
        pq->data[i] = pq->data[(i - 1) / 2];
        pq->data[(i - 1) / 2] = temp;
        i = (i - 1) / 2;
    }
}
```

#### В) Удаление минимума/максимума (Sift Down / Просеивание вниз)

1. Корень заменяется **последним** элементом массива.
    
2. Размер уменьшается на 1.
    
3. Новый корень «тонет»: сравнивается с детьми и меняется местами с меньшим из них.
    

**Сложность:** $O(\log n)$.

---

### 5. Слияние очередей (Merge)

Это «узкое место» бинарных куч на массиве.

#### Слияние с разрушением (Destructive Merge)

Мы берем элементы из второй кучи и по одному вставляем в первую. Вторая куча перестает существовать или становится пустой.

- **Сложность:** $O(m \log(n+m))$, где $m$ — размер меньшей кучи.
    

#### Слияние без разрушения

Мы создаем третий массив, копируем туда данные из обеих куч и вызываем функцию **Heapify** (построение кучи с нуля).

- **Сложность:** $O(n+m)$ (построение кучи из произвольного массива занимает линейное время).
    

---

### 6. Итоговая таблица сложностей

|**Операция**|**Сложность**|**Примечание**|
|---|---|---|
|**Поиск Min/Max**|$O(1)$|Элемент всегда в корне.|
|**Вставка**|$O(\log n)$|Путь от листа до корня.|
|**Удаление Min/Max**|$O(\log n)$|Путь от корня до листа.|
|**Слияние**|$O(n)$|Самый эффективный способ — пересборка.|