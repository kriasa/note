Отношение эквивалентности на пространстве элементов. Кастомизация операции отношения эквивалентности для заданного контекста в языке C. Алгоритм дихотомического поиска, его алгоритмическая сложность. 

## 1. Отношение эквивалентности

**Отношение эквивалентности** — это бинарное отношение на множестве, которое обладает тремя обязательными свойствами:

1. **Рефлексивность**: Элемент эквивалентен самому себе ($a \sim a$).
2. **Симметричность**: Если $a \sim b$, то $b \sim a$.
3. **Транзитивность**: Если $a \sim b$ и $b \sim c$, то $a \sim c$.
    

**Главный смысл**: Отношение эквивалентности разбивает всё множество элементов на непересекающиеся группы, называемые **классами эквивалентности**. Внутри одного класса все элементы считаются «одинаковыми» с точки зрения заданного правила.

---

## 2. Кастомизация отношения эквивалентности в Си

В языке Си эквивалентность чаще всего реализуется через функции сравнения, возвращающие логическое значение (истина/ложь). В отличие от отношения порядка (`qsort`), где важна разница «больше/меньше», здесь нас интересует только **совпадение критериев**.

### Пример: Эквивалентность строк без учета регистра

Для стандартного Си строки `"Apple"` и `"apple"` — разные. Мы можем кастомизировать это правило.


```c
#include <stdio.h>
#include <ctype.h>
#include <stdbool.h>

// Кастомная функция эквивалентности
bool are_equivalent(const char *s1, const char *s2) {
    if (s1 == s2) return true; // Рефлексивность
    
    while (*s1 && *s2) {
        if (tolower((unsigned char)*s1) != tolower((unsigned char)*s2)) {
            return false;
        }
        s1++;
        s2++;
    }
    return *s1 == *s2;
}

int main() {
    char str1[] = "Hello";
    char str2[] = "HELLO";

    if (are_equivalent(str1, str2)) {
        printf("Строки эквивалентны в данном контексте.\n");
    }
    return 0;
}
```

**Где это применяется:**

- Поиск дубликатов в базе данных (например, по ID или email).
- Группировка объектов в сложные структуры (хеш-таблицы).
    

---

## 3. Алгоритм дихотомического поиска

**Дихотомический (бинарный) поиск** — это классический алгоритм поиска элемента в **отсортированном** массиве данных.

### Суть алгоритма:

Алгоритм работает по принципу «разделяй и властвуй». Вместо того чтобы проверять каждый элемент по очереди, мы на каждом шаге делим область поиска пополам.

1. Выбираем средний элемент массива.
2. Если он равен искомому — цель достигнута.
3. Если средний элемент **больше** искомого — повторяем поиск в левой половине.
4. Если средний элемент **меньше** искомого — повторяем поиск в правой половине.
    

### Реализация на языке C:

```c
int binary_search(int arr[], int size, int target) {
    int left = 0;
    int right = size - 1;

    while (left <= right) {
        int mid = left + (right - left) / 2; // Защита от переполнения (left + right)

        if (arr[mid] == target) {
            return mid; // Эквивалентность найдена
        }
        if (arr[mid] < target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return -1; // Элемент не найден
}
```

---

## 4. Алгоритмическая сложность

Бинарный поиск является одним из самых эффективных алгоритмов.

### Временная сложность:

- **Худший и средний случаи**: $O(\log n)$.
    
    - _Пример_: Если в массиве 1 024 элемента, алгоритм найдет нужный (или скажет, что его нет) максимум за 10 шагов ($2^{10} = 1024$). Для 1 000 000 элементов потребуется всего ~20 шагов.
        
- **Лучший случай**: $O(1)$ (если искомый элемент оказался ровно посередине при первой проверке).
    

### Пространственная сложность:

- **Итеративный подход**: $O(1)$ (используем только несколько переменных для индексов).
    
- **Рекурсивный подход**: $O(\log n)$ (из-за затрат памяти на стек вызовов).
    

---

## Важные выводы для билета:

1. **Связь понятий**: Дихотомический поиск работает на отношении **порядка** ($<$ и $>$), но его цель — найти **эквивалентный** элемент ($==$).
    
2. **Главное условие**: Дихотомический поиск **невозможен** в неупорядоченном массиве.
    
3. **Преимущество**: При больших объемах данных $O(\log n)$ колоссально быстрее линейного поиска $O(n)$.

---

### 1. Математический фундамент: Классы эквивалентности

Когда мы задаем отношение эквивалентности $\sim$ на множестве $A$, всё это множество распадается на **классы эквивалентности**.

- Каждый элемент принадлежит ровно одному классу.
    
- Любые два элемента из одного класса эквивалентны между собой.
    
- Любые два элемента из разных классов **не** эквивалентны.
    

Пример из жизни: Отношение «иметь тот же цвет».

Если у нас есть красные, синие и зеленые шары, то все красные шары образуют один класс эквивалентности. Нам не важно, какой именно это красный шар, с точки зрения цвета они — одно и то же.

---

### 2. Зачем это нужно программисту?

В программировании отношение эквивалентности используется повсеместно, часто незаметно для нас:

1. **Хеширование (Hash Maps):** Чтобы `HashMap` работал, нам нужно два правила:
    
    - Как вычислить хеш (число).
        
    - Как понять, что два объекта «одинаковые» (отношение эквивалентности), если их хеши совпали.
        
2. **Базы данных:** Операция `GROUP BY` в SQL — это и есть разбиение на классы эквивалентности по заданному столбцу.
    
3. **Оптимизация компилятора:** Компилятор ищет эквивалентные выражения (например, `a = b + c` и `x = b + c`), чтобы вычислить их один раз и сэкономить время.
    

---

### 3. Реализация на C: Сложные случаи

В простых случаях мы используем `==`. Но для структур данных мы сами определяем, что считать эквивалентностью. Это называется **логической эквивалентностью** (в противовес побитовому равенству).

#### Пример: Эквивалентность дробей

Дроби $\frac{1}{2}$ и $\frac{2}{4}$ — это разные наборы данных в памяти (разные числители и знаменатели), но они **эквивалентны** как числа.

C

```
#include <stdio.h>
#include <stdbool.h>

typedef struct {
    int num; // числитель
    int den; // знаменатель
} Fraction;

// Кастомизация отношения эквивалентности
bool fractions_equal(Fraction f1, Fraction f2) {
    // Используем основное свойство пропорции: a/b = c/d <=> a*d == b*c
    return f1.num * f2.den == f2.num * f1.den;
}

int main() {
    Fraction a = {1, 2};
    Fraction b = {2, 4};

    if (fractions_equal(a, b)) {
        printf("Дроби эквивалентны\n");
    }
    return 0;
}
```

---

### 4. Отношение эквивалентности vs Идентичность

Важно различать эти понятия, особенно в контексте указателей:

- **Идентичность (Identity):** Два указателя указывают на **один и тот же** адрес в памяти. Это самое строгое равенство (`ptr1 == ptr2`).
    
- **Эквивалентность (Equivalence):** Две разные области памяти содержат данные, которые мы **договорились** считать одинаковыми.
    

---

### 5. Проверка свойств (Для экзамена)

Если на экзамене тебя попросят доказать, что твоя функция является отношением эквивалентности, ты должна проверить:

1. **Рефлексивность:** `equals(A, A)` всегда `true`?
    
2. **Симметричность:** Если `equals(A, B)` истинно, то и `equals(B, A)` истинно?
    
3. **Транзитивность:** Если `equals(A, B)` и `equals(B, C)`, то следует ли из этого `equals(A, C)`?
    

> **Интересный факт:** Если ты нарушишь хотя бы одно свойство (например, транзитивность) в функции сравнения для `std::sort` или `qsort`, программа может уйти в бесконечный цикл или вылететь с ошибкой сегментации. Алгоритмы очень доверяют твоей математической честности!