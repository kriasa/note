Динамическое выделение памяти. Функции malloc, calloc, realloc, free. Оператор sizeof.

# Концептуальная основа динамического выделения памяти

Динамическая память выделяется из кучи (heap) — области памяти процесса, управляемой ОС и библиотекой в runtime.

- **Статическое/Автоматическое выделение (Стек):** Память выделяется для глобальных и локальных переменных во время компиляции или выполнения функции и автоматически освобождается при выходе из области видимости. Размер должен быть известен заранее.
    
- **Динамическое выделение (Куча/Heap):** Память выделяется явно во время **выполнения программы (Runtime)**. Программист сам определяет размер и **обязан** сам освободить эту память.

Отличие от стека заключается в том, что память не выделяется и не очищается автоматическе, а требует явного управления.
### Структура адресного пространства
- Сегмент кода (text) — исполняемый код программы
- Область данных — глобальные и статические переменные
- Куча — растет вверх, управляется через *malloc/free*
- Стек — растет вниз, управляется автоматически

**Критическое отличие**: стековая память освобождается автоматически, динамическая — только явным вызовом `free()`. Отсутствие освобождения приводит к **утечкам памяти (memory leak)**.

---
## Func *malloc*

**Назначение:** Выделяет блок памяти указанного размера в байтах.

```c
void* malloc(size_t size);
```
#### Семантика работы

- Выделяет непрерывный (последовательный) блок, size - Количество **байтов**, которое нужно выделить.
- Указатель типа `void*` на начало выделенного блока. В случае ошибки (недостаточно памяти) возвращает `NULL`.
- Память не инициализируется (содержит мусор)
```c
int *array = (int*) malloc(10 * sizeof(int));
```
## Func *сalloc*

**Назначение:** Выделяет память для указанного числа элементов, каждый из которых имеет указанный размер, и **инициализирует** весь блок **нулями**.

```c
void* calloc(size_t nmemb, size_t size);
```
#### Семантика работы
- Принимает два аргумента количество элементов `nmemb` и размер элемента  `size`.
- Выделяет непрерывный (последовательный) блок, размером *size* байт из кучи
- *Returns* `void*` на начало выделенного блока памяти 
	- В случае ошибки возвращает `NULL`
- Память инициализируется (заполняется нулями 0 или NULL)
```c
int *array = (int*) calloc(10, sizeof(int)); // Все 10 элементов равны 0
```
## Func *realloc*

**Назначение:** Изменяет размер ранее выделенного блока памяти.
```c
void* realloc(void *ptr, size_t new_size);
```

|**Параметр**|**Описание**|
|---|---|
|`ptr`|Указатель на существующий блок, выделенный ранее (`malloc`, `calloc`, `realloc`).|
|`new_size`|Новый желаемый размер блока в байтах.|
|**Возврат**|Указатель типа `void*` на новый блок (который может быть расположен по другому адресу) или `NULL` при ошибке.|
**Особенности:**

- **Перемещение:** Если новый размер больше старого, `realloc` пытается расширить блок на месте. Если это невозможно, он выделяет новый блок, **копирует** содержимое старого блока в начало нового, и **освобождает** старый блок.
    
- **Сохранение данных:** Содержимое, которое помещается в новый блок, остается неизменным. Новая добавленная область памяти **не инициализируется**.
    
- **Использование для уменьшения:** Может использоваться для уменьшения размера блока.
    
- **Особые случаи:**
    
    - Если `ptr` равен `NULL`, `realloc(NULL, new_size)` работает как `malloc(new_size)`.
        
    - Если `new_size` равен `0`, `realloc` освобождает память и возвращает `NULL` (работает как `free`).
##### Важно!
> При использовании `realloc` использовать временный указатель, во избежание утечки памяти, в случае неудачи аллокатора.

```c
int *temp = (int*) realloc(array, 20 * sizeof(int));
if (temp != NULL) {
    array = temp; // Успешно изменили размер массива до 20 элементов
}
```
---
## Func *free*

**Назначение:** Освобождает блок памяти в куче, который был ранее выделен функциями `malloc`, `calloc` или `realloc`.

```c
void free(void *ptr);
```
### Семантика:
- Освобождает память, ранее выделенную malloc/calloc/realloc
- После вызова указатель становится **висячим (dangling pointer)** — указывает на освобожденную память Чтобы избежать ошибок, рекомендуется сразу присвоить ему `NULL`: `ptr = NULL;`.
- Передача `NULL` — **безопасна** и ничего не делает (стандарт C гарантирует)
- Передача невалидного указателя — **неопределенное поведение (UB)**: может вызвать segmentation fault или повреждение кучи
### Критические ошибки:
- **Double free** — двойное освобождение
- **Use after free** — использование после освобождения:

## Оператор *sizeof*

Оператор `sizeof` не является функцией, а является **унарным оператором**, который вычисляется **на этапе компиляции** (за исключением случаев с VLA — массивами переменной длины).

Определяет размер в **байтах** типа данных или выражения.

### Возвращаемый тип:

`size_t` — беззнаковый целочисленный тип, достаточный для хранения размера любого объекта в памяти. На 64-битных системах обычно `unsigned long` (8 байт), на 32-битных — `unsigned int` (4 байта).

```c
sizeof(char)     // Всегда 1 (по стандарту C)
sizeof(int)      // Обычно 4, но НЕ гарантировано!
sizeof(double)   // Обычно 8
sizeof(void*)    // 8 на 64-бит, 4 на 32-бит

// Размер массива
int arr[10];
sizeof(arr)           // 40 байт (10 * sizeof(int))
sizeof(arr)/sizeof(arr[0])  // 10 — идиома для длины массива
```
Оператор `sizeof` **обязателен** при работе с `malloc` и `calloc`, так как он обеспечивает **переносимость** кода. Размеры типов данных (`int`, `long`, `pointer`) зависят от архитектуры и компилятора. Использование `sizeof` гарантирует, что программа всегда запрашивает правильное количество байтов, независимо от платформы.

### Особые случаи sizeof:
**VLA (Variable Length Arrays)** — исключение, вычисляется во время выполнения:
```c
int n = 10;
int vla[n];
sizeof(vla) // Вычисляется runtime: n * sizeof(int)
```

