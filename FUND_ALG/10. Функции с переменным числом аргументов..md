
 Функции с переменным числом аргументов. Типы данных и основные макросы для работы со списком аргументов переменной длины. Указатели на функции. Массив указателей на функции. Функция atexit.

# Функции с переменным числом аргументов (Variadic Functions)

Функции с переменным числом аргументов (Variadic Functions) позволяют передавать различное количество аргументов при каждом вызове (например, `printf`, `scanf`, `execl`).
### Синтаксис объявления

**Прототип:** Объявляется с использованием многоточия (`...`) после последнего **фиксированного** аргумента.

**Ключевой момент:** Должен быть хотя бы один **фиксированный** аргумент. Этот аргумент используется для определения, где в стеке начинается переменный список аргументов.

```c
#include <stdarg.h>

тип_возврата имя_функции(тип_фиксированный_1 arg1, ...);
```

# Типы данных для работы с variadic functions

Для доступа к аргументам из списка переменной длины используется заголовочный файл **`<stdarg.h>`** и набор макросов

|**Макрос/Тип**|**Назначение**|
|---|---|
|**`va_list`**|**Тип данных:** Указатель на список аргументов переменной длины.|
|**`va_start(ap, last_arg)`**|**Инициализация:** Устанавливает указатель `ap` на первый аргумент в переменном списке. `last_arg` — это имя последнего **фиксированного** аргумента.|
|**`va_arg(ap, type)`**|**Извлечение:** Возвращает следующий аргумент из списка и продвигает указатель `ap`. Необходимо **точно** указать **тип** извлекаемого аргумента.|
|**`va_end(ap)`**|**Очистка:** Выполняет необходимую очистку после завершения работы со списком (должен быть вызван обязательно).|
### va_list

**Что это по сути**: Это **непрозрачный тип данных** (opaque type), который хранит информацию о текущем состоянии обработки списка аргументов.

**Критически важно**: `va_list` — это **изменяемый объект**. Каждый вызов `va_arg()` модифицирует его внутреннее состояние, перемещая "указатель" на следующий аргумент.

# Основные макросы для работы с переменными аргументами

Все макросы определены в заголовочном файле `<stdarg.h>`.

### 1. va_start (MACRO!!)
```c
void va_start(va_list ap, lastNamedParam)
```
**Инициализирует** `va_list` для начала обработки перепменных.

**Параметры**:
- `ap` — переменная типа `va_list`
- `last_named_param` — имя последнего именованного параметра перед `...`

#### Что делает под капотом
```c
#define va_start(ap, last)  (ap = (char*)&last + ...)

va_start(ap, x);  
ap = (char*)&x + SIZE;  // раскрытый типа
```
- **Получение Адреса (`&last_arg`):**
    
    - Сначала берется адрес последнего **фиксированного** аргумента (`last_arg`, в вашем примере это `x`).
        
- **Приведение к `char*`:**
    
    - Адрес приводится к указателю на байт (`char*`). Это позволяет выполнять адресную арифметику **побайтово**, независимо от типа `last_arg`.
        
- **Смещение (`+ SIZE`):**
    
    - К адресу `last_arg` добавляется **размер** этого аргумента (`SIZE`), чтобы указатель проскочил сам `last_arg` и оказался точно на **начале следующего аргумента** в стеке.
### 2. va_arg (MACRO!!)
```c
TYPE va_arg(va_list ap, TYPE);
```

**Параметры**:
- `ap` — переменная типа `va_list`
- `TYPE` —  тип извлекаемого аргумента
**Returns**:
- TYPE — переменную типа TYPE

### 3. va_end (MACRO!!)
```c
void va_end(va_list ap);
```
**Важно**: Вызов `va_end` **обязателен** после каждого `va_start`! Это может быть критично на некоторых платформах, где `va_list` выделяет ресурсы.

**После вызова `va_end`**: Переменная `ap` становится неопределённой (undefined). Для повторного использования нужен новый `va_start`.

## Полный пример variadic function

```c
#include <stdarg.h>
#include <stdio.h>

// Функция суммирует count целых чисел
int sum(int count, ...) {
    va_list args;
    va_start(args, count);  // инициализация
    
    int total = 0;
    for (int i = 0; i < count; i++) {
        int value = va_arg(args, int);  // извлечение очередного аргумента
        total += value;
    }
    
    va_end(args);  // обязательное завершение
    return total;
}

int main() {
    printf("%d\n", sum(3, 10, 20, 30));     // 60
    printf("%d\n", sum(5, 1, 2, 3, 4, 5));  // 15
    return 0;
}
```

### Чем эта ебучая хуйня отличается от функции

## Чем Функция Отличается от Макроса?

| **Критерий**            | **Функция (Function)**                                                                      | **Макрос (Macro)**                                                                                                          |
| ----------------------- | ------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------- |
| **Этап обработки**      | **Компиляция** и **выполнение** (Runtime).                                                  | **Препроцессирование** (до компиляции).                                                                                     |
| **Механизм**            | Передача управления. Создание нового стекового кадра.                                       | Простая **текстовая подстановка** (`find and replace`).                                                                     |
| **Типобезопасность**    | **Полностью типобезопасна.** Компилятор проверяет типы аргументов и возвращаемого значения. | **Типонезависим.** Препроцессор не знает о типах.                                                                           |
| **Издержки (Overhead)** | При вызове есть небольшие издержки (push/pop регистров, создание стекового кадра).          | **Отсутствуют.** Код вставляется напрямую, что может ускорить выполнение.                                                   |
| **Размер кода**         | Код функции хранится в памяти **один раз**.                                                 | Код макроса вставляется в каждом месте использования, что может увеличить размер исполняемого файла (Code Bloat).           |
| **Аргументы**           | Аргументы вычисляются **один раз** перед передачей.                                         | Аргументы подставляются как текст и могут быть вычислены **несколько раз**, что может вызвать ошибки с побочными эффектами. |
Функции для работы с переменным числом аргументов (из `<stdarg.h>`) — **`va_start`**, **`va_arg`** и **`va_end`** — не могут быть реализованы как стандартные функции C, поскольку их работа требует доступа к метаинформации о типах и низкоуровневой манипуляции памятью, что доступно только на этапе препроцессирования.

### А. Причина 1: Необходимость Знать Тип (`va_arg`)

Макрос **`va_arg(ap, type)`** должен знать **тип данных** (`type`), который он должен извлечь из списка аргументов.

1. **Проблема Функции:** В языке C нет синтаксического механизма для передачи самого **типа данных** (`int`, `double`, `struct MyStruct`) в качестве аргумента функции. Функция может принимать только _значения_ или _указатели_ на значения.
    
2. **Решение Макроса:** Поскольку макрос работает как текстовая подстановка, он может использовать `type` для генерации двух частей кода:
    
    - **Разыменование:** Он генерирует код для правильного разыменования указателя, используя нужный тип, например: `*( (type*)ap )`.
        
    - **Смещение:** Он использует оператор `sizeof(type)` для определения, насколько нужно продвинуть указатель, чтобы перейти к следующему аргументу, например: `ap += sizeof(type)`.
        

Только макрос может **вставить информацию о типе** (`(type*)` и `sizeof(type)`) в код до его компиляции.

### Б. Причина 2: Низкоуровневая Манипуляция Памятью (`va_start`)

Макрос **`va_start(ap, last_arg)`** должен определить точное место в памяти (в стеке или регистрах), где начинается переменный список аргументов.

1. **Проблема Функции:** Стандартная функция C не имеет доступа к внутренней структуре стекового кадра вызывающей функции.
    
2. **Решение Макроса:** Макрос выполняет низкоуровневую адресную арифметику, используя адрес последнего фиксированного аргумента (`&last_arg`), чтобы вычислить адрес следующего аргумента.
    
    - Логика под капотом:
        $$\text{ap} = (\text{char*})\& \text{last\_arg} + \text{смещение}$$
        
    - Это смещение зависит от архитектуры и правил передачи аргументов, но его расчет требует прямого доступа к адресу `last_arg` и его размеру.
---

# Указатели на функции
### Определение

**Указатель на функцию** — это переменная, которая хранит адрес памяти, с которого начинается исполняемый код функции.

Указатели на функции позволяют: 
- Передавать функции как аргументы. 
- Хранить массивы функций. 
- Вызывать функции через указатель. 

#### Синтаксис объявления

```c
тип_возврата (*имя_указателя)(типы_параметров);

int (*ptr_func)(int, int);     // указатель на функцию
int *func_ptr(int, int);       // функция, возвращающая int* (не то!)
```

| Объявление       | Что это                      |
| ---------------- | ---------------------------- |
| `int *p;`        | указатель на `int`           |
| `int (*f)(int);` | указатель на функцию         |
| `int *f(int);`   | функция, возвращающая `int*` |

- `int (*ptr_func)`: Указывает, что `ptr_func` — это указатель, возвращающий `int`.
    
- `(int, int)`: Указывает, что функция, на которую он указывает, принимает два аргумента `int`.
```c
#include  <stdio.h> 
// Обычная функция 
int add(int a, int b) { 
    return a + b; 
} 
int main() { 
// Указатель на функцию 
    int (*func_ptr)(int, int) = add; 
    
    // Вызов функции через указатель 
    printf("Sum: %d\n", func_ptr(3, 4)); 
    // Сумма: 7 
    return 0; 
}
```
# Массив указателей на функции

**Массив указателей на функции** используется для реализации **диспетчеризации** (Dispatch Table) — механизма, который позволяет выбирать функцию для выполнения во время выполнения программы, используя индекс (например, для реализации меню или конечного автомата).

### Синтаксис объявления

```c
#include <stdio.h>

int add(int a, int b) { return a + b; }
int subtract(int a, int b) { return a - b; }
int multiply(int a, int b) { return a * b; }
int divide(int a, int b) { return a / b; }

int main() {
    // Массив указателей на функции
    int (*operations[4])(int, int) = {add, subtract, multiply, divide};
    
    char *op_names[] = {"+", "-", "*", "/"};
    
    int x = 10, y = 5;
    
    for (int i = 0; i < 4; i++) {
        printf("%d %s %d = %d\n", x, op_names[i], y, operations[i](x, y));
    }
    
    return 0;
}
```

**Вывод**:
```c
10 + 5 = 15
10 - 5 = 5
10 * 5 = 50
10 / 5 = 2
```

---

# Функция atexit (defer-like)

Функция `atexit` (определена в `<stdlib.h>`) позволяет регистрировать функции, которые будут автоматически вызваны при **нормальном завершении** программы.

- **Нормальное завершение:** Вызов `return` из `main` или вызов функции `exit()`.
- **Использование:** Идеально подходит для задач очистки ресурсов: закрытие файлов, освобождение динамически выделенной памяти, запись логов.

**Прототип**:
```c
#include <stdlib.h>

int atexit(void (*function)(void));
```
Функция atexit регистрирует функции, которые будут вызваны автоматически при завершении программы. Эти функции выполняются в порядке, обратном их регистрации.

**Возвращает**:
- `0` при успешной регистрации
- Ненулевое значение при ошибке

```c
#include <stdio.h>
#include <stdlib.h>
// Завершающие функции 
void goodbye() { printf("Goodbye!\n"); } 
void saveData() { printf("Saving data...\n"); }

int main() { 
    atexit(goodbye); // Регистрируем функцию 
    atexit(saveData); 
    printf("Program is running...\n"); 
    return 0; // При завершении вызовутся функции atexit
}
```

Вывод: 
Program is running... 
Saving data... 
Goodbye

- **Аргумент:** `atexit` принимает указатель на функцию, которая **не принимает аргументов** (`void`) и **не возвращает значения** (`void`).
    
- **Порядок вызова:** Зарегистрированные функции вызываются в **обратном порядке** по отношению к порядку их регистрации (LIFO: Last In, First Out).
    
- **Ограничение:** Регистрируемые функции **не** вызываются при аномальном завершении программы (например, при получении сигнала `SIGKILL` или сбое сегментации).
### Правила работы atexit

1. **Порядок вызова**: LIFO (Last In, First Out) — последняя зарегистрированная функция вызывается первой
2. **Количество**: Стандарт гарантирует минимум **32** функции, многие реализации поддерживают больше
3. **Сигнатура**: Функция должна иметь тип `void (*)(void)` — без параметров и без возврата
4. **Не вызывается**: При аварийном завершении (сигналы, `abort()`, `_Exit()`)